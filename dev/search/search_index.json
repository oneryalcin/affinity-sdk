{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Affinity Python SDK","text":"<p>A modern, strongly-typed Python wrapper for the Affinity CRM API.</p> <p>Disclaimer: This is an unofficial community project and is not affiliated with, endorsed by, or sponsored by Affinity. \u201cAffinity\u201d and related marks are trademarks of their respective owners. Use of the Affinity API is subject to Affinity\u2019s Terms of Service.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install affinity-sdk\n</code></pre> <p>Requires Python 3.10+.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    me = client.whoami()\n    print(me.user.email)\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Getting started - Authentication, first request, common patterns</li> <li>Examples</li> <li>CLI</li> <li>AI Integrations - MCP Server &amp; Claude Code plugins</li> <li>Troubleshooting</li> <li>API reference</li> </ul>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Authentication - API keys, env vars, context managers</li> <li>Pagination - Iterating large result sets</li> <li>Filtering - Filter query syntax</li> <li>Field values - Custom field data</li> <li>Errors &amp; retries - Exception handling</li> <li>Rate limits - Managing API quotas</li> <li>Datetime handling - Timezone behavior</li> <li>Sync vs async - Choosing the right client</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#101-2026-02-01","title":"[1.0.1] - 2026-02-01","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>SDK: <code>InteractionService.list()</code> and <code>iter()</code> now validate that <code>type</code> parameter is required, raising <code>ValueError</code> with clear guidance instead of failing with cryptic API 422 errors. The Affinity V1 API has always required this parameter.</li> <li>CLI: <code>--check-unreplied</code> and <code>expand: [\"unreplied\"]</code> now work correctly. Previously, all unreplied checks silently failed (returning null) due to missing <code>type</code> parameter in interaction API calls.</li> <li>CLI: Query <code>dryRun</code> JSON output now includes a warning when estimated API calls exceed 50, helping LLMs notice expensive operations.</li> </ul>"},{"location":"changelog/#100-2026-01-31","title":"[1.0.0] - 2026-01-31","text":"<p>First stable release. The SDK and CLI APIs are now considered stable. Breaking changes will follow semantic versioning (major version bumps).</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>CLI: Auto-update notifications. The CLI now checks PyPI daily (in background) and displays a notification when a new version is available. Notifications are suppressed in non-interactive environments (<code>--quiet</code>, <code>--output json</code>, CI, no TTY). Disable with <code>XAFFINITY_NO_UPDATE_CHECK=1</code> or <code>update_check = false</code> in config.</li> <li>CLI: <code>xaffinity config update-check --background</code> flag for non-blocking update checks. Used by MCP server to trigger background updates without waiting for results.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>MCP: Add <code>AFFINITY_API_KEY</code> to environment variable allowlist. API keys configured in Claude Desktop's MCP settings were being silently dropped, requiring manual config file creation as a workaround.</li> <li>MCP: Detect CLI in macOS Python framework path (<code>/Library/Frameworks/Python.framework/Versions/*/bin/</code>). Users who installed via <code>pip install</code> with python.org Python were getting \"xaffinity: command not found\" errors.</li> </ul>"},{"location":"changelog/#0161-2026-01-27","title":"[0.16.1] - 2026-01-27","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Docs: \"Verify Installation\" section in CLI documentation with step-by-step health check instructions (<code>xaffinity --version</code>, <code>AFFINITY_API_KEY=... xaffinity whoami</code>).</li> </ul>"},{"location":"changelog/#0160-2026-01-26","title":"[0.16.0] - 2026-01-26","text":""},{"location":"changelog/#changed-breaking","title":"Changed (Breaking)","text":"<ul> <li>SDK: <code>Person.interactions</code> and <code>Company.interactions</code> attribute type changed from <code>dict[str, Any]</code> to typed <code>Interactions</code> model. Migration: change dict access (<code>person.interactions[\"last_event\"][\"person_ids\"]</code>) to attribute access (<code>person.interactions.last_event.person_ids</code>). The <code>Interactions</code> model provides typed access to <code>first_email</code>, <code>last_email</code>, <code>first_event</code>, <code>last_event</code>, <code>next_event</code>, <code>last_chat_message</code>, and <code>last_interaction</code> fields, each containing an <code>InteractionEvent</code> with <code>date</code> and <code>person_ids</code> attributes.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>SDK: <code>PersonService.get()</code> field values are now properly validated as <code>FieldValue</code> models.</li> </ul>"},{"location":"changelog/#0151-2026-01-25","title":"[0.15.1] - 2026-01-25","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>CLI: <code>query --output json</code> now supports cursor-based pagination when output is truncated. Previously, JSON truncation happened at the MCP layer after CLI execution, so no cursor was emitted. Now JSON truncation happens in the CLI layer (same as other formats), enabling proper resumption via <code>--cursor</code>.</li> </ul>"},{"location":"changelog/#0150-2026-01-23","title":"[0.15.0] - 2026-01-23","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>CLI: <code>company files read</code>, <code>person files read</code>, <code>opportunity files read</code> commands to read file content with chunking support. Returns base64-encoded content with metadata (<code>size</code>, <code>offset</code>, <code>length</code>, <code>hasMore</code>, <code>nextOffset</code>). Use <code>--offset</code> and <code>--limit</code> to fetch large files in chunks. Default chunk size is 1MB.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>CLI: <code>--env-file</code> now implicitly enables dotenv loading when an explicit file path is provided (not the default <code>.env</code>). Previously, using <code>--env-file .sandbox.env</code> without <code>--dotenv</code> would silently ignore the file.</li> <li>CLI: Fixed dropdown field value resolution in <code>entry field --set</code> and <code>--append</code> commands. The V2 API requires <code>{\"dropdownOptionId\": ID}</code> format, but the CLI was sending raw values. Now dropdown text (e.g., \"In Progress\") or numeric IDs are properly resolved to the V2 API format.</li> <li>CLI: List field metadata now fetched from V1 API to include <code>dropdown_options</code>, which V2 API omits.</li> </ul>"},{"location":"changelog/#0140-2026-01-22","title":"0.14.0 - 2026-01-22","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>CLI: <code>company files ls</code>, <code>person files ls</code>, <code>opportunity files ls</code> commands to list files attached to entities without downloading them. Supports pagination (<code>--page-size</code>, <code>--cursor</code>, <code>--max-results</code>, <code>--all</code>), selector resolution (ID, URL, name, domain, email), and MCP safety limits.</li> <li>CLI: <code>file-url</code> command to get presigned download URLs for files. Returns URL valid for 60 seconds along with file metadata (name, size, contentType). Useful for programmatic access and MCP workflows.</li> <li>CLI: <code>files download --file-id</code> option for single-file downloads. Downloads one file directly without creating a manifest.</li> <li>SDK: <code>FilesService.get_download_url(file_id)</code> method to get presigned download URLs without downloading content. Returns <code>PresignedUrl</code> with URL, file metadata, and expiration info.</li> <li>SDK: <code>PresignedUrl</code> dataclass exported from <code>affinity</code> package with fields: <code>url</code>, <code>file_id</code>, <code>name</code>, <code>size</code>, <code>content_type</code>, <code>expires_in</code>, <code>expires_at</code>.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>CLI: <code>files dump</code> renamed to <code>files download</code> for clarity.</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>SDK: <code>CompanyService.get()</code> and <code>PersonService.get()</code> now automatically fall back to V1 API when V2 returns 404. This handles V1\u2192V2 eventual consistency issues where a search (<code>company ls --query</code>, <code>person ls --query</code>) finds an entity via V1, but a subsequent <code>get</code> fails because V2 hasn't synced yet. The fallback is transparent and requires no code changes.</li> </ul>"},{"location":"changelog/#known-issues","title":"Known Issues","text":"<ul> <li>MCP: <code>get-file-url</code> tool returns valid presigned URLs, but Claude Desktop's WebFetch cannot access <code>userfiles.affinity.co</code> due to domain sandbox restrictions. This affects all Claude Desktop users - neither \"Additional allowed domains\" nor \"All domains\" settings work around this limitation (#19087, #11897). Workaround: Use <code>files read</code> command (returns content inline), copy URL to browser, or use CLI directly with <code>files download --file-id</code>.</li> </ul>"},{"location":"changelog/#0131-2026-01-21","title":"0.13.1 - 2026-01-21","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>CLI: Query progress now emits <code>progress: 0</code> in <code>on_step_start</code> events, enabling mcp-bash timeout extension for slow first-page fetches</li> </ul>"},{"location":"changelog/#0130-2026-01-21","title":"0.13.0 - 2026-01-21","text":""},{"location":"changelog/#changed-breaking_1","title":"Changed (Breaking)","text":"<ul> <li>SDK: <code>AffinityList.list_size</code> field removed. The V2 API returns incorrect values (often 0 for non-empty lists). Use <code>client.lists.get_size(list_id)</code> instead, which fetches from the V1 API and caches for 5 minutes.</li> </ul>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>SDK: <code>ListService.get_size(list_id)</code> and <code>AsyncListService.get_size(list_id)</code> methods to get accurate list size from the V1 API with automatic caching (5 minutes). Use <code>force=True</code> to bypass cache when fresh data is critical.</li> </ul>"},{"location":"changelog/#0120-2026-01-20","title":"0.12.0 - 2026-01-20","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>CLI: <code>query --cursor</code> option for resumable pagination when responses are truncated (exceed <code>--max-output-bytes</code>):</li> <li>Streaming mode (simple queries): O(1) resumption via stored Affinity API cursor - no re-fetching of previous pages</li> <li>Full-fetch mode (queries with orderBy/aggregate): Results cached to disk, zero API calls on resume</li> <li>Cursor emitted to stderr as NDJSON <code>{\"type\": \"cursor\", \"cursor\": \"...\", \"mode\": \"...\"}</code> for MCP extraction</li> <li>CLI exits with code 100 when truncated (cursor available)</li> <li>Cache auto-cleanup on startup: LRU eviction (500MB limit), 1-hour TTL</li> <li>Validation: query hash, format mismatch, cache tampering all detected with clear errors</li> </ul>"},{"location":"changelog/#0110-2026-01-20","title":"0.11.0 - 2026-01-20","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>CLI: Full scan protection when running via MCP gateway. Commands with pagination (<code>list export</code>, <code>person ls</code>, <code>company ls</code>, etc.) now enforce limits: default 1000 records, max 10000 records. The <code>--all</code> flag is blocked with a clear error message guiding users to use explicit <code>--max-results</code> or cursor pagination instead.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>CLI: <code>--csv</code> is now an alias for <code>--output csv</code> (consistent with <code>--json</code> being an alias for <code>--output json</code>)</li> <li>CLI: CSV sub-options (<code>--csv-bom</code>, <code>--csv-header</code>, <code>--csv-mode</code>) auto-enable CSV output when no format is specified</li> <li>CLI: Error messages for output flag conflicts no longer have trailing periods (e.g., <code>--csv and --json are mutually exclusive</code> instead of ending with <code>.</code>)</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Breaking: CLI: <code>--pretty</code> flag removed from <code>query</code> command (use <code>| jq .</code> for pretty JSON output)</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>CLI: Query engine now correctly computes <code>entityName</code> for Person list entries. Previously, <code>entityName</code> was <code>null</code> for persons because the API returns <code>firstName</code>/<code>lastName</code> instead of <code>name</code>. Now uses the same display name logic as <code>list export</code>.</li> <li>CLI: Table/CSV formatters now correctly detect Person entities with real API types (<code>external</code>/<code>internal</code>) or no type field. Previously, formatters only checked for <code>type=\"person\"</code> which the API never actually returns, causing Person data to display as \"object (N keys)\" instead of \"John Smith (id=123)\".</li> </ul>"},{"location":"changelog/#performance","title":"Performance","text":"<ul> <li>CLI: Session cache now caches person resolution (by email/name) and company resolution (by domain/name), reducing API calls when running multiple commands in a session pipeline.</li> <li>CLI: Person and company field resolution now uses session cache, avoiding redundant field definition fetches.</li> </ul>"},{"location":"changelog/#0100-2026-01-19","title":"0.10.0 - 2026-01-19","text":""},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>SDK: Removed unsafe <code>asyncio.create_task()</code> in <code>AsyncAffinity.__del__</code> that could cause tasks to be garbage collected before completion. Users must now use context managers or call <code>close()</code> explicitly.</li> <li>SDK: Added thread-safe locking to <code>SimpleCache</code> for concurrent access.</li> <li>SDK: Fixed async client initialization race condition with asyncio lock.</li> <li>SDK: Fixed stream context manager cleanup on errors in HTTP client.</li> <li>SDK: Fixed empty/whitespace content handling in JSON response parsing.</li> <li>SDK: Added error handling for partial file cleanup on download failures.</li> <li>SDK: Improved filename sanitization for server-provided filenames (null bytes, control chars).</li> <li>CLI: Added validation for <code>--timeout</code>, <code>--max-columns</code>, <code>--max-records</code>, <code>--max-output-bytes</code> to reject non-positive values.</li> <li>CLI: Added validation for <code>--env-file</code> to check file exists when <code>--dotenv</code> is enabled.</li> <li>CLI: Added file size limit (1MB) for config files to prevent memory exhaustion.</li> <li>CLI: Added file permission warnings for API key files (same as config files).</li> <li>CLI: Fixed TOML escaping to handle newlines, tabs, and carriage returns in API keys.</li> <li>CLI: Fixed JSON/TOML parse error handling with helpful error messages.</li> <li>CLI: Fixed type validation for list access in CSV/table output (verify first element is dict).</li> <li>CLI: Fixed exponential backoff calculation to cap exponent before computing power.</li> <li>CLI: Let <code>AuthenticationError</code>/<code>AuthorizationError</code> propagate in query executor instead of silent catch.</li> <li>CLI: Added logging to silent exception handlers in entity validation.</li> </ul>"},{"location":"changelog/#changed-breaking_2","title":"Changed (Breaking)","text":"<ul> <li>CLI: <code>--check-unreplied-emails</code> renamed to <code>--check-unreplied</code> with support for both email and chat messages.</li> <li>New <code>--unreplied-types</code> flag: comma-separated list of types to check (<code>email</code>, <code>chat</code>, <code>all</code>). Default: <code>email,chat</code></li> <li>Output now includes <code>type</code> field (\"email\" or \"chat\") in addition to date, daysSince, and subject</li> <li>Chat messages have <code>null</code> subject (no subject attribute)</li> <li>Cross-type reply detection: email replied via chat (or vice versa) counts as \"replied\"</li> <li>CLI: Query <code>expand: [\"unrepliedEmails\"]</code> renamed to <code>expand: [\"unreplied\"]</code></li> <li>Same cross-type reply detection and multi-type support as CLI flag</li> <li>CSV columns renamed: <code>unrepliedEmailDate</code> \u2192 <code>unrepliedDate</code>, <code>unrepliedEmailDaysSince</code> \u2192 <code>unrepliedDaysSince</code>, <code>unrepliedEmailSubject</code> \u2192 <code>unrepliedSubject</code>, plus new <code>unrepliedType</code> column</li> </ul>"},{"location":"changelog/#0914-2026-01-19","title":"0.9.14 - 2026-01-19","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>CLI: Query <code>select</code> clause now automatically includes <code>expand</code> fields. Previously, using <code>select</code> with <code>expand</code> would filter out the expansion data (e.g., <code>interactionDates</code>, <code>unreplied</code>), requiring users to explicitly list expansions in <code>select</code>.</li> </ul>"},{"location":"changelog/#0913-2026-01-19","title":"0.9.13 - 2026-01-19","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>CLI: Query <code>include</code> for <code>listEntries</code> now supports <code>persons</code>, <code>companies</code>, <code>opportunities</code>, and <code>interactions</code>. Fetches related entities based on list entry entity type (e.g., company entries get associated persons).</li> <li>CLI: Query <code>expand: [\"unrepliedEmails\"]</code> now works with <code>listEntries</code>. Checks each list entry's underlying entity for unreplied incoming emails.</li> <li>CLI: Query extended include syntax with parameters:</li> <li><code>{include: {interactions: {limit: 50, days: 180}}}</code> - Limit and lookback control</li> <li><code>{include: {opportunities: {list: \"Pipeline\"}}}</code> - Scope to specific opportunity list</li> <li><code>{include: {persons: {where: {...}}}}</code> - Filter included entities</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>CLI: Query TOON format now correctly flattens <code>fields.*</code> and <code>interactionDates</code> like markdown and CSV formats do. Previously, TOON was missing the <code>_apply_explicit_flattening()</code> call, causing nested fields to be truncated and interaction dates to be missing entirely.</li> <li>CLI: <code>list export --check-unreplied-emails</code> now works standalone without requiring <code>--expand</code>.</li> <li>CLI: <code>expand: [\"interactionDates\"]</code> now always produces 8 canonical columns regardless of data presence, ensuring consistent schema across all records.</li> <li>SDK: Improved error message when adding wrong entity type to a list (e.g., adding a company to a person list). Now provides clear guidance about list type requirements instead of exposing raw API validation error.</li> </ul>"},{"location":"changelog/#performance_1","title":"Performance","text":"<ul> <li>CLI: Query <code>expand: [\"interactionDates\"]</code> is significantly faster with parallel person resolution, bounded concurrent fetches (semaphore=10), and parallelized section resolution. Default concurrency increased from 5 to 15 (tunable via <code>XAFFINITY_QUERY_CONCURRENCY</code>).</li> </ul>"},{"location":"changelog/#0912-2026-01-17","title":"0.9.12 - 2026-01-17","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>CLI: Query <code>listEntries</code> now normalizes reference field values to display strings:</li> <li>Person fields: <code>{\"firstName\": \"Jane\", \"lastName\": \"Doe\"}</code> \u2192 <code>\"Jane Doe\"</code></li> <li>Company fields: <code>{\"name\": \"Acme Corp\", \"id\": 123}</code> \u2192 <code>\"Acme Corp\"</code></li> <li>Multi-person/company fields: Arrays of names instead of raw objects</li> <li>Use <code>expand</code> or <code>include</code> for full entity data when needed</li> <li>CLI: Query output with explicit <code>select</code> on <code>fields.*</code> paths now flattens fields to top-level columns in table/CSV/markdown formats. JSON output preserves nested structure.</li> </ul>"},{"location":"changelog/#0911-2026-01-17","title":"0.9.11 - 2026-01-17","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>CLI: Query <code>include</code> clause now displays included relationships inline by default. Use <code>--include-style=separate</code> for separate tables or <code>--include-style=ids-only</code> for raw IDs. JSON output includes full <code>included</code> and <code>included_by_parent</code> mappings for correlation.</li> <li>CLI: Query <code>include</code> extended syntax for custom display fields: <code>include: {companies: {display: [\"name\", \"domain\"]}}</code>.</li> <li>SDK: <code>with_interaction_dates</code> and <code>with_interaction_persons</code> parameters for <code>CompanyService.get()</code> and <code>PersonService.get()</code>. When enabled, routes to V1 API to fetch interaction date summaries (last/next meeting, email dates, team member IDs).</li> <li>CLI: <code>--expand interactions</code> option for <code>list export</code> command. Adds interaction date summaries to each list entry (last meeting, next meeting, last email, last interaction with daysSince/daysUntil calculations and team member names). Supports both JSON and CSV output formats.</li> <li>CLI: <code>expand: [\"interactionDates\"]</code> support in <code>query</code> command. Enriches records with interaction date summaries directly on each record in <code>result.data</code>. Works with <code>persons</code>, <code>companies</code>, and <code>listEntries</code> queries.</li> <li>CLI: <code>--check-unreplied-emails</code> flag for <code>list export</code> command. Detects unreplied incoming emails for each list entry and adds date, daysSince, and subject to output. Use <code>--unreplied-lookback-days</code> to configure lookback period (default: 30 days).</li> <li>CLI: <code>--with-interaction-dates</code> and <code>--with-interaction-persons</code> flags for <code>company get</code> and <code>person get</code> commands. Fetches interaction date summaries directly in entity get operations.</li> <li>MCP: Query tool <code>format</code> parameter now functional (was previously ignored). Supports <code>toon</code>, <code>markdown</code>, <code>json</code>, <code>jsonl</code>, <code>csv</code>.</li> <li>CLI: <code>--max-output-bytes</code> option for <code>query</code> command. Enables format-aware truncation for MCP use, returning exit code 100 when truncated.</li> <li>CLI: <code>format_toon_envelope()</code> function for TOON output with full envelope (<code>data[N]{...}:</code>, <code>pagination:</code>, <code>included_*:</code> sections).</li> <li>SDK: Batch association methods for PersonService, CompanyService, and OpportunityService:</li> <li><code>get_associated_company_ids_batch(person_ids)</code> / <code>get_associated_opportunity_ids_batch(person_ids)</code></li> <li><code>get_associated_person_ids_batch(company_ids)</code> / <code>get_associated_opportunity_ids_batch(company_ids)</code></li> <li><code>get_associated_person_ids_batch(opportunity_ids)</code> / <code>get_associated_company_ids_batch(opportunity_ids)</code></li> <li>All return <code>dict[EntityId, list[AssocId]]</code> with <code>on_error=\"raise\"|\"skip\"</code> parameter.</li> <li>SDK: <code>retries</code> parameter on <code>persons.get()</code>, <code>companies.get()</code>, and <code>opportunities.get()</code> methods. Enables automatic retry with exponential backoff on 404 errors to handle V1\u2192V2 eventual consistency after create operations. Default is <code>retries=0</code> (fail fast).</li> <li>CLI: Reminder date options now accept relative dates and keywords in addition to ISO-8601:</li> <li><code>--due-date</code>: <code>+7d</code>, <code>+2w</code>, <code>+1m</code>, <code>+1y</code>, <code>today</code>, <code>tomorrow</code>, <code>yesterday</code>, <code>now</code></li> <li><code>--due-after</code>, <code>--due-before</code>: Same formats for filtering in <code>reminder ls</code></li> <li>Example: <code>xaffinity reminder create --due-date +7d --type one-time --owner-id 123</code></li> <li>CLI: Domain validation for <code>company create</code> and <code>company update</code> now provides helpful error messages:</li> <li>Detects underscores (RFC 1035 violation) and suggests dash replacement</li> <li>Detects URL prefixes and extracts domain</li> <li>Example: <code>--domain test_company.com</code> \u2192 \"Use 'test-company.com' instead\"</li> <li>Docs: V1\u2192V2 eventual consistency guide covering 404 after create and stale data after update scenarios.</li> <li>Tests: Integration test suite for SDK write operations (<code>tests/integration/</code>).</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>SDK: <code>OpportunityService.get_associated_people()</code> and <code>get_associated_companies()</code> now use V2 batch lookup instead of individual V1 fetches, reducing N+1 API calls (e.g., 50 people now fetched in 2 calls instead of 51).</li> <li>SDK: Query executor <code>_batch_fetch_by_ids()</code> now uses V2 batch lookup for persons and companies, improving query performance on relationship includes.</li> <li>CLI: Query <code>include</code> clause now fetches relationship IDs in parallel, then batch-fetches full records via V2 API, reducing API calls from N\u00d7M to N+1 for deduped lookups.</li> </ul>"},{"location":"changelog/#changed-breaking_3","title":"Changed (Breaking)","text":"<ul> <li>MCP: Query tool default format changed from <code>json</code> to <code>toon</code> for better token efficiency (~40% fewer tokens).</li> <li>CLI: TOON query output now includes full envelope structure instead of data-only format. The <code>data</code> prefix is added to the array header: <code>data[N]{fields}:</code> instead of <code>[N]{fields}:</code>.</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>MCP: Query tool now honors the <code>format</code> parameter instead of always using JSON output.</li> <li>SDK: <code>ListEntryService.batch_update_fields()</code> now uses correct V2 API payload format. Previously failed with \"Missing discriminator for property operation\" error.</li> </ul>"},{"location":"changelog/#099-2026-01-14","title":"0.9.9 - 2026-01-14","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>CLI: <code>query</code> command now supports advanced relationship filtering:</li> <li><code>all</code> quantifier: Filter where all related items match a condition (e.g., find persons where all their companies have \".com\" domains)</li> <li><code>none</code> quantifier: Filter where no related items match a condition (e.g., find persons with no spam interactions)</li> <li><code>exists</code> subquery: Filter where at least one related item exists, optionally matching a condition (e.g., find persons who have email interactions)</li> <li><code>_count</code> pseudo-field: Filter by count of related items (e.g., <code>\"path\": \"companies._count\", \"op\": \"gte\", \"value\": 2</code>)</li> <li>Available relationship paths: persons\u2192companies/opportunities/interactions/notes/listEntries, companies\u2192persons/opportunities/interactions/notes/listEntries, opportunities\u2192persons/companies/interactions</li> <li>Note: These features cause N+1 API calls to fetch relationship data; use <code>--dry-run</code> to preview</li> </ul>"},{"location":"changelog/#changed-breaking_4","title":"Changed (Breaking)","text":"<ul> <li>CLI: Renamed relationship <code>\"people\"</code> to <code>\"persons\"</code> for consistency with entity type names:</li> <li>Query <code>include</code>: <code>{\"from\": \"companies\", \"include\": [\"people\"]}</code> \u2192 use <code>[\"persons\"]</code></li> <li>CLI <code>--expand</code>: <code>xaffinity company get &lt;id&gt; --expand people</code> \u2192 use <code>--expand persons</code></li> <li>JSON output: <code>data.people</code> \u2192 <code>data.persons</code></li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>CLI: Query engine no longer silently passes all records for <code>all</code>, <code>none</code>, and <code>_count</code> filters. Previously these were placeholder implementations that returned <code>True</code> for all records, causing incorrect query results. (Bug #15)</li> </ul>"},{"location":"changelog/#098-2026-01-12","title":"0.9.8 - 2026-01-12","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>CLI: <code>query</code> command now correctly fetches all records before applying filter, sort, or aggregate operations. Previously, limits were applied during fetch which caused incorrect results:</li> <li>With filters: Empty results when matching records were beyond the limit position</li> <li>With sort + limit: Random N records sorted instead of actual top N</li> <li>With aggregate: Inaccurate counts/sums computed on partial data</li> </ul>"},{"location":"changelog/#097-2026-01-12","title":"0.9.7 - 2026-01-12","text":""},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>CI: Smoke test now correctly installs CLI extras before testing CLI import</li> </ul>"},{"location":"changelog/#096-2026-01-12","title":"0.9.6 - 2026-01-12","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>CLI: <code>listEntries</code> queries now include convenience aliases: <code>listEntryId</code>, <code>entityId</code>, <code>entityName</code>, <code>entityType</code>. These intuitive field names work in both <code>select</code> and <code>where</code> clauses.</li> <li>CLI: <code>listEntries</code> records now always include a <code>fields</code> key (defaults to <code>{}</code> if no custom fields).</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>CLI: Query projection now includes null values for explicitly selected fields. Previously, <code>select: [\"entityName\", \"fields.Status\"]</code> would return <code>{}</code> if Status was null; now returns <code>{\"entityName\": \"Acme\", \"fields\": {\"Status\": null}}</code>.</li> </ul>"},{"location":"changelog/#095-2026-01-12","title":"0.9.5 - 2026-01-12","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>CLI: New <code>--output</code>/<code>-o</code> option supporting multiple formats: <code>json</code>, <code>jsonl</code>, <code>markdown</code>, <code>toon</code>, <code>csv</code>, <code>table</code> (default).</li> <li><code>markdown</code>: GitHub-flavored markdown tables, best for LLM analysis and comprehension</li> <li><code>toon</code>: Token-Optimized Object Notation, 30-60% fewer tokens than JSON for large datasets</li> <li><code>jsonl</code>: JSON Lines format, one object per line for streaming workflows</li> <li>Example: <code>xaffinity person ls --output markdown</code>, <code>xaffinity query -o toon</code></li> <li>Existing <code>--csv</code> and <code>--json</code> flags continue to work as before.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>CLI: <code>to_cell()</code> now extracts \"text\" from dropdown/multi-select fields instead of JSON-serializing the full dict. This makes CSV and other tabular outputs human-readable for dropdown values.</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>CLI: <code>query</code> command with <code>limit</code> now correctly returns results when combined with client-side filters (like <code>has_any</code> on multi-select fields). Previously, the limit was applied during fetch before filtering, causing empty results when the first N records didn't match the filter criteria.</li> </ul>"},{"location":"changelog/#094-2026-01-12","title":"0.9.4 - 2026-01-12","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>CLI: <code>query</code> command now supports <code>has_any</code> and <code>has_all</code> operators for multi-select field filtering.</li> <li>SDK/CLI: Filter parser now supports V2 API comparison operators: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> for numeric/date comparisons.</li> <li>SDK/CLI: Filter parser now supports word-based operator aliases for LLM/human clarity:</li> <li><code>contains</code>, <code>starts_with</code>, <code>ends_with</code> (string matching)</li> <li><code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code> (numeric/date comparisons)</li> <li><code>is null</code>, <code>is not null</code>, <code>is empty</code> (null/empty checks)</li> <li>SDK/CLI: Filter parser now supports collection bracket syntax <code>[A, B, C]</code> with operators:</li> <li><code>in [A, B]</code> - value is one of the listed values</li> <li><code>between [1, 10]</code> - value is in range (inclusive)</li> <li><code>has_any [A, B]</code> - array field contains any of the values</li> <li><code>has_all [A, B]</code> - array field contains all of the values</li> <li><code>contains_any [A, B]</code> - substring match for any term</li> <li><code>contains_all [A, B]</code> - substring match for all terms</li> <li><code>= [A, B]</code> - set equality (array has exactly these elements)</li> <li><code>=~ [A, B]</code> - V2 API collection contains (array contains all elements)</li> </ul>"},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>CLI: <code>query</code> command now correctly filters on multi-select dropdown fields (like \"Team Member\"). The <code>eq</code> operator checks array membership for scalar values and set equality for array values. Previously, these queries returned 0 results due to strict equality comparison.</li> <li>SDK/CLI: <code>list export --filter</code> now correctly matches multi-select dropdown fields. The <code>=</code>, <code>!=</code>, and <code>=~</code> operators now handle array values properly. Also fixes extraction of text values from multi-select dropdown API responses.</li> <li>SDK/CLI: Fixed <code>=^</code> (starts_with) and <code>=$</code> (ends_with) operators which were broken due to tokenizer ordering issue.</li> </ul>"},{"location":"changelog/#improved","title":"Improved","text":"<ul> <li>SDK/CLI: Filter parser now provides helpful hints for common mistakes:</li> <li>Multi-word field names: suggests quoting (<code>\"Team Member\"</code>)</li> <li>Multi-word values: suggests quoting (<code>\"Intro Meeting\"</code>)</li> <li>SQL keywords (<code>AND</code>, <code>OR</code>): suggests correct symbols (<code>&amp;</code>, <code>|</code>)</li> <li>Double equals (<code>==</code>): suggests single <code>=</code></li> </ul>"},{"location":"changelog/#093-2026-01-11","title":"0.9.3 - 2026-01-11","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>CI: SDK releases now include MCPB bundle and plugin ZIP for convenience.</li> <li>CI: Enabled PyPI attestations via workflow_dispatch API trigger.</li> </ul>"},{"location":"changelog/#092-2026-01-11","title":"0.9.2 - 2026-01-11","text":""},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>SDK: <code>AsyncListEntryService.pages()</code> now supports <code>progress_callback</code> parameter (sync/async parity fix).</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>BREAKING: CLI: <code>interaction ls</code> JSON output restructured for consistency:</li> <li><code>.data.interactions</code> \u2192 <code>.data</code> (direct array)</li> <li><code>.data.metadata.totalRows</code> \u2192 <code>.meta.summary.totalRows</code></li> <li><code>.data.metadata.dateRange</code> \u2192 <code>.meta.summary.dateRange</code></li> <li><code>.data.metadata.typeStats</code> \u2192 <code>.meta.summary.typeBreakdown</code></li> <li>BREAKING: CLI: <code>note ls</code> JSON output restructured for consistency:</li> <li><code>.data.notes</code> \u2192 <code>.data</code> (direct array)</li> <li>Pagination: <code>.data.notes.nextCursor</code> \u2192 <code>.meta.pagination.nextCursor</code></li> <li>BREAKING: CLI: <code>query</code> JSON output (with <code>--include-meta</code>) restructured for consistency:</li> <li><code>.meta.recordCount</code> \u2192 <code>.meta.summary.totalRows</code></li> <li>Included entity counts now in <code>.meta.summary.includedCounts</code></li> <li>CLI: Standardized <code>ResultSummary</code> footer rendering across all commands (displays row counts, date ranges, type breakdowns as compact footer text instead of tables).</li> </ul>"},{"location":"changelog/#091-2026-01-11","title":"0.9.1 - 2026-01-11","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>CLI: <code>query</code> command now validates entity queryability and provides clear error messages for unsupported entities.</li> <li>CLI: <code>query</code> command resolves field names to IDs automatically (e.g., <code>\"field\": \"Status\"</code> works alongside <code>\"fieldId\": 123</code>).</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>CLI: <code>query</code> for <code>listEntries</code> entity now correctly requires <code>listId</code> filter.</li> <li>CLI: <code>query</code> relationship definitions now correctly set <code>requires_n_plus_1</code> flag for proper query planning.</li> </ul>"},{"location":"changelog/#090-2026-01-11","title":"0.9.0 - 2026-01-11","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>CLI: New <code>query</code> command for structured JSON queries with complex filtering, includes, aggregations, and sorting. Use <code>--dry-run</code> to preview execution plans. Supports entities: persons, companies, opportunities, listEntries, interactions, notes.</li> <li>MCP: New <code>query</code> tool for complex data queries via JSON query language. Supports filtering (AND/OR/NOT), includes (related entities), aggregations (count/sum/avg/min/max), groupBy, and sorting.</li> <li>CLI: <code>--limit</code> alias for <code>--max-results</code> on <code>company get</code>, <code>person get</code>, and <code>opportunity get</code> commands (consistency with <code>ls</code> commands).</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>CLI: <code>--list</code>, <code>--list-entry-field</code>, and <code>--show-list-entry-fields</code> now auto-imply <code>--expand list-entries</code> on <code>company get</code> and <code>person get</code> commands (improved DX).</li> </ul>"},{"location":"changelog/#086-2026-01-10","title":"0.8.6 - 2026-01-10","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>SDK: <code>PersonService.get_associated_company_ids()</code> and <code>get_associated_opportunity_ids()</code> methods for symmetric association API.</li> <li>SDK: <code>CompanyService.get_associated_opportunity_ids()</code> method.</li> </ul>"},{"location":"changelog/#085-2026-01-10","title":"0.8.5 - 2026-01-10","text":""},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>CLI/SDK: <code>FilterParseError</code> now raised when filter expressions fail to parse (previously silently ignored). Common cause: unquoted multi-word values like <code>--filter 'Status=Intro Meeting'</code> must be quoted: <code>--filter 'Status=\"Intro Meeting\"'</code>.</li> <li>CLI: Pre-commit hook now validates installed CLI version matches <code>pyproject.toml</code> before regenerating MCP registry.</li> </ul>"},{"location":"changelog/#084-2026-01-10","title":"0.8.4 - 2026-01-10","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>CLI: NDJSON progress output for <code>interaction ls</code> multi-type queries (MCP integration).</li> </ul>"},{"location":"changelog/#083-2026-01-10","title":"0.8.3 - 2026-01-10","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>CLI: <code>--limit</code> alias for <code>--max-results</code> on all <code>ls</code> commands (LLM-friendly).</li> <li>CLI: Option aliases now included in <code>--help --json</code> output.</li> </ul>"},{"location":"changelog/#082-2026-01-10","title":"0.8.2 - 2026-01-10","text":"<p>No user-facing changes. Version bump for PyPI release.</p>"},{"location":"changelog/#081-2026-01-10","title":"0.8.1 - 2026-01-10","text":"<p>No user-facing changes. Version bump for PyPI release.</p>"},{"location":"changelog/#080-2026-01-10","title":"0.8.0 - 2026-01-10","text":""},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>CLI: Renamed <code>--json</code> to <code>--set-json</code> on <code>person field</code>, <code>company field</code>, <code>opportunity field</code> commands to avoid conflict with global <code>--json</code> output flag.</li> <li>BREAKING: CLI: <code>--csv FILE</code> is now <code>--csv</code> flag that outputs CSV to stdout. Use shell redirection: <code>--csv &gt; file.csv</code>. Applies to <code>person ls</code>, <code>company ls</code>, <code>opportunity ls</code>, <code>list export</code>.</li> <li>CLI: <code>--csv</code> and <code>--json</code> are now mutually exclusive (error if both specified).</li> <li>CLI: <code>person ls --query</code> and <code>company ls --query</code> now support <code>--field</code> and <code>--field-type</code> options via hybrid V1\u2192V2 fetch.</li> <li>BREAKING: CLI: <code>interaction ls</code> date filter parameters renamed for consistency:</li> <li><code>--start-time</code> \u2192 <code>--after</code></li> <li><code>--end-time</code> \u2192 <code>--before</code></li> <li>Context metadata keys changed: <code>startTime</code>/<code>endTime</code> \u2192 <code>after</code>/<code>before</code></li> <li>Note: Interaction object fields (<code>startTime</code>/<code>endTime</code>) are unchanged</li> <li>BREAKING: CLI: <code>interaction ls</code> now requires <code>--type</code> (was optional but API required it).</li> <li>CLI: <code>interaction ls</code> date range now defaults to all-time when <code>--days</code> and <code>--after</code> are omitted.</li> <li>BREAKING: CLI: <code>interaction ls</code> removed <code>--cursor</code> and <code>--all</code> flags (auto-chunking replaces manual pagination).</li> <li>BREAKING: CLI: <code>interaction ls</code> output field renamed <code>modifiers.type</code> \u2192 <code>modifiers.types</code> (now always an array).</li> <li>BREAKING: CLI: <code>interaction ls</code> metadata <code>chunksProcessed</code> moved to <code>typeStats[type].chunksProcessed</code>.</li> <li>BREAKING: CLI: Naive datetime strings (without timezone) are now interpreted as local time instead of UTC. Use explicit <code>Z</code> suffix or offset for UTC. See datetime-handling guide for details.</li> <li>BREAKING: CLI: List entry field commands unified into single <code>entry field</code> command:</li> <li><code>entry set-field --field F --value V</code> \u2192 <code>entry field --set F V</code></li> <li><code>entry set-field --field F --value-json '{...}'</code> \u2192 <code>entry field --set-json '{\"F\": ...}'</code></li> <li><code>entry set-fields --updates-json '{...}'</code> \u2192 <code>entry field --set-json '{...}'</code></li> <li><code>entry unset-field --field F</code> \u2192 <code>entry field --unset F</code></li> <li><code>entry unset-field --field F --value V</code> \u2192 <code>entry field --unset-value F V</code></li> <li><code>entry unset-field --field F --all-values</code> \u2192 <code>entry field --unset F</code></li> <li>Removed: <code>--field-id</code> option (field IDs can be passed as FIELD argument directly)</li> <li>Behavior change: <code>--set</code> on multi-value field now replaces all values (use <code>--append</code> to add)</li> </ul>"},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>CLI: <code>interaction ls --type</code> now accepts multiple types (e.g., <code>--type email --type meeting</code>).</li> <li>CLI: <code>interaction ls --type all</code> convenience option fetches all interaction types.</li> <li>CLI: <code>interaction ls</code> multi-type results sorted by date descending (types interleaved).</li> <li>CLI: <code>interaction ls</code> metadata includes <code>typeStats</code> with per-type counts and chunk info.</li> <li>CLI: <code>interaction ls</code> auto-chunking for date ranges &gt; 1 year (transparently splits into API-compatible chunks).</li> <li>CLI: <code>interaction ls --days N</code> convenience flag for \"last N days\" queries.</li> <li>CLI: <code>interaction ls --csv</code> and <code>--csv-bom</code> flags for CSV export.</li> <li>CLI: <code>interaction ls</code> metadata in JSON output includes <code>dateRange</code>, <code>typeStats</code>, <code>totalRows</code>.</li> <li>SDK: <code>ListEntryService.from_saved_view()</code> now accepts <code>field_ids</code> and <code>field_types</code> parameters.</li> <li>CLI: <code>list export --saved-view</code> can now be combined with <code>--field</code> for server-side filtering with explicit field selection.</li> <li>SDK: <code>ids</code> parameter added to <code>PersonService</code>, <code>CompanyService</code>, and <code>OpportunityService</code> for batch fetching by ID.</li> <li>CLI: <code>entry field --get FIELD</code> for reading field values (new functionality).</li> <li>CLI: <code>entry field --append FIELD VALUE</code> for adding to multi-value fields without replacing.</li> <li>CLI: <code>entry field --unset-value FIELD VALUE</code> for removing specific value from multi-value field.</li> </ul>"},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>SDK: <code>FieldValues</code> now properly parses field arrays from API responses (previously showed <code>requested=False</code>).</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>CLI: <code>person search</code> and <code>company search</code> commands. Use <code>person ls --query</code> and <code>company ls --query</code> instead.</li> <li>CLI: Removed <code>entry set-field</code>, <code>entry set-fields</code>, and <code>entry unset-field</code> commands (replaced by unified <code>entry field</code>).</li> </ul>"},{"location":"changelog/#070-2026-01-08","title":"0.7.0 - 2026-01-08","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>CLI: Column limiting for wide table output - tables now auto-limit columns based on terminal width.</li> <li>CLI: <code>--all-columns</code> flag to show all columns regardless of terminal width.</li> <li>CLI: <code>--max-columns N</code> flag for fine control over column limits.</li> <li>CLI: Real-time filter scanning progress during <code>list export --filter</code> shows \"Scanning X... (Y matches)\".</li> <li>CLI: Export summary line after filtered operations (e.g., \"Exported 35 rows (filtered from 9,340 scanned) in 2:15\").</li> <li>CLI: <code>format_duration()</code> helper for human-readable time formatting.</li> <li>CLI: Rich pager now uses <code>styles=True</code> to preserve ANSI colors when paging.</li> <li>SDK: <code>FilterStats</code> dataclass for tracking scanned/matched counts during filtered pagination.</li> <li>SDK: <code>PaginatedResponse.filter_stats</code> property exposes filter statistics.</li> </ul>"},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li>CLI: JSON progress output no longer appears alongside Rich progress bar (mutual exclusivity enforced).</li> <li>SDK: Dropdown field filtering now extracts \"text\" property from dropdown dicts.</li> </ul>"},{"location":"changelog/#0611-2026-01-07","title":"0.6.11 - 2026-01-07","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>CLI: Parameter help text (<code>help</code>) now included in <code>--help --json</code> output.</li> <li>CLI: Click.Choice values (<code>choices</code>) now included in <code>--help --json</code> output.</li> <li>CLI: Examples from docstrings now parsed and included in <code>--help --json</code> output.</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>CLI: Improved <code>--filter</code> help text with full operator list (<code>= != =~ =^ =$ &gt; &lt; &gt;= &lt;=</code>).</li> <li>CLI: Improved <code>--query</code> help text to clarify V1 fuzzy search vs V2 structured filtering.</li> </ul>"},{"location":"changelog/#0610-2026-01-06","title":"0.6.10 - 2026-01-06","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>CLI: JSON progress output to stderr when not connected to a TTY (for MCP integration).</li> <li>CLI: <code>@progress_capable</code> decorator to mark commands supporting progress reporting.</li> <li>CLI: Rate-limited progress updates (0.65s interval) with guaranteed 100% completion emission.</li> <li>CLI: <code>progressCapable</code> field in <code>--help --json</code> output for registry generation.</li> <li>MCP: <code>run_xaffinity_with_progress</code> helper for progress-aware CLI execution.</li> <li>MCP: <code>command_supports_progress</code> helper to check registry for progress capability.</li> <li>MCP: Execute tools now forward CLI progress for <code>@progress_capable</code> commands.</li> <li>CLI: File upload commands (<code>person/company/opportunity files upload</code>) marked as <code>@progress_capable</code>.</li> <li>MCP: <code>PROGRESS_MIN_VERSION</code> in COMPATIBILITY for graceful degradation with older CLIs.</li> <li>MCP: <code>version_gte</code> helper for portable version comparison (macOS/Linux).</li> <li>MCP: CLI version check in <code>command_supports_progress</code> (disables progress for CLI &lt; 0.6.10).</li> <li>MCP: <code>XAFFINITY_CLI_VERSION</code> exported for tool scripts to access CLI version.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>MCP: Updated mcp-bash.lock to patched v0.9.3 (commit ee245a7) with progress passthrough fixes.</li> </ul>"},{"location":"changelog/#069-2026-01-06","title":"0.6.9 - 2026-01-06","text":""},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>CLI Plugin: Skill now documents destructive command confirmation flow (look up, ask, wait, execute with <code>--yes</code>).</li> <li>CLI Plugin: Skill lists all destructive commands requiring double confirmation.</li> </ul>"},{"location":"changelog/#068-2026-01-05","title":"0.6.8 - 2026-01-05","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>CLI: <code>@category</code> and <code>@destructive</code> decorators for MCP registry generation.</li> <li>CLI: <code>--help --json</code> output for machine-readable command documentation.</li> <li>CLI: Commands now expose category (read/write/local) and destructive metadata.</li> </ul>"},{"location":"changelog/#067-2026-01-03","title":"0.6.7 - 2026-01-03","text":""},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Docs: Updated all documentation links to use versioned <code>/latest/</code> URLs for reliable navigation.</li> </ul>"},{"location":"changelog/#066-2026-01-03","title":"0.6.6 - 2026-01-03","text":""},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li>SDK: Regex patterns in <code>lists.py</code> and <code>http.py</code> were double-escaped, matching literal <code>\\d</code> instead of digits.</li> </ul>"},{"location":"changelog/#065-2026-01-02","title":"0.6.5 - 2026-01-02","text":"<p>No user-facing changes. Version bump for PyPI release.</p>"},{"location":"changelog/#064-2026-01-02","title":"0.6.4 - 2026-01-02","text":"<p>No user-facing changes. Version bump for PyPI release.</p>"},{"location":"changelog/#063-2026-01-02","title":"0.6.3 - 2026-01-02","text":"<p>No user-facing changes. Version bump for PyPI release.</p>"},{"location":"changelog/#062-2026-01-02","title":"0.6.2 - 2026-01-02","text":""},{"location":"changelog/#fixed_23","title":"Fixed","text":"<ul> <li>CLI: Added explicit <code>type=str</code> to Click arguments for Python 3.13 mypy compatibility.</li> </ul>"},{"location":"changelog/#061-2026-01-02","title":"0.6.1 - 2026-01-02","text":""},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Docs: Separated MCP Server documentation from Claude Code plugins.</li> </ul>"},{"location":"changelog/#060-2026-01-02","title":"0.6.0 - 2026-01-02","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>MCP: <code>read-xaffinity-resource</code> tool for clients with limited resource support.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Plugins: Restructured into 3-plugin marketplace architecture (affinity-sdk, xaffinity-cli, xaffinity-mcp).</li> <li>Docs: Restructured Claude integrations with consistent naming.</li> </ul>"},{"location":"changelog/#fixed_24","title":"Fixed","text":"<ul> <li>CLI: Improved <code>setup-key</code> command UX with Rich styling.</li> <li>MCP: Source both <code>.zprofile</code> and <code>.zshrc</code> in environment wrapper.</li> <li>MCP: Parse JSON response correctly for <code>check-key</code> output.</li> </ul>"},{"location":"changelog/#051-2026-01-01","title":"0.5.1 - 2026-01-01","text":""},{"location":"changelog/#fixed_25","title":"Fixed","text":"<ul> <li>Plugins: Consolidated plugin structure and fixed relative paths.</li> </ul>"},{"location":"changelog/#050-2026-01-01","title":"0.5.0 - 2026-01-01","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>MCP: Initial xaffinity MCP server as separate Claude Code plugin.</li> <li>CLI: Top-level <code>entry</code> command group as shorthand for <code>list entry</code> (e.g., <code>xaffinity entry get</code> instead of <code>xaffinity list entry get</code>).</li> <li>CLI: <code>--query</code> / <code>-q</code> flag for <code>person ls</code>, <code>company ls</code>, and <code>opportunity ls</code> to enable free-text search (V1 API).</li> <li>CLI: <code>--company-id</code> and <code>--opportunity-id</code> options for <code>interaction ls</code>.</li> <li>CLI: <code>-A</code> short flag for <code>--all</code> on all paginated list commands.</li> <li>CLI: <code>-n</code> short flag for <code>--max-results</code> on all commands with result limits.</li> <li>CLI: <code>-s</code> short flag for <code>--page-size</code> on all pagination commands.</li> <li>CLI: <code>-t</code> short flag for <code>--type</code> on interaction commands.</li> <li>CLI: Structured <code>CommandContext</code> for all commands.</li> <li>SDK: <code>OpportunityService.search()</code>, <code>search_pages()</code>, <code>search_all()</code> methods for V1 opportunity search.</li> <li>SDK: Async versions of opportunity search methods in <code>AsyncOpportunityService</code>.</li> <li>SDK: <code>InteractionService.list()</code> now accepts <code>company_id</code> and <code>opportunity_id</code> parameters.</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>CLI: <code>list view</code> renamed to <code>list get</code> for consistency with other entity commands.</li> <li>CLI: <code>--completed/--not-completed</code> boolean flag pattern for <code>reminder update</code> (replaces separate flags).</li> <li>CLI: Removed API version mentions from help text (implementation detail).</li> <li>CLI: <code>interaction ls</code> now requires an entity ID (<code>--person-id</code>, <code>--company-id</code>, or <code>--opportunity-id</code>) and defaults to last 7 days with visible warning (API max: 1 year).</li> <li>CLI: Unified <code>person field</code>, <code>company field</code>, <code>opportunity field</code> commands replace <code>set-field</code>, <code>set-fields</code>, and <code>unset-field</code> commands. New syntax: <code>--set FIELD VALUE</code>, <code>--unset FIELD</code>, <code>--set-json '{...}'</code>, <code>--get FIELD</code>.</li> <li>CLI: Note content separated from metadata in table display.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>CLI: <code>person set-field</code>, <code>person set-fields</code>, <code>person unset-field</code> commands (use <code>person field</code> instead).</li> <li>CLI: <code>company set-field</code>, <code>company set-fields</code>, <code>company unset-field</code> commands (use <code>company field</code> instead).</li> <li>CLI: <code>opportunity set-field</code>, <code>opportunity set-fields</code>, <code>opportunity unset-field</code> commands (use <code>opportunity field</code> instead).</li> </ul>"},{"location":"changelog/#fixed_26","title":"Fixed","text":"<ul> <li>CLI: Help text formatting - added missing spaces in command examples (~78 instances).</li> <li>CLI: Improved <code>--cursor</code> help text explaining incompatibility with <code>--page-size</code>.</li> <li>CLI: Clarified <code>--csv</code> help text to indicate it writes to file while stdout format is unchanged.</li> <li>CLI: CommandContext validation and test isolation issues.</li> </ul>"},{"location":"changelog/#048-2025-12-31","title":"0.4.8 - 2025-12-31","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>CLI: <code>xaffinity field history</code> for viewing field value change history.</li> <li>CLI: Session caching for pipeline optimization via <code>AFFINITY_SESSION_CACHE</code> environment variable.</li> <li>CLI: <code>session start/end/status</code> commands for managing session cache lifecycle.</li> <li>CLI: <code>--session-cache</code> and <code>--no-cache</code> global flags for cache control.</li> <li>CLI: Cache hit/miss visibility with <code>--trace</code> flag.</li> <li>CLI: <code>config check-key --json</code> now includes <code>pattern</code> field showing key source.</li> <li>SDK: Client-side filtering for list entries (V2 API does not support server-side filtering).</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>CLI: <code>--filter</code> on list entry commands now applies client-side with warning (V2 API limitation).</li> <li>CLI: Removed <code>--opportunity-id</code> from <code>list entry add</code> (opportunities are created atomically via <code>opportunity create --list-id</code>).</li> </ul>"},{"location":"changelog/#fixed_27","title":"Fixed","text":"<ul> <li>SDK: Client-side filter parsing handles whitespace-only and unparseable filters gracefully.</li> <li>CLI: <code>--filter</code> on list entries now returns proper field values (V2 API format).</li> </ul>"},{"location":"changelog/#040-2025-12-30","title":"0.4.0 - 2025-12-30","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>CLI: <code>config check-key</code> command to check if an API key is configured (checks environment, .env, and config.toml).</li> <li>CLI: <code>config setup-key</code> command for secure API key configuration with hidden input, validation, and automatic .gitignore management.</li> <li>CLI: <code>set-field</code>, <code>set-fields</code>, <code>unset-field</code> commands for person, company, opportunity, and list entry entities.</li> <li>CLI: <code>list entry get</code> command with field metadata display.</li> <li>CLI: Enhanced <code>--expand-filter</code> syntax with OR (<code>|</code>), AND (<code>&amp;</code>), NOT (<code>!</code>), NULL checks (<code>=*</code>, <code>!=*</code>), and contains (<code>=~</code>).</li> <li>SDK: <code>list_entries</code> field added to <code>Person</code> model.</li> <li>SDK: Unified filter parser with <code>parse()</code> function and <code>matches()</code> method for client-side filter evaluation.</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>CLI: Authentication error hints now reference <code>config check-key</code> and <code>config setup-key</code> commands.</li> <li>CLI: Authentication documentation updated with Quick Setup section.</li> </ul>"},{"location":"changelog/#fixed_28","title":"Fixed","text":"<ul> <li>CLI: Default <code>--page-size</code> reduced from 200 to 100 to match Affinity API limit.</li> <li>SDK: Async <code>merge()</code> parameter names corrected (<code>primaryCompanyId</code>/<code>duplicateCompanyId</code>).</li> <li>SDK: Cache invalidation added to async create/update/delete in <code>CompanyService</code>.</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>CLI: Deprecated <code>field-value</code> and <code>field-value-changes</code> command groups removed (use entity-specific field commands instead).</li> <li>CLI: Deprecated <code>update-field</code> and <code>batch-update</code> list entry commands removed (use <code>set-field</code>/<code>set-fields</code> instead).</li> </ul>"},{"location":"changelog/#030-2025-12-30","title":"0.3.0 - 2025-12-30","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li>CLI: <code>xaffinity list export --expand</code> for exporting list entries with entity field expansion (company/person/opportunity fields).</li> <li>CLI: <code>xaffinity field-value-changes ls</code> for viewing field value change history.</li> <li>CLI: <code>xaffinity company get</code> (id/URL/resolver selectors) with <code>--all-fields</code> and <code>--expand lists|list-entries|people</code>.</li> <li>CLI: <code>xaffinity person get</code> (id/URL/resolver selectors) with <code>--all-fields</code> and <code>--expand lists|list-entries</code>.</li> <li>CLI: <code>xaffinity person ls</code> and <code>xaffinity company ls</code> with search flags.</li> <li>CLI: <code>xaffinity opportunity</code> command group with <code>ls/get/create/update/delete</code>.</li> <li>CLI: <code>xaffinity note</code>, <code>xaffinity reminder</code>, and <code>xaffinity interaction</code> command groups.</li> <li>CLI: <code>xaffinity file upload</code> command for file uploads.</li> <li>CLI: Write/merge/field operations for list entries.</li> <li>CLI: <code>--max-results</code> and <code>--all</code> controls for pagination and expansions.</li> <li>CLI: Progress reporting for all paginated commands.</li> <li>CLI: Rate limit visibility via SDK event hook.</li> <li>CLI: <code>--trace</code> flag for debugging SDK requests.</li> <li>SDK: <code>client.files.download_stream_with_info(...)</code> exposes headers/filename/size alongside streamed bytes.</li> <li>SDK: v1-only company association helpers <code>get_associated_person_ids(...)</code> and <code>get_associated_people(...)</code>.</li> <li>SDK: List-scoped opportunity resolution helpers <code>resolve(...)</code> and <code>resolve_all(...)</code>.</li> <li>SDK: Async parity for company and person services.</li> <li>SDK: Async parity for V1-only services.</li> <li>SDK: Async list and list entry write helpers.</li> <li>SDK: Pagination support for person resolution in <code>PersonService</code> and <code>AsyncPersonService</code>.</li> <li>SDK: <code>client.clear_cache()</code> method for cache invalidation.</li> <li>SDK: Field value changes service with <code>client.field_value_changes</code>.</li> <li>SDK: Detailed exception handling for <code>ConflictError</code>, <code>UnsafeUrlError</code>, and <code>UnsupportedOperationError</code>.</li> <li>SDK: Webhook <code>sent_at</code> timestamp validation.</li> <li>SDK: Request pipeline with policies (read-only mode, transport injection).</li> <li>SDK: <code>on_error</code> hook for error observability.</li> <li>Inbound webhook parsing helpers: <code>parse_webhook(...)</code>, <code>dispatch_webhook(...)</code>, and <code>BodyRegistry</code>.</li> <li>Claude Code plugin for SDK/CLI documentation and guidance.</li> </ul>"},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>CLI: Enum fields now display human-readable names instead of integers (type, status, direction, actionType).</li> <li>CLI: Datetimes render in local time with timezone info in column headers.</li> <li>CLI: Human/table output renders dict-shaped results as sections/tables (no JSON-looking panels).</li> <li>CLI: <code>--json</code> output now uses section-keyed <code>data</code> and <code>meta.pagination</code>.</li> <li>CLI: List-entry fields tables default to list-only fields; use <code>--list-entry-fields-scope all</code> for full payloads.</li> <li>CLI: Domain columns are now linkified in table output.</li> <li>CLI: Output only pages when content would scroll.</li> <li><code>FieldValueType</code> is now V2-first and string-based (e.g. <code>dropdown-multi</code>, <code>ranked-dropdown</code>, <code>interaction</code>).</li> <li><code>ListEntry.entity</code> is now discriminated by <code>entity_type</code>.</li> <li>Rate limit API unified across sync and async clients.</li> </ul>"},{"location":"changelog/#fixed_29","title":"Fixed","text":"<ul> <li>SDK: <code>ListService.get()</code> now uses V1 API to return correct <code>list_size</code>.</li> <li>CLI: JSON serialization now handles datetime objects correctly.</li> <li>Sync entity file download <code>deadline_seconds</code> handling.</li> <li>File downloads now use public services for company expansion pagination.</li> </ul>"},{"location":"changelog/#020-2025-12-17","title":"0.2.0 - 2025-12-17","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li>Initial public release.</li> <li><code>client.files.download_stream(...)</code> and <code>client.files.download_to(...)</code> for chunked file downloads.</li> <li><code>client.files.upload_path(...)</code> and <code>client.files.upload_bytes(...)</code> for ergonomic uploads.</li> <li><code>client.files.all(...)</code> / <code>client.files.iter(...)</code> for auto-pagination over files.</li> </ul>"},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>File downloads now follow redirects without forwarding credentials and use the standard retry/diagnostics policy.</li> <li><code>client.files.list(...)</code> and <code>client.files.upload(...)</code> now require exactly one of <code>person_id</code>, <code>organization_id</code>, or <code>opportunity_id</code> (per API contract).</li> </ul>"},{"location":"cli-reference/","title":"CLI Output Reference","text":"<p>This document describes the output formats available from Affinity CLI commands.</p>"},{"location":"cli-reference/#output-formats","title":"Output Formats","text":"<p>The CLI supports multiple output formats via the <code>--output</code> / <code>-o</code> flag:</p> Format Flag Availability Description <code>table</code> default Global Rich terminal tables (default for interactive use) <code>json</code> <code>--json</code> or <code>-o json</code> Global Full JSON with envelope (<code>ok</code>, <code>data</code>, <code>meta</code>, <code>error</code>) <code>jsonl</code> <code>-o jsonl</code> Per-command JSON Lines (one object per line, data only) <code>markdown</code> <code>-o markdown</code> Per-command GitHub-flavored markdown tables (data only) <code>toon</code> <code>-o toon</code> Per-command Token-Optimized Object Notation (30-60% fewer tokens) <code>csv</code> <code>--csv</code> or <code>-o csv</code> Per-command Comma-separated values (data only) <p>Note: <code>table</code> and <code>json</code> are available on all commands. Other formats (<code>jsonl</code>, <code>markdown</code>, <code>toon</code>, <code>csv</code>) are available on specific commands that support them (primarily list/export commands).</p> <p>For LLM/MCP use: Use <code>markdown</code> for best comprehension or <code>toon</code> for large datasets.</p> <p>For scripts: Use <code>--json</code> for full structured output with error handling.</p> <p>Example: <pre><code>xaffinity person ls --query \"Alice\" --output markdown\nxaffinity query --query '{\"from\": \"companies\", \"limit\": 10}' -o toon\n</code></pre></p>"},{"location":"cli-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Standard Response Format</li> <li>Resolved Metadata</li> <li>Pagination Metadata</li> <li>Rate Limit Metadata</li> <li>Error Responses</li> <li>Query Command Output</li> </ul>"},{"location":"cli-reference/#standard-response-format","title":"Standard Response Format","text":"<p>All CLI commands support the <code>--json</code> flag for machine-readable output. The response follows a consistent structure:</p> <pre><code>{\n  \"ok\": true,\n  \"command\": {\"name\": \"person get\", \"inputs\": {\"personSelector\": \"12345\"}, \"modifiers\": {}, \"resolved\": null},\n  \"data\": {\n    \"person\": {\n      \"id\": 12345,\n      \"firstName\": \"John\",\n      \"lastName\": \"Doe\",\n      \"emailAddresses\": [\"john@example.com\"]\n    }\n  },\n  \"meta\": {\n    \"durationMs\": 234,\n    \"resolved\": {},\n    \"pagination\": null,\n    \"rateLimit\": {\n      \"limit\": 300,\n      \"remaining\": 299,\n      \"reset\": 1609459200\n    }\n  }\n}\n</code></pre>"},{"location":"cli-reference/#top-level-fields","title":"Top-Level Fields","text":"<ul> <li>ok (boolean): <code>true</code> if the command succeeded, <code>false</code> if it failed</li> <li>command (object): Command metadata with <code>name</code> (string), <code>inputs</code> (object), <code>modifiers</code> (object), and <code>resolved</code> (object|null)</li> <li>data (object): The command's result data (structure varies by command)</li> <li>meta (object): Metadata about the command execution</li> </ul>"},{"location":"cli-reference/#meta-object","title":"Meta Object","text":"<p>The <code>meta</code> object contains:</p> <ul> <li>durationMs (number): How long the command took to execute (in milliseconds)</li> <li>resolved (object): Information about how CLI inputs were resolved to API parameters</li> <li>pagination (object | null): Pagination metadata for list commands</li> <li>rateLimit (object): API rate limit information</li> </ul>"},{"location":"cli-reference/#resolved-metadata","title":"Resolved Metadata","text":"<p>The <code>meta.resolved</code> field contains information about how CLI inputs were resolved to API parameters. The structure varies by command type based on what inputs need resolution.</p>"},{"location":"cli-reference/#entity-commands","title":"Entity Commands","text":"<p>For person, company, and opportunity commands, the resolved metadata includes information about how entity selectors were resolved:</p> <pre><code>{\n  \"resolved\": {\n    \"person\": {\n      \"input\": \"john@example.com\",\n      \"personId\": 12345,\n      \"source\": \"email\",\n      \"canonicalUrl\": \"https://app.affinity.co/persons/12345\"\n    },\n    \"fieldSelection\": {\n      \"fieldIds\": [\"field-123\", \"field-456\"],\n      \"fieldTypes\": [\"global\"]\n    },\n    \"expand\": [\"lists\", \"interactions\"]\n  }\n}\n</code></pre>"},{"location":"cli-reference/#entity-selector-resolution","title":"Entity Selector Resolution","text":"<p>The entity object (e.g., <code>person</code>, <code>company</code>, <code>opportunity</code>) contains:</p> <ul> <li>input (string): The original selector you provided</li> <li>{entityType}Id (number): The resolved entity ID</li> <li>source (string): How the selector was resolved</li> <li><code>\"id\"</code>: Direct numeric ID</li> <li><code>\"url\"</code>: Affinity URL</li> <li><code>\"email\"</code>: Email address (persons only)</li> <li><code>\"name\"</code>: Name search (persons only)</li> <li><code>\"domain\"</code>: Domain search (companies only)</li> <li>canonicalUrl (string, optional): The canonical Affinity URL for the entity</li> </ul>"},{"location":"cli-reference/#field-selection","title":"Field Selection","text":"<p>When field selection options are used (e.g., <code>--field</code>), the <code>fieldSelection</code> object contains:</p> <ul> <li>fieldIds (array of strings): Specific field IDs requested</li> <li>fieldTypes (array of strings): Field types requested (e.g., <code>\"global\"</code>, <code>\"list-specific\"</code>)</li> </ul>"},{"location":"cli-reference/#expansion","title":"Expansion","text":"<p>When <code>--expand</code> is used, the <code>expand</code> array contains the expansions requested (e.g., <code>[\"lists\", \"interactions\"]</code>).</p>"},{"location":"cli-reference/#list-commands","title":"List Commands","text":"<p>For list-related commands, the resolved metadata includes list and saved view resolution:</p> <pre><code>{\n  \"resolved\": {\n    \"list\": {\n      \"input\": \"Sales Pipeline\",\n      \"listId\": 789,\n      \"source\": \"name\"\n    },\n    \"savedView\": {\n      \"input\": \"My Active Deals\",\n      \"savedViewId\": 456,\n      \"name\": \"My Active Deals\"\n    }\n  }\n}\n</code></pre>"},{"location":"cli-reference/#list-resolution","title":"List Resolution","text":"<p>The <code>list</code> object contains:</p> <ul> <li>input (string): The original list selector</li> <li>listId (number): The resolved list ID</li> <li>source (string): How the list was resolved (<code>\"id\"</code>, <code>\"url\"</code>, or <code>\"name\"</code>)</li> </ul>"},{"location":"cli-reference/#saved-view-resolution","title":"Saved View Resolution","text":"<p>When a saved view is specified, the <code>savedView</code> object contains:</p> <ul> <li>input (string): The original saved view selector</li> <li>savedViewId (number): The resolved saved view ID</li> <li>name (string): The name of the saved view</li> </ul>"},{"location":"cli-reference/#opportunity-commands","title":"Opportunity Commands","text":"<p>Opportunity commands may include additional resolution metadata:</p> <pre><code>{\n  \"resolved\": {\n    \"opportunity\": {\n      \"input\": \"OPP-123\",\n      \"opportunityId\": 12345,\n      \"source\": \"id\"\n    },\n    \"list\": {\n      \"input\": \"789\",\n      \"listId\": 789,\n      \"source\": \"id\"\n    }\n  }\n}\n</code></pre>"},{"location":"cli-reference/#pagination-metadata","title":"Pagination Metadata","text":"<p>For commands that return collections, pagination metadata is namespaced by collection type:</p> <pre><code>{\n  \"data\": {\n    \"persons\": [\n      {\"id\": 1, \"firstName\": \"Alice\"},\n      {\"id\": 2, \"firstName\": \"Bob\"}\n    ]\n  },\n  \"meta\": {\n    \"pagination\": {\n      \"persons\": {\n        \"nextCursor\": \"eyJpZCI6MTIzfQ==\",\n        \"prevCursor\": null\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"cli-reference/#pagination-object-structure","title":"Pagination Object Structure","text":"<p>The pagination key always matches the data key (<code>persons</code>, <code>companies</code>, <code>opportunities</code>, <code>rows</code>, etc.). Each pagination object contains:</p> <ul> <li>nextCursor (string | null): Cursor for the next page, or <code>null</code> if this is the last page</li> <li>prevCursor (string | null): Cursor for the previous page, or <code>null</code> if this is the first page</li> </ul>"},{"location":"cli-reference/#using-pagination-cursors","title":"Using Pagination Cursors","text":"<p>To fetch the next page, use the <code>--cursor</code> option:</p> <pre><code>xaffinity person ls --query \"Alice\" --json\n# Get nextCursor from response\nxaffinity person ls --query \"Alice\" --cursor \"eyJpZCI6MTIzfQ==\" --json\n</code></pre>"},{"location":"cli-reference/#rate-limit-metadata","title":"Rate Limit Metadata","text":"<p>All API responses include rate limit information:</p> <pre><code>{\n  \"meta\": {\n    \"rateLimit\": {\n      \"limit\": 300,\n      \"remaining\": 299,\n      \"reset\": 1609459200\n    }\n  }\n}\n</code></pre>"},{"location":"cli-reference/#rate-limit-fields","title":"Rate Limit Fields","text":"<ul> <li>limit (number): Total number of requests allowed per time window</li> <li>remaining (number): Number of requests remaining in the current window</li> <li>reset (number): Unix timestamp when the rate limit window resets</li> </ul>"},{"location":"cli-reference/#error-responses","title":"Error Responses","text":"<p>When a command fails, the response structure changes:</p> <pre><code>{\n  \"ok\": false,\n  \"command\": {\"name\": \"person get\", \"inputs\": {\"personSelector\": \"99999\"}, \"modifiers\": {}, \"resolved\": null},\n  \"error\": {\n    \"type\": \"api_error\",\n    \"message\": \"Person not found\",\n    \"statusCode\": 404,\n    \"details\": {\n      \"personId\": 99999\n    }\n  },\n  \"meta\": {\n    \"durationMs\": 123\n  }\n}\n</code></pre>"},{"location":"cli-reference/#error-object","title":"Error Object","text":"<p>The <code>error</code> object contains:</p> <ul> <li>type (string): Error category</li> <li><code>\"api_error\"</code>: API returned an error</li> <li><code>\"usage_error\"</code>: Invalid command usage</li> <li><code>\"validation_error\"</code>: Input validation failed</li> <li><code>\"network_error\"</code>: Network/connection issue</li> <li>message (string): Human-readable error description</li> <li>statusCode (number, optional): HTTP status code for API errors</li> <li>details (object, optional): Additional error context</li> </ul>"},{"location":"cli-reference/#examples","title":"Examples","text":""},{"location":"cli-reference/#person-get-by-email","title":"Person Get by Email","text":"<p>Command: <pre><code>xaffinity person get email:john@example.com --json\n</code></pre></p> <p>Response: <pre><code>{\n  \"ok\": true,\n  \"command\": \"person get\",\n  \"data\": {\n    \"person\": {\n      \"id\": 12345,\n      \"firstName\": \"John\",\n      \"lastName\": \"Doe\",\n      \"emailAddresses\": [\"john@example.com\"]\n    }\n  },\n  \"meta\": {\n    \"durationMs\": 156,\n    \"resolved\": {\n      \"person\": {\n        \"input\": \"email:john@example.com\",\n        \"personId\": 12345,\n        \"source\": \"email\",\n        \"canonicalUrl\": \"https://app.affinity.co/persons/12345\"\n      }\n    },\n    \"pagination\": null,\n    \"rateLimit\": {\n      \"limit\": 300,\n      \"remaining\": 298,\n      \"reset\": 1609459200\n    }\n  }\n}\n</code></pre></p>"},{"location":"cli-reference/#person-list-with-query-and-pagination","title":"Person List with Query and Pagination","text":"<p>Command: <pre><code>xaffinity person ls --query \"Alice\" --json\n</code></pre></p> <p>Response: <pre><code>{\n  \"ok\": true,\n  \"command\": \"person ls\",\n  \"data\": {\n    \"persons\": [\n      {\n        \"id\": 1,\n        \"firstName\": \"Alice\",\n        \"lastName\": \"Smith\",\n        \"emailAddresses\": [\"alice@example.com\"]\n      },\n      {\n        \"id\": 2,\n        \"firstName\": \"Alice\",\n        \"lastName\": \"Jones\",\n        \"emailAddresses\": [\"ajones@example.com\"]\n      }\n    ]\n  },\n  \"meta\": {\n    \"durationMs\": 234,\n    \"resolved\": {},\n    \"pagination\": {\n      \"persons\": {\n        \"nextCursor\": \"eyJpZCI6Mn0=\",\n        \"prevCursor\": null\n      }\n    },\n    \"rateLimit\": {\n      \"limit\": 300,\n      \"remaining\": 297,\n      \"reset\": 1609459200\n    }\n  }\n}\n</code></pre></p>"},{"location":"cli-reference/#list-export-with-saved-view","title":"List Export with Saved View","text":"<p>Command: <pre><code>xaffinity list export \"Sales Pipeline\" --saved-view \"Active Deals\" --json\n</code></pre></p> <p>Response: <pre><code>{\n  \"ok\": true,\n  \"command\": {\"name\": \"list export\", \"inputs\": {\"listSelector\": \"Sales Pipeline\"}, \"modifiers\": {\"savedView\": \"Active Deals\"}, \"resolved\": null},\n  \"data\": {\n    \"entries\": [\n      {\n        \"id\": 101,\n        \"listId\": 789,\n        \"entityId\": 12345\n      }\n    ]\n  },\n  \"meta\": {\n    \"durationMs\": 189,\n    \"resolved\": {\n      \"list\": {\n        \"input\": \"Sales Pipeline\",\n        \"listId\": 789,\n        \"source\": \"name\"\n      },\n      \"savedView\": {\n        \"input\": \"Active Deals\",\n        \"savedViewId\": 456,\n        \"name\": \"Active Deals\"\n      }\n    },\n    \"pagination\": {\n      \"entries\": {\n        \"nextCursor\": null,\n        \"prevCursor\": null\n      }\n    },\n    \"rateLimit\": {\n      \"limit\": 300,\n      \"remaining\": 296,\n      \"reset\": 1609459200\n    }\n  }\n}\n</code></pre></p>"},{"location":"cli-reference/#field-naming-conventions","title":"Field Naming Conventions","text":"<p>All field names in JSON output use camelCase to match the Affinity API conventions:</p> <ul> <li><code>firstName</code> (not <code>first_name</code>)</li> <li><code>emailAddresses</code> (not <code>email_addresses</code>)</li> <li><code>nextCursor</code> (not <code>next_cursor</code>)</li> </ul> <p>This applies to both the <code>data</code> section and all metadata fields.</p>"},{"location":"cli-reference/#json-output-vs-table-output","title":"JSON Output vs Table Output","text":"<p>Important differences between <code>--json</code> and table output:</p> <ol> <li>Completeness: JSON output includes all fields from the API response, while table output may filter or format fields for readability</li> <li>Filter Flags: Flags like <code>--list-entry-field</code> and <code>--field</code> that control table formatting are ignored in JSON mode</li> <li>Consistency: JSON structure is stable and suitable for programmatic parsing</li> <li>Metadata: JSON includes full metadata (resolved, pagination, rate limits) that isn't shown in tables</li> </ol> <p>When writing scripts or integrations, always use <code>--json</code> for reliable, complete output.</p>"},{"location":"cli-reference/#typescript-type-definitions","title":"TypeScript Type Definitions","text":"<p>For TypeScript users, here are type definitions for the CLI output structure:</p> <pre><code>// Standard response wrapper\ninterface CLIResponse&lt;T = unknown&gt; {\n  ok: boolean;\n  command: string;\n  data?: T;\n  error?: CLIError;\n  meta: CLIMeta;\n}\n\n// Error object (when ok = false)\ninterface CLIError {\n  type: 'api_error' | 'usage_error' | 'validation_error' | 'network_error';\n  message: string;\n  statusCode?: number;\n  details?: Record&lt;string, unknown&gt;;\n}\n\n// Metadata object\ninterface CLIMeta {\n  durationMs: number;\n  resolved: ResolvedMetadata;\n  pagination: PaginationMetadata | null;\n  rateLimit: RateLimitInfo;\n}\n\n// Resolved metadata (structure varies by command)\ninterface ResolvedMetadata {\n  person?: EntityResolution;\n  company?: EntityResolution;\n  opportunity?: EntityResolution;\n  list?: ListResolution;\n  savedView?: SavedViewResolution;\n  fieldSelection?: FieldSelection;\n  expand?: string[];\n}\n\ninterface EntityResolution {\n  input: string;\n  personId?: number;\n  companyId?: number;\n  opportunityId?: number;\n  source: 'id' | 'url' | 'email' | 'name' | 'domain';\n  canonicalUrl?: string;\n}\n\ninterface ListResolution {\n  input: string;\n  listId: number;\n  source: 'id' | 'url' | 'name';\n}\n\ninterface SavedViewResolution {\n  input: string;\n  savedViewId: number;\n  name: string;\n}\n\ninterface FieldSelection {\n  fieldIds?: string[];\n  fieldTypes?: string[];\n}\n\n// Pagination (key matches data collection name)\ntype PaginationMetadata = {\n  [collectionName: string]: {\n    nextCursor: string | null;\n    prevCursor: string | null;\n  };\n};\n\n// Rate limit info\ninterface RateLimitInfo {\n  limit: number;\n  remaining: number;\n  reset: number;\n}\n\n// Example usage:\ninterface PersonGetResponse extends CLIResponse&lt;{ person: Person }&gt; {\n  data: {\n    person: Person;\n  };\n}\n\ninterface PersonListResponse extends CLIResponse&lt;{ persons: Person[] }&gt; {\n  data: {\n    persons: Person[];\n  };\n}\n</code></pre>"},{"location":"cli-reference/#query-command-output","title":"Query Command Output","text":"<p>The <code>xaffinity query</code> command uses a different output format optimized for complex queries with includes and aggregations:</p> <pre><code>{\n  \"data\": [\n    {\"id\": 1, \"firstName\": \"Alice\", \"lastName\": \"Smith\"},\n    {\"id\": 2, \"firstName\": \"Bob\", \"lastName\": \"Jones\"}\n  ],\n  \"included\": {\n    \"companies\": [\n      {\"id\": 100, \"name\": \"Acme Corp\"},\n      {\"id\": 101, \"name\": \"TechCo\"}\n    ]\n  },\n  \"meta\": {\n    \"executionTime\": 2.34,\n    \"recordsFetched\": 2,\n    \"apiCalls\": 3\n  },\n  \"pagination\": {\n    \"nextCursor\": \"eyJpZCI6Mn0=\"\n  }\n}\n</code></pre>"},{"location":"cli-reference/#query-output-fields","title":"Query Output Fields","text":"<ul> <li>data (array): Query results as an array of records</li> <li>included (object, optional): Related entities fetched via <code>include</code>, keyed by entity type</li> <li>meta (object, optional): Execution metadata (requires <code>--include-meta</code>)</li> <li>pagination (object, optional): Pagination cursors for continuing the query</li> </ul> <p>Note: Query output does not include <code>ok</code>, <code>command</code>, or <code>resolved</code> fields. Use <code>--include-meta</code> to include execution metadata.</p>"},{"location":"cli-reference/#related-documentation","title":"Related Documentation","text":"<ul> <li>CLI Commands Reference - Complete command documentation</li> <li>CLI Scripting Guide - Working with JSON output and pagination</li> <li>CSV Export Guide - Exporting data to CSV files</li> <li>Query Language Reference - Complete query syntax</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>All examples assume <code>AFFINITY_API_KEY</code> is set:</p> <pre><code>export AFFINITY_API_KEY=\"your-api-key\"\n</code></pre> <p>Run an example with:</p> <pre><code>python examples/basic_usage.py\n</code></pre>"},{"location":"examples/#basic","title":"Basic","text":"<ul> <li><code>examples/basic_usage.py</code> \u2014 small end-to-end tour of core services</li> <li><code>examples/advanced_usage.py</code> \u2014 deeper patterns and best practices</li> </ul>"},{"location":"examples/#async","title":"Async","text":"<ul> <li><code>examples/async_lifecycle.py</code> \u2014 async client lifecycle and usage</li> </ul>"},{"location":"examples/#filtering-and-hooks","title":"Filtering and hooks","text":"<ul> <li><code>examples/filter_builder.py</code> \u2014 build V2 filter expressions with <code>affinity.F</code></li> <li><code>examples/hooks_debugging.py</code> \u2014 request/response hooks for debugging</li> </ul>"},{"location":"examples/#lists-resolve-helpers-tasks","title":"Lists, resolve helpers, tasks","text":"<ul> <li><code>examples/list_management.py</code> \u2014 list CRUD and entry operations</li> <li><code>examples/resolve_helpers.py</code> \u2014 resolve helpers (IDs from external identifiers)</li> <li><code>examples/task_polling.py</code> \u2014 polling long-running tasks</li> </ul>"},{"location":"examples/#field-value-changes-audit-history","title":"Field Value Changes (audit history)","text":"<p>Query the change history for a specific field on an entity:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import CompanyId, FieldId, FieldValueChangeAction\n\nwith Affinity.from_env() as client:\n    # Get all changes to field \"field-123\" for company 456\n    changes = client.field_value_changes.list(\n        FieldId(\"field-123\"),\n        company_id=CompanyId(456),\n    )\n\n    for change in changes:\n        print(f\"{change.changed_at}: {change.value} (action={change.action_type})\")\n\n    # Filter by action type (e.g., only updates)\n    updates = client.field_value_changes.list(\n        FieldId(\"field-123\"),\n        company_id=CompanyId(456),\n        action_type=FieldValueChangeAction.UPDATE,\n    )\n</code></pre> <p>Note: This endpoint is not paginated. For large histories, use narrow filters.</p>"},{"location":"examples/#v1-only-exception-company-people-associations","title":"V1-only exception: company -&gt; people associations","text":"<p>V2 does not expose a company -&gt; people association endpoint yet. These helpers use the v1 organizations API and are documented as exceptions:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import CompanyId\n\nwith Affinity.from_env() as client:\n    person_ids = client.companies.get_associated_person_ids(CompanyId(224925494))\n    people = client.companies.get_associated_people(CompanyId(224925494), max_results=5)\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":"<p>Requires Python 3.10+.</p>"},{"location":"getting-started/#provide-your-api-key","title":"Provide your API key","text":"<p>Set <code>AFFINITY_API_KEY</code>:</p> <pre><code>export AFFINITY_API_KEY=\"your-api-key\"\n</code></pre> <p>Then create a client from the environment:</p> <pre><code>from affinity import Affinity\n\nclient = Affinity.from_env()\n</code></pre> <p>To load a local <code>.env</code> file, install the optional extra and set <code>load_dotenv=True</code>:</p> <pre><code>pip install \"affinity-sdk[dotenv]\"\n</code></pre> <pre><code>from affinity import Affinity\n\nclient = Affinity.from_env(load_dotenv=True)\n</code></pre>"},{"location":"getting-started/#disable-writes-policy","title":"Disable writes (policy)","text":"<p>If you want the SDK to guarantee it does not perform write operations (POST/PUT/PATCH/DELETE), disable writes via policy:</p> <pre><code>from affinity import Affinity\nfrom affinity.policies import Policies, WritePolicy\n\nclient = Affinity.from_env(policies=Policies(write=WritePolicy.DENY))\n</code></pre>"},{"location":"getting-started/#create-a-client","title":"Create a client","text":"<pre><code>from affinity import Affinity\n\nclient = Affinity(api_key=\"your-api-key\")\n</code></pre> <p>Prefer the context manager to ensure resources are closed:</p> <pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    ...\n</code></pre>"},{"location":"getting-started/#make-your-first-request","title":"Make your first request","text":"<p>This snippet covers authentication, a first request, and common failures:</p> <pre><code>from affinity import Affinity\nfrom affinity.exceptions import AuthenticationError, RateLimitError\n\ntry:\n    with Affinity.from_env() as client:\n        me = client.whoami()\n        print(f\"Authenticated as: {me.user.email}\")\nexcept AuthenticationError:\n    print(\"Check AFFINITY_API_KEY is set correctly\")\nexcept RateLimitError as e:\n    print(f\"Rate limited. Retry after: {e.retry_after}\")\n</code></pre>"},{"location":"getting-started/#resolve-a-list-by-name","title":"Resolve a list by name","text":"<p>If you have a list name from configuration (and not a <code>ListId</code>), you can resolve it:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import ListType\n\nwith Affinity.from_env() as client:\n    pipeline = client.lists.resolve(name=\"Deal Pipeline\", list_type=ListType.OPPORTUNITY)\n    if pipeline is None:\n        raise ValueError(\"List not found\")\n    for entry in client.lists.entries(pipeline.id).all():\n        ...\n</code></pre> <p>SDK-specific gotchas</p> <ul> <li>Use typed IDs (e.g., <code>CompanyId(123)</code>) instead of raw integers.</li> <li>Entity <code>fields</code> are only present when requested via <code>field_ids</code> or <code>field_types</code> parameters. The <code>entity.fields.requested</code> boolean indicates whether field data was actually fetched (<code>True</code>) or omitted (<code>False</code>). When <code>True</code>, <code>entity.fields.data</code> contains the field values (which may be empty if the entity has no field values).</li> <li>Some write operations still route to V1; see the V1 vs V2 routing guide.</li> </ul>"},{"location":"getting-started/#sync-vs-async","title":"Sync vs async","text":"<ul> <li>Use <code>Affinity</code> for synchronous code.</li> <li>Use <code>AsyncAffinity</code> for async/await code.</li> </ul> <p>See Sync vs async.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Authentication</li> <li>Examples</li> <li>Pagination</li> <li>Filtering</li> <li>CSV Export (CLI)</li> <li>Errors &amp; retries</li> <li>Configuration</li> <li>Field types &amp; values</li> <li>API versions &amp; routing</li> <li>AI Integrations - MCP Server &amp; Claude Code plugins</li> <li>API reference</li> </ul>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#entity-types","title":"Entity Types","text":"<ul> <li>Person: A contact in Affinity (individual). Has properties like name, email addresses, phone numbers.</li> <li>Company: An organization in Affinity. Has properties like name, domain(s), and associated persons.</li> <li>Opportunity: A deal or pipeline item. Always belongs to a specific list.</li> <li>List: A collection that can contain persons, companies, or opportunities. Lists have custom fields and workflow configurations.</li> <li>List Entry: A record in a list linking an entity (person, company, or opportunity) to that list with field values.</li> </ul>"},{"location":"glossary/#api-generations-v1-vs-v2","title":"API Generations (V1 vs V2)","text":"<ul> <li>V1 API: Legacy Affinity endpoints at <code>https://api.affinity.co</code>. Used for writes and some read operations.</li> <li>V2 API: Newer Affinity endpoints at <code>https://api.affinity.co/v2</code>. Used for most reads with better performance.</li> </ul> <p>The SDK automatically routes requests to the appropriate API version.</p>"},{"location":"glossary/#v2-api-version","title":"V2 API Version","text":"<p>V2 has dated versions (for example <code>2024-01-01</code>). In the Affinity dashboard, your API key has a \"Default API Version\" setting that selects the V2 version used for your requests.</p>"},{"location":"glossary/#beta-endpoints","title":"Beta Endpoints","text":"<p>Some V2 endpoints are opt-in and require <code>enable_beta_endpoints=True</code> in the SDK. Currently includes merge operations.</p>"},{"location":"glossary/#typed-ids","title":"Typed IDs","text":"<p>The SDK uses typed ID classes to reduce accidental mixups:</p> <ul> <li><code>PersonId</code> - Person identifier</li> <li><code>CompanyId</code> - Company identifier</li> <li><code>OpportunityId</code> - Opportunity identifier</li> <li><code>ListId</code> - List identifier</li> <li><code>ListEntryId</code> - List entry identifier</li> <li><code>FieldId</code> - Field definition identifier</li> <li><code>FieldValueId</code> - Field value identifier</li> <li><code>NoteId</code> - Note identifier</li> <li><code>InteractionId</code> - Interaction identifier</li> <li><code>FileId</code> - File attachment identifier</li> </ul>"},{"location":"glossary/#fields-and-field-values","title":"Fields and Field Values","text":"<ul> <li>Field (metadata): A custom field definition on a list or entity type. Has a name, type, and configuration.</li> <li>Field Value: The actual data stored in a field for a specific entity or list entry.</li> <li><code>fields.requested</code>: Boolean indicating whether field data was requested and returned by the API. If <code>False</code>, fields were not fetched.</li> </ul>"},{"location":"glossary/#interactions","title":"Interactions","text":"<p>Records of communication or meetings with entities:</p> <ul> <li><code>email</code> - Email correspondence</li> <li><code>meeting</code> - Calendar meetings</li> <li><code>call</code> - Phone calls</li> <li><code>chat_message</code> - Chat/text messages</li> <li><code>in_person</code> - In-person meetings</li> </ul>"},{"location":"glossary/#relationship-strength","title":"Relationship Strength","text":"<p>A score (0-5) indicating how strong the relationship is between your organization and a person/company, based on interaction frequency and recency.</p> <p>Note: The SDK uses <code>client.relationships</code> service, while the CLI uses <code>xaffinity relationship-strength</code> command (with hyphen).</p>"},{"location":"glossary/#eventual-consistency-v1v2","title":"Eventual Consistency (V1\u2192V2)","text":"<p>After creating or updating an entity via V1, there's a brief delay (typically 100-500ms) before the change appears in V2 reads. See Errors &amp; retries.</p>"},{"location":"glossary/#session-caching-cli","title":"Session Caching (CLI)","text":"<p>A CLI feature that shares metadata (field definitions, list configurations) across multiple commands in a pipeline, reducing redundant API calls.</p>"},{"location":"glossary/#pageiterator","title":"PageIterator","text":"<p>The object returned by <code>all()</code> and <code>iter()</code> methods. Supports:</p> <ul> <li>Direct iteration (<code>for item in iterator</code>)</li> <li><code>pages()</code> method for page-by-page access with progress callbacks</li> <li><code>all()</code> method to collect all items into a list</li> </ul>"},{"location":"glossary/#policies","title":"Policies","text":"<p>Client-level configuration that controls SDK behavior:</p> <ul> <li>WritePolicy: <code>ALLOW</code> (default) or <code>DENY</code> to prevent write operations</li> <li>ExternalHookPolicy: Controls how external URLs appear in hook events (<code>REDACT</code>, <code>SUPPRESS</code>, <code>EMIT_UNSAFE</code>)</li> </ul>"},{"location":"glossary/#exception-types","title":"Exception Types","text":"<p>The SDK raises specific exception types for different error conditions:</p> <ul> <li>AffinityError: Base class for all SDK errors</li> <li>AuthenticationError: Invalid or missing API key (401)</li> <li>PermissionError: Insufficient permissions for the operation (403)</li> <li>NotFoundError: Requested resource does not exist (404)</li> <li>RateLimitError: API rate limit exceeded (429); includes <code>retry_after</code> attribute</li> <li>ValidationError: Invalid input data or request parameters</li> <li>BetaEndpointDisabledError: Beta endpoint used without <code>enable_beta_endpoints=True</code></li> <li>VersionCompatibilityError: API version mismatch between client and server</li> </ul> <p>See Errors &amp; retries for handling strategies.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#401-403-errors","title":"401 / 403 errors","text":"<ul> <li>Verify your API key is correct.</li> <li>Ensure the key has access to the entities you\u2019re querying.</li> </ul>"},{"location":"troubleshooting/#404-immediately-after-create","title":"404 immediately after create","text":"<p>If you get a 404 <code>NotFoundError</code> when calling <code>get()</code> right after <code>create()</code>, this is due to V1\u2192V2 eventual consistency. The entity exists but hasn't propagated to V2 yet. This typically resolves within 100-500ms, but can take longer under load.</p> <p>Solutions: - Use the object returned by <code>create()</code> directly (recommended) - Use <code>get(..., retries=3)</code> to retry with backoff</p> <p>See V1\u2192V2 eventual consistency for details.</p>"},{"location":"troubleshooting/#stale-data-after-update","title":"Stale data after update","text":"<p>If <code>get()</code> returns old values after calling <code>update()</code>, this is also due to V1\u2192V2 eventual consistency. The update succeeded, but V2 hasn't synced yet. Like the 404 case, this typically resolves within 100-500ms.</p> <p>Solution: Use the object returned by <code>update()</code> directly - it contains the updated data.</p> <p>See Stale data after update for details.</p>"},{"location":"troubleshooting/#underscores-escaped-in-note-content","title":"Underscores escaped in note content","text":"<p>When you create or update a note, the Affinity API escapes underscores in the content:</p> <pre><code>Input:  \"test_note_content\"\nOutput: \"test\\_note\\_content\"\n</code></pre> <p>This is server-side markdown escaping and cannot be prevented. If you need to search for or compare note content, account for this transformation:</p> <pre><code># When checking note content, allow for escaped underscores\noriginal = \"my_note\"\nfrom_api = note.content\nassert from_api in (original, original.replace(\"_\", r\"\\_\"))\n</code></pre>"},{"location":"troubleshooting/#rate-limits","title":"Rate limits","text":"<p>The client tracks rate-limit state and retries some requests automatically. See Client and Exceptions.</p>"},{"location":"troubleshooting/#debugging","title":"Debugging","text":"<p>Enable hooks or set <code>log_requests=True</code> on the client.</p>"},{"location":"troubleshooting/#cli-disable-update-notifications","title":"CLI: Disable update notifications","text":"<p>The CLI shows update notifications in interactive sessions. To disable:</p> <p>For a single command: <pre><code>xaffinity --no-update-check person ls\n</code></pre></p> <p>Via environment variable: <pre><code>export XAFFINITY_NO_UPDATE_CHECK=1\n</code></pre></p> <p>Via config file (<code>~/.config/xaffinity/config.toml</code>): <pre><code>[default]\nupdate_check = false\n</code></pre></p> <p>Automatic suppression: Notifications are automatically hidden when using <code>--quiet</code>, <code>--output json</code>, in CI environments, or when not attached to a terminal.</p> <p>See CLI Update Notifications for more details.</p>"},{"location":"troubleshooting/#next-steps","title":"Next steps","text":"<ul> <li>Getting started</li> <li>Examples</li> <li>Debugging hooks</li> <li>Errors &amp; retries</li> </ul>"},{"location":"ai-integrations/","title":"AI Integrations","text":"<p>Connect AI tools to Affinity CRM for intelligent workflows, meeting preparation, and pipeline management.</p>"},{"location":"ai-integrations/#choose-your-integration","title":"Choose Your Integration","text":"Integration Best For What It Provides MCP Server Any MCP-compatible AI tool Tools for search, workflows, relationship intelligence Claude Code Plugins Claude Code users Skills that teach Claude SDK/CLI best practices"},{"location":"ai-integrations/#mcp-server","title":"MCP Server","text":"<p>The Model Context Protocol (MCP) server connects desktop AI applications to Affinity:</p> <ul> <li>Claude Desktop, ChatGPT Desktop, Cursor, Windsurf, VS Code + Copilot, and more</li> <li>7 native tools for entity search, relationship insights, workflow management, and full CLI access via gateway</li> <li>8 guided prompts for common workflows (meeting prep, pipeline review, warm intros)</li> </ul> <p>MCP Server documentation{ .md-button }</p>"},{"location":"ai-integrations/#claude-code-plugins-skills","title":"Claude Code Plugins &amp; Skills","text":"<p>Claude Code plugins provide skills\u2014knowledge packages that teach Claude domain-specific patterns:</p> Plugin Skill What Claude Learns <code>sdk@xaffinity</code> affinity-python-sdk Typed IDs, context managers, pagination, filtering gotchas <code>cli@xaffinity</code> xaffinity-cli-usage <code>--readonly</code> default, <code>--json</code> output, API key verification <p>Claude Code Plugins documentation{ .md-button }</p>"},{"location":"ai-integrations/#quick-install","title":"Quick Install","text":""},{"location":"ai-integrations/#mcp-server_1","title":"MCP Server","text":"<p>Claude Desktop (easiest - MCPB bundle):</p> <ol> <li>Install CLI: <code>pipx install \"affinity-sdk[cli]\"</code></li> <li>(Optional) Pre-configure API key: <code>xaffinity config setup-key</code> (Claude Desktop will prompt if skipped)</li> <li>Download <code>.mcpb</code> from GitHub Releases and double-click</li> </ol> <p>Other clients (Cursor, Windsurf, VS Code, etc.):</p> <pre><code>pipx install \"affinity-sdk[cli]\"\nxaffinity config setup-key\n</code></pre> <p>Then add to your MCP client's configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"xaffinity\": {\n      \"command\": \"/path/to/affinity-sdk/mcp/xaffinity-mcp.sh\"\n    }\n  }\n}\n</code></pre>"},{"location":"ai-integrations/#claude-code-plugins","title":"Claude Code Plugins","text":"<pre><code>/plugin marketplace add yaniv-golan/affinity-sdk\n/plugin install sdk@xaffinity   # SDK patterns\n/plugin install cli@xaffinity   # CLI patterns\n/plugin install mcp@xaffinity   # MCP server (Claude Code only)\n</code></pre>"},{"location":"ai-integrations/#when-to-use-what","title":"When to Use What","text":"Scenario Recommended Writing Python scripts with the SDK SDK plugin (skills) Running CLI commands CLI plugin (skills) Meeting prep, pipeline management, logging interactions MCP Server Using Claude Desktop, Cursor, or other MCP clients MCP Server Using Claude Code for development Both plugins + optionally MCP"},{"location":"cli/","title":"CLI","text":"<p>The SDK ships an optional <code>xaffinity</code> CLI that dogfoods the SDK. Install it as an extra so library-only users don't pay the dependency cost.</p>"},{"location":"cli/#key-features","title":"Key Features","text":"<ul> <li>Query Language: Complex queries with filtering, aggregations, and includes (Query Guide)</li> <li>CSV Export: Export people, companies, opportunities, and list entries to CSV with <code>--csv</code> flag (CSV Export Guide)</li> <li>Filtering: Server-side filtering on custom fields with <code>--filter</code> (Filtering Guide)</li> <li>JSON Output: All commands support <code>--json</code> for programmatic use (Scripting Guide)</li> <li>Datetime Handling: Local time input, UTC output for JSON (Datetime Guide)</li> <li>Pagination: Fetch all pages with <code>--all</code>, control page size with <code>--page-size</code> (items per API call), or limit total results with <code>--max-results</code></li> <li>Name Resolution: Use names instead of IDs for lists, fields, and entities</li> <li>Session Caching: Share metadata across pipeline commands with <code>session start/end</code> (Pipeline Optimization)</li> </ul> <p>See Commands Reference for complete command documentation.</p>"},{"location":"cli/#ai-integration","title":"AI Integration","text":""},{"location":"cli/#mcp-server","title":"MCP Server","text":"<p>Connect desktop AI tools (Claude Desktop, Cursor, Windsurf, VS Code + Copilot) to Affinity.</p> <p>Important: The CLI is a prerequisite for the MCP server. Install and configure the CLI first (see Install and Authentication below), then follow the MCP Server setup guide.</p>"},{"location":"cli/#claude-code","title":"Claude Code","text":"<p>Using Claude Code? Install the CLI plugin for AI-assisted usage:</p> <pre><code>/plugin marketplace add yaniv-golan/affinity-sdk\n/plugin install cli@xaffinity\n</code></pre> <p>This teaches Claude CLI patterns and provides the <code>/affinity-help</code> quick reference command. See Claude Code plugins for all available plugins.</p>"},{"location":"cli/#install","title":"Install","text":"<p>Recommended for end-users:</p> <pre><code>pipx install \"affinity-sdk[cli]\"\n</code></pre> <p>Or in a virtualenv:</p> <pre><code>pip install \"affinity-sdk[cli]\"\n</code></pre>"},{"location":"cli/#verify-installation","title":"Verify Installation","text":"<p>Step 1: Check the CLI is installed:</p> <pre><code>xaffinity --version\n</code></pre> <p>Expected: Version number (e.g., <code>0.15.0</code>)</p> <p>Step 2: Verify API connectivity with your API key:</p> <pre><code>AFFINITY_API_KEY=\"your-key-here\" xaffinity whoami\n</code></pre> <p>Expected: Your user information and tenant details</p> <p>If <code>whoami</code> hangs, check network connectivity (firewall, proxy, VPN). If it returns an authentication error, verify your API key is correct (Settings \u2192 API Keys in Affinity).</p> <p>Once verified, see Authentication for persistent API key configuration options.</p>"},{"location":"cli/#authentication","title":"Authentication","text":"<p>The CLI never makes \"background\" requests. It only calls the API for commands that require it.</p>"},{"location":"cli/#quick-setup","title":"Quick Setup","text":"<p>Check if a key is already configured:</p> <pre><code>xaffinity config check-key\n</code></pre> <p>Set up a new key securely (hidden input, not echoed):</p> <pre><code>xaffinity config setup-key\n</code></pre> <p>See config check-key and config setup-key for details.</p>"},{"location":"cli/#api-key-sources","title":"API Key Sources","text":"<p>The CLI checks these sources in order (highest precedence first):</p> <ol> <li><code>--api-key-stdin</code> flag (reads from stdin)</li> <li><code>--api-key-file PATH</code> (reads from file, or <code>-</code> for stdin)</li> <li><code>AFFINITY_API_KEY</code> environment variable</li> <li><code>.env</code> file in current directory (requires <code>--dotenv</code> flag, or use <code>--env-file &lt;path&gt;</code> which implicitly enables dotenv)</li> <li><code>api_key</code> in user config file (<code>~/.config/xaffinity/config.toml</code>)</li> </ol>"},{"location":"cli/#reading-from-file-or-stdin","title":"Reading from File or Stdin","text":"<p>For scripts or CI/CD pipelines, you can pass the API key via file or stdin:</p> <pre><code># Read from a secrets file\nxaffinity --api-key-file /run/secrets/affinity-key whoami\n\n# Read from stdin (useful for piping from secret managers)\nvault kv get -field=api_key secret/affinity | xaffinity --api-key-stdin whoami\n\n# Equivalent: --api-key-file - reads from stdin\necho \"$SECRET_KEY\" | xaffinity --api-key-file - whoami\n</code></pre>"},{"location":"cli/#using-env-files","title":"Using .env Files","text":"<p>For project-specific keys, use <code>--dotenv</code> to load from <code>.env</code>:</p> <pre><code>xaffinity --dotenv whoami\nxaffinity --dotenv --env-file ./dev.env whoami\n</code></pre> <p>The <code>config setup-key --scope project</code> command creates a <code>.env</code> file and adds it to <code>.gitignore</code> automatically.</p>"},{"location":"cli/#output-contract","title":"Output contract","text":"<ul> <li><code>--json</code> is supported on every command.</li> <li>In <code>--json</code> mode, JSON is written to stdout. Progress/logging go to stderr.</li> <li>Human/table output goes to stdout; diagnostics go to stderr.</li> <li>Commands build a single structured result and then render it as either JSON or table output (no \u201cdouble implementations\u201d).</li> <li>In <code>--json</code> mode, <code>data</code> is an object keyed by section name (even for single-section commands), and pagination tokens/URLs live in <code>meta.pagination.&lt;section&gt;</code>.</li> <li>If <code>--max-results</code> truncates results mid-page, the CLI may omit <code>meta.pagination.&lt;section&gt;</code> to avoid producing an unsafe resume token.</li> </ul>"},{"location":"cli/#performance","title":"Performance","text":"<p>The CLI enables SDK in-memory caching for cacheable metadata requests (e.g., field metadata) automatically.</p> <p>For pipelines running multiple commands, use session caching to share metadata across invocations:</p> <pre><code>export AFFINITY_SESSION_CACHE=$(xaffinity session start)\nxaffinity list export \"My List\" | xaffinity person get\nxaffinity session end\n</code></pre> <p>See Pipeline Optimization for details.</p>"},{"location":"cli/#query-command-tuning","title":"Query Command Tuning","text":"<p>For the <code>query</code> command, advanced users can tune concurrency:</p> Variable Default Description <code>XAFFINITY_QUERY_CONCURRENCY</code> 15 Max concurrent API calls for fetches/expansions <p>Higher values speed up queries with <code>include</code> or <code>expand</code> but may trigger rate limits on smaller accounts.</p>"},{"location":"cli/#update-notifications","title":"Update Notifications","text":"<p>The CLI checks for available updates once per day and displays a notification after command execution:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Update available: 1.0.0 \u2192 1.1.0                     \u2502\n\u2502  Run: pip install --upgrade \"affinity-sdk[cli]\"      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The upgrade command is auto-detected based on your installation method (pipx, uv, pip).</p> <p>The check is non-blocking and never delays command execution. Notifications are automatically suppressed when:</p> <ul> <li>Using <code>--quiet</code> or <code>--output json</code></li> <li>Running in CI/CD environments (<code>CI</code>, <code>GITHUB_ACTIONS</code>, etc.)</li> <li>Not attached to a terminal</li> <li>Using the <code>--no-update-check</code> flag</li> </ul>"},{"location":"cli/#configuration","title":"Configuration","text":"<p>Disable update checks via config file (<code>~/.config/xaffinity/config.toml</code>):</p> <pre><code>[default]\nupdate_check = false\n</code></pre> <p>Or via environment variable:</p> <pre><code>export XAFFINITY_NO_UPDATE_CHECK=1\n</code></pre> <p>Control notification behavior with <code>update_notify</code>:</p> <pre><code>[default]\nupdate_notify = \"interactive\"  # \"interactive\" (default), \"always\", or \"never\"\n</code></pre>"},{"location":"cli/#manual-check","title":"Manual Check","text":"<p>Check for updates manually:</p> <pre><code>xaffinity config update-check --now\n</code></pre> <p>See current update status:</p> <pre><code>xaffinity config update-check --status\n</code></pre>"},{"location":"cli/#background-check-for-mcpautomation","title":"Background Check (for MCP/Automation)","text":"<p>Trigger a non-blocking background update check (used by MCP server):</p> <pre><code>xaffinity config update-check --background\n</code></pre> <p>This spawns a background worker that checks for updates and caches the result. It exits immediately with no output on success, exit code 1 on failure.</p>"},{"location":"cli/#progress-quiet-mode","title":"Progress + quiet mode","text":"<ul> <li>Long operations show progress bars/spinners on stderr when interactive.</li> <li><code>-q/--quiet</code> disables progress and suppresses non-essential stderr output.</li> </ul>"},{"location":"cli/#logging","title":"Logging","text":"<p>The CLI writes logs to platform-standard locations (via <code>platformdirs</code>), with rotation and redaction.</p> <p>Override with:</p> <ul> <li><code>--log-file &lt;path&gt;</code></li> <li><code>--no-log-file</code></li> </ul>"},{"location":"cli/#sdk-controls","title":"SDK controls","text":"<p>These flags expose useful SDK behaviors directly from the CLI:</p> <ul> <li><code>--readonly</code>: disallow write operations (guard rail for scripts).</li> <li><code>--max-retries N</code>: tune rate-limit retry behavior.</li> <li><code>--trace</code>: trace request/response/error events to stderr (safe redaction).</li> </ul>"},{"location":"cli/#advanced-configuration-testing","title":"Advanced configuration (testing)","text":"<p>For testing against mock servers, these environment variables override API base URLs:</p> <ul> <li><code>AFFINITY_V1_BASE_URL</code>: Override V1 API base URL (default: <code>https://api.affinity.co</code>)</li> <li><code>AFFINITY_V2_BASE_URL</code>: Override V2 API base URL (default: <code>https://api.affinity.co/v2</code>)</li> </ul> <p>These can also be set per-profile in the config file.</p>"},{"location":"cli/#exit-codes","title":"Exit codes","text":"<ul> <li><code>0</code>: success</li> <li><code>1</code>: general error</li> <li><code>2</code>: usage/validation error (including ambiguous name resolution)</li> <li><code>3</code>: auth/permission error (401/403)</li> <li><code>4</code>: not found</li> <li><code>5</code>: rate limited or temporary upstream failure (429/5xx after retries)</li> <li><code>130</code>: interrupted (Ctrl+C)</li> <li><code>143</code>: terminated (SIGTERM)</li> </ul>"},{"location":"cli/commands/","title":"Commands","text":""},{"location":"cli/commands/#no-network-commands","title":"No-network commands","text":"<p>These commands never call the Affinity API:</p> <ul> <li><code>xaffinity --help</code></li> <li><code>xaffinity completion bash|zsh|fish</code></li> <li><code>xaffinity version</code> (also <code>xaffinity --version</code>)</li> <li><code>xaffinity config path</code></li> <li><code>xaffinity config init</code></li> <li><code>xaffinity config check-key</code> (reads files, but never calls API)</li> </ul>"},{"location":"cli/commands/#configuration","title":"Configuration","text":""},{"location":"cli/commands/#xaffinity-config-path","title":"<code>xaffinity config path</code>","text":"<p>Show the path to the configuration file.</p> <pre><code>xaffinity config path\n</code></pre>"},{"location":"cli/commands/#xaffinity-config-init","title":"<code>xaffinity config init</code>","text":"<p>Create a new configuration file with template.</p> <pre><code>xaffinity config init\nxaffinity config init --force  # Overwrite existing\n</code></pre>"},{"location":"cli/commands/#xaffinity-config-check-key","title":"<code>xaffinity config check-key</code>","text":"<p>Check if an API key is configured. Returns exit code 0 if key found, 1 if not found.</p> <p>This command checks (in order): 1. <code>AFFINITY_API_KEY</code> environment variable 2. <code>.env</code> file in current directory 3. User config file (<code>config.toml</code>)</p> <pre><code>xaffinity config check-key\nxaffinity config check-key --json\nxaffinity config check-key &amp;&amp; echo \"Key exists\"\n</code></pre> <p>The <code>--json</code> output includes: - <code>configured</code>: boolean indicating if a key was found - <code>source</code>: where the key was found (<code>\"environment\"</code>, <code>\"dotenv\"</code>, <code>\"config\"</code>, or <code>null</code>)</p>"},{"location":"cli/commands/#xaffinity-config-setup-key","title":"<code>xaffinity config setup-key</code>","text":"<p>Securely configure your Affinity API key. Prompts for the key with hidden input (not echoed to screen).</p> <p>Options:</p> <ul> <li><code>--scope [project|user]</code>: Where to store the key</li> <li><code>project</code>: <code>.env</code> file in current directory (auto-added to <code>.gitignore</code>)</li> <li><code>user</code>: User config file (<code>config.toml</code>, with <code>chmod 600</code> on Unix)</li> <li><code>--force</code>: Overwrite existing key without confirmation</li> <li><code>--validate/--no-validate</code>: Test key against API after storing (default: validate)</li> </ul> <pre><code># Interactive setup (prompts for scope)\nxaffinity config setup-key\n\n# Store in current project's .env file\nxaffinity config setup-key --scope project\n\n# Store in user config (works across all projects)\nxaffinity config setup-key --scope user\n\n# Overwrite existing key\nxaffinity config setup-key --force\n\n# Skip API validation\nxaffinity config setup-key --no-validate\n</code></pre> <p>Get your API key from Affinity API Settings.</p>"},{"location":"cli/commands/#global-options","title":"Global options","text":"<p>These options can be used with any command:</p> <ul> <li><code>--json</code> / <code>--output json</code>: emit machine-readable <code>CommandResult</code> JSON to stdout.</li> <li><code>--help --json</code>: emit machine-readable command documentation (see Scripting: Machine-Readable Help).</li> <li><code>--trace</code>: emit request/response/error trace lines to stderr (safe redaction). Recommended with <code>--no-progress</code> for long-running commands.</li> <li><code>--beta</code>: enable beta endpoints (required for merge commands).</li> <li><code>--session-cache &lt;dir&gt;</code>: enable session caching using the specified directory.</li> <li><code>--no-cache</code>: disable session caching for this command.</li> </ul>"},{"location":"cli/commands/#pipeline-optimization","title":"Pipeline Optimization","text":"<p>When running multiple CLI commands in a pipeline, you can enable session caching to avoid redundant API calls for metadata like field definitions and list resolution.</p>"},{"location":"cli/commands/#using-session-commands","title":"Using session commands","text":"<pre><code># Start a session (creates temp cache directory)\nexport AFFINITY_SESSION_CACHE=$(xaffinity session start)\n\n# Run your commands - metadata is cached across invocations\nxaffinity list export \"My List\" --json &gt; entries.json\nxaffinity field ls --list-id 12345\nxaffinity person get 12345\n\n# Check session status\nxaffinity session status\n\n# End session (cleanup)\nxaffinity session end\nunset AFFINITY_SESSION_CACHE\n</code></pre>"},{"location":"cli/commands/#best-practice-for-scripts-with-automatic-cleanup","title":"Best practice for scripts (with automatic cleanup)","text":"<pre><code>#!/bin/bash\nexport AFFINITY_SESSION_CACHE=$(xaffinity session start) || exit 1\ntrap 'xaffinity session end; unset AFFINITY_SESSION_CACHE' EXIT\n\n# Your commands here - cleanup happens automatically on exit, error, or Ctrl+C\nxaffinity list export \"My List\" | jq '.entries[]' | xaffinity person get\n</code></pre>"},{"location":"cli/commands/#quick-one-liner-pattern-subshell","title":"Quick one-liner pattern (subshell)","text":"<p>For simple pipelines, use a subshell - the session dir is cleaned up by TTL:</p> <pre><code>(\n  export AFFINITY_SESSION_CACHE=$(xaffinity session start)\n  xaffinity list export \"My List\" | xaffinity person get\n)\n</code></pre>"},{"location":"cli/commands/#cache-behavior","title":"Cache behavior","text":"<ul> <li>Cache is scoped to your API key (multi-tenant safe)</li> <li>Default TTL is 10 minutes (configurable via <code>AFFINITY_SESSION_CACHE_TTL</code>)</li> <li>Cache is file-based in the specified directory</li> <li><code>session end</code> is idempotent - safe to call multiple times</li> </ul>"},{"location":"cli/commands/#environment-variables","title":"Environment variables","text":"Variable Description <code>AFFINITY_SESSION_CACHE</code> Directory for session cache files <code>AFFINITY_SESSION_CACHE_TTL</code> Cache TTL in seconds (default: 600)"},{"location":"cli/commands/#session-commands","title":"Session commands","text":"Command Description <code>xaffinity session start</code> Create session cache, output path <code>xaffinity session end</code> Clean up session cache directory <code>xaffinity session status</code> Show cache stats (entries, size, age)"},{"location":"cli/commands/#debugging","title":"Debugging","text":"<p>Use <code>--trace</code> to see cache hit/miss information:</p> <pre><code>xaffinity --trace list export \"My List\"\n# trace #+ cache hit: list_fields_12345\n# trace #- cache miss: saved_views_12345\n</code></pre> <p>Use <code>--no-cache</code> to bypass session cache:</p> <pre><code>xaffinity --no-cache list export \"My List\"\n</code></pre>"},{"location":"cli/commands/#identity","title":"Identity","text":""},{"location":"cli/commands/#xaffinity-whoami","title":"<code>xaffinity whoami</code>","text":"<p>Validates credentials and prints tenant/user context.</p> <pre><code>xaffinity whoami\nxaffinity whoami --json | jq\n</code></pre>"},{"location":"cli/commands/#url-resolution","title":"URL resolution","text":""},{"location":"cli/commands/#xaffinity-resolve-url-url","title":"<code>xaffinity resolve-url &lt;url&gt;</code>","text":"<p>Parses an Affinity UI URL (including tenant hosts like <code>https://&lt;tenant&gt;.affinity.co/...</code> or <code>https://&lt;tenant&gt;.affinity.com/...</code>) and validates it by fetching the referenced object.</p> <pre><code>xaffinity resolve-url \"https://app.affinity.co/companies/263169568\"\nxaffinity resolve-url \"https://mydomain.affinity.com/companies/263169568\" --json\n</code></pre>"},{"location":"cli/commands/#query","title":"Query","text":""},{"location":"cli/commands/#xaffinity-query","title":"<code>xaffinity query</code>","text":"<p>Execute structured JSON queries against Affinity data. Supports complex filtering, aggregations, grouping, and including related entities.</p> <pre><code># Simple query\nxaffinity query --query '{\"from\": \"persons\", \"limit\": 10}'\n\n# Filter with conditions\nxaffinity query --query '{\"from\": \"persons\", \"where\": {\"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.com\"}}'\n\n# Include related entities\nxaffinity query --query '{\"from\": \"persons\", \"include\": [\"companies\"], \"limit\": 50}'\n\n# Aggregation\nxaffinity query --query '{\"from\": \"opportunities\", \"groupBy\": \"status\", \"aggregate\": {\"count\": {\"count\": true}}}'\n\n# Dry-run to preview execution plan\nxaffinity query --query '{\"from\": \"persons\", \"include\": [\"companies\"]}' --dry-run\n\n# From file\nxaffinity query --file query.json\n</code></pre> <p>Key options:</p> <ul> <li><code>--query &lt;json&gt;</code>: Inline JSON query string</li> <li><code>--file &lt;path&gt;</code>: Read query from JSON file</li> <li><code>--dry-run</code>: Show execution plan without running (estimated API calls)</li> <li><code>--dry-run-verbose</code>: Detailed plan with step breakdown</li> <li><code>--max-records &lt;n&gt;</code>: Safety limit (default: 10000)</li> <li><code>--timeout &lt;secs&gt;</code>: Query timeout (default: 300)</li> <li><code>--csv</code> / <code>--json</code>: Output format</li> </ul> <p>See Query Language Reference and Query Guide for full documentation.</p>"},{"location":"cli/commands/#people","title":"People","text":""},{"location":"cli/commands/#xaffinity-person-ls","title":"<code>xaffinity person ls</code>","text":"<p>List persons. Supports field selection, filter expressions, and free-text search.</p> <p>Options:</p> <ul> <li><code>--query &lt;term&gt;</code> / <code>-q &lt;term&gt;</code>: free-text search (name or email)</li> <li><code>--field &lt;id-or-name&gt;</code> (repeatable): field ID or name to include</li> <li><code>--field-type &lt;type&gt;</code> (repeatable): field type to include (global, enriched, relationship-intelligence)</li> <li><code>--filter &lt;expression&gt;</code>: filter expression (custom fields only)</li> <li><code>--page-size</code>, <code>--cursor</code>, <code>--max-results</code>, <code>--all</code>: pagination options</li> <li><code>--csv</code>: output as CSV (to stdout)</li> <li><code>--csv-bom</code>: add UTF-8 BOM for Excel compatibility</li> </ul> <p>Note: <code>--filter</code> only works with custom fields. To filter on built-in properties like <code>type</code>, <code>firstName</code>, etc., use <code>--json</code> output with <code>jq</code>.</p> <p>Note: <code>--query</code> can be combined with <code>--field</code> and <code>--field-type</code> to search with field data.</p> <pre><code>xaffinity person ls\nxaffinity person ls --page-size 50\nxaffinity person ls --field-type enriched --all\nxaffinity person ls --filter 'Email =~ \"@acme.com\"'\nxaffinity person ls --query \"alice@example.com\"\nxaffinity person ls --query \"Alice\" --field-type enriched --all\nxaffinity person ls --all --csv &gt; people.csv\nxaffinity person ls --all --csv --csv-bom &gt; people.csv\n</code></pre> <p>See the CSV Export Guide for more details.</p>"},{"location":"cli/commands/#xaffinity-person-get-personselector","title":"<code>xaffinity person get &lt;personSelector&gt;</code>","text":"<p>Fetch a person by id, UI URL (including tenant hosts), or a resolver selector.</p> <p>Examples:</p> <pre><code>xaffinity person get 26229794\nxaffinity person get \"https://mydomain.affinity.com/persons/26229794\"\nxaffinity person get email:alice@example.com\nxaffinity person get 'name:\"Alice Smith\"'\n</code></pre> <p>Field selection:</p> <ul> <li><code>--all-fields</code>: include all supported (non-list-specific) fields.</li> <li><code>--field &lt;id-or-exact-name&gt;</code> (repeatable)</li> <li><code>--field-type &lt;type&gt;</code> (repeatable)</li> <li><code>--no-fields</code>: skip fields entirely.</li> </ul> <p>Expansions:</p> <ul> <li><code>--expand lists</code>: include lists the person is on (auto-paginates up to a safe cap; use <code>--max-results</code> / <code>--all</code> to adjust).</li> <li><code>--expand list-entries</code>: include list entries for the person (first page by default; use <code>--max-results</code> / <code>--all</code> to fetch more).</li> <li><code>--list &lt;id-or-exact-name&gt;</code>: filter list entries to a specific list (requires <code>--expand list-entries</code>).</li> <li><code>--list-entry-field &lt;id-or-exact-name&gt;</code> (repeatable): project list-entry fields into columns (requires <code>--expand list-entries</code>). Field names are only allowed with <code>--list</code>.</li> <li><code>--show-list-entry-fields</code>: render per-list-entry Fields tables in human output (requires <code>--expand list-entries</code> and <code>--max-results &lt;= 3</code>). Mutually exclusive with <code>--list-entry-field</code>.</li> <li><code>--list-entry-fields-scope list-only|all</code>: control which fields appear in list-entry tables (human output only).</li> </ul> <p>Interaction dates (V1 API):</p> <ul> <li><code>--with-interaction-dates</code>: include interaction date summaries (last/next meeting, email dates). Uses V1 API.</li> <li><code>--with-interaction-persons</code>: include person IDs involved in each interaction (requires <code>--with-interaction-dates</code>).</li> </ul> <pre><code>xaffinity person get 26229794 --all-fields --expand lists\nxaffinity person get 26229794 --expand list-entries --list \"Dealflow\" --max-results 200\nxaffinity person get 26229794 --expand list-entries --list \"Dealflow\" --list-entry-field Stage --list-entry-field Amount\nxaffinity person get 26229794 --expand list-entries --max-results 1 --show-list-entry-fields\nxaffinity person get 26229794 --expand list-entries --max-results 1 --show-list-entry-fields --list-entry-fields-scope all\nxaffinity person get 26229794 --all-fields --expand lists --json | jq '.data.person.name'\n\n# Include interaction dates (last meeting, next meeting, email dates)\nxaffinity person get 26229794 --with-interaction-dates --json\nxaffinity person get 26229794 --with-interaction-dates --with-interaction-persons --json\n</code></pre>"},{"location":"cli/commands/#xaffinity-person-create","title":"<code>xaffinity person create</code>","text":"<pre><code>xaffinity person create --first-name Ada --last-name Lovelace --email ada@example.com\nxaffinity person create --first-name Ada --last-name Lovelace --company-id 224925494\n</code></pre>"},{"location":"cli/commands/#xaffinity-person-update-personid","title":"<code>xaffinity person update &lt;personId&gt;</code>","text":"<pre><code>xaffinity person update 26229794 --email ada@example.com --email ada@work.com\nxaffinity person update 26229794 --first-name Ada --last-name Byron\n</code></pre>"},{"location":"cli/commands/#xaffinity-person-delete-personid","title":"<code>xaffinity person delete &lt;personId&gt;</code>","text":"<pre><code>xaffinity person delete 26229794\n</code></pre>"},{"location":"cli/commands/#xaffinity-person-merge-primaryid-duplicateid","title":"<code>xaffinity person merge &lt;primaryId&gt; &lt;duplicateId&gt;</code>","text":"<pre><code>xaffinity --beta person merge 111 222\n</code></pre>"},{"location":"cli/commands/#xaffinity-person-files-dump-personid","title":"<code>xaffinity person files dump &lt;personId&gt;</code>","text":"<p>Downloads all files attached to a person into a folder bundle with a <code>manifest.json</code>.</p> <pre><code>xaffinity person files dump 12345 --out ./bundle\n</code></pre>"},{"location":"cli/commands/#xaffinity-person-files-upload-personid","title":"<code>xaffinity person files upload &lt;personId&gt;</code>","text":"<p>Uploads one or more files to a person.</p> <pre><code>xaffinity person files upload 12345 --file doc.pdf\nxaffinity person files upload 12345 --file a.pdf --file b.pdf\n</code></pre>"},{"location":"cli/commands/#companies","title":"Companies","text":""},{"location":"cli/commands/#xaffinity-company-ls","title":"<code>xaffinity company ls</code>","text":"<p>List companies. Supports field selection, filter expressions, and free-text search.</p> <p>Options:</p> <ul> <li><code>--query &lt;term&gt;</code> / <code>-q &lt;term&gt;</code>: free-text search (name or domain)</li> <li><code>--field &lt;id-or-name&gt;</code> (repeatable): field ID or name to include</li> <li><code>--field-type &lt;type&gt;</code> (repeatable): field type to include (global, enriched, relationship-intelligence)</li> <li><code>--filter &lt;expression&gt;</code>: filter expression (custom fields only)</li> <li><code>--page-size</code>, <code>--cursor</code>, <code>--max-results</code>, <code>--all</code>: pagination options</li> <li><code>--csv</code>: output as CSV (to stdout)</li> <li><code>--csv-bom</code>: add UTF-8 BOM for Excel compatibility</li> </ul> <p>Note: <code>--filter</code> only works with custom fields. To filter on built-in properties like <code>name</code>, <code>domain</code>, etc., use <code>--json</code> output with <code>jq</code>.</p> <p>Note: <code>--query</code> can be combined with <code>--field</code> and <code>--field-type</code> to search with field data.</p> <pre><code>xaffinity company ls\nxaffinity company ls --page-size 50\nxaffinity company ls --field-type enriched --all\nxaffinity company ls --filter 'Industry = \"Software\"'\nxaffinity company ls --query \"example.com\"\nxaffinity company ls --query \"Example\" --field-type enriched --all\nxaffinity company ls --all --csv &gt; companies.csv\nxaffinity company ls --all --csv --csv-bom &gt; companies.csv\n</code></pre> <p>See the CSV Export Guide for more details.</p>"},{"location":"cli/commands/#xaffinity-company-get-companyselector","title":"<code>xaffinity company get &lt;companySelector&gt;</code>","text":"<p>Fetch a company by id, UI URL (including tenant hosts), or a resolver selector.</p> <p>Examples:</p> <pre><code>xaffinity company get 224925494\nxaffinity company get \"https://mydomain.affinity.com/companies/224925494\"\nxaffinity company get domain:wellybox.com\nxaffinity company get 'name:\"WellyBox\"'\n</code></pre> <p>Field selection:</p> <ul> <li><code>--all-fields</code>: include all supported (non-list-specific) fields.</li> <li><code>--field &lt;id-or-exact-name&gt;</code> (repeatable)</li> <li><code>--field-type &lt;type&gt;</code> (repeatable)</li> <li><code>--no-fields</code>: skip fields entirely.</li> </ul> <p>Expansions:</p> <ul> <li><code>--expand lists</code>: include lists the company is on (auto-paginates up to a safe cap; use <code>--max-results</code> / <code>--all</code> to adjust).</li> <li><code>--expand list-entries</code>: include list entries for the company (first page by default; use <code>--max-results</code> / <code>--all</code> to fetch more).</li> <li><code>--expand persons</code>: include people associated with the company (use <code>--max-results</code> / <code>--all</code> to control volume).</li> <li><code>--list &lt;id-or-exact-name&gt;</code>: filter list entries to a specific list (requires <code>--expand list-entries</code>).</li> <li><code>--list-entry-field &lt;id-or-exact-name&gt;</code> (repeatable): project list-entry fields into columns (requires <code>--expand list-entries</code>). Field names are only allowed with <code>--list</code>.</li> <li><code>--show-list-entry-fields</code>: render per-list-entry Fields tables in human output (requires <code>--expand list-entries</code> and <code>--max-results &lt;= 3</code>). Mutually exclusive with <code>--list-entry-field</code>.</li> <li><code>--list-entry-fields-scope list-only|all</code>: control which fields appear in list-entry tables (human output only).</li> </ul> <p>Interaction dates (V1 API):</p> <ul> <li><code>--with-interaction-dates</code>: include interaction date summaries (last/next meeting, email dates). Uses V1 API.</li> <li><code>--with-interaction-persons</code>: include person IDs involved in each interaction (requires <code>--with-interaction-dates</code>).</li> </ul> <pre><code>xaffinity company get 224925494 --all-fields --expand lists\nxaffinity company get 224925494 --expand list-entries --list \"Dealflow\" --max-results 200\nxaffinity company get 224925494 --expand list-entries --list \"Dealflow\" --list-entry-field Stage --list-entry-field Amount\nxaffinity company get 224925494 --expand list-entries --max-results 1 --show-list-entry-fields\nxaffinity company get 224925494 --expand list-entries --max-results 1 --show-list-entry-fields --list-entry-fields-scope all\nxaffinity company get 224925494 --expand persons --max-results 50\nxaffinity company get 224925494 --all-fields --expand lists --json | jq '.data.company.name'\n\n# Include interaction dates (last meeting, next meeting, email dates)\nxaffinity company get 224925494 --with-interaction-dates --json\nxaffinity company get 224925494 --with-interaction-dates --with-interaction-persons --json\n</code></pre>"},{"location":"cli/commands/#xaffinity-company-create","title":"<code>xaffinity company create</code>","text":"<pre><code>xaffinity company create --name \"Acme Corp\" --domain acme.com\nxaffinity company create --name \"Acme Corp\" --person-id 26229794\n</code></pre>"},{"location":"cli/commands/#xaffinity-company-update-companyid","title":"<code>xaffinity company update &lt;companyId&gt;</code>","text":"<pre><code>xaffinity company update 224925494 --domain acme.com\nxaffinity company update 224925494 --person-id 26229794 --person-id 26229795\n</code></pre>"},{"location":"cli/commands/#xaffinity-company-delete-companyid","title":"<code>xaffinity company delete &lt;companyId&gt;</code>","text":"<pre><code>xaffinity company delete 224925494\n</code></pre>"},{"location":"cli/commands/#xaffinity-company-merge-primaryid-duplicateid","title":"<code>xaffinity company merge &lt;primaryId&gt; &lt;duplicateId&gt;</code>","text":"<pre><code>xaffinity --beta company merge 111 222\n</code></pre>"},{"location":"cli/commands/#xaffinity-company-files-dump-companyid","title":"<code>xaffinity company files dump &lt;companyId&gt;</code>","text":"<pre><code>xaffinity company files dump 9876 --out ./bundle\n</code></pre> <p>Notes: - Saved files use the original filename when possible; if multiple files share the same name, the CLI disambiguates by appending the file id.</p>"},{"location":"cli/commands/#xaffinity-company-files-upload-companyid","title":"<code>xaffinity company files upload &lt;companyId&gt;</code>","text":"<p>Uploads one or more files to a company.</p> <pre><code>xaffinity company files upload 9876 --file doc.pdf\nxaffinity company files upload 9876 --file a.pdf --file b.pdf\n</code></pre>"},{"location":"cli/commands/#opportunities","title":"Opportunities","text":""},{"location":"cli/commands/#xaffinity-opportunity-ls","title":"<code>xaffinity opportunity ls</code>","text":"<p>List opportunities.</p> <p>Options:</p> <ul> <li><code>--page-size</code>, <code>--cursor</code>, <code>--max-results</code>, <code>--all</code>: pagination options</li> <li><code>--csv</code>: output as CSV (to stdout)</li> <li><code>--csv-bom</code>: add UTF-8 BOM for Excel compatibility</li> </ul> <pre><code>xaffinity opportunity ls\nxaffinity opportunity ls --page-size 200 --all --json\nxaffinity opportunity ls --all --csv &gt; opportunities.csv\nxaffinity opportunity ls --all --csv --csv-bom &gt; opportunities.csv\n</code></pre> <p>See the CSV Export Guide for more details.</p>"},{"location":"cli/commands/#xaffinity-opportunity-get-opportunityselector","title":"<code>xaffinity opportunity get &lt;opportunitySelector&gt;</code>","text":"<p>Fetch an opportunity by id or UI URL (including tenant hosts).</p> <pre><code>xaffinity opportunity get 123\nxaffinity opportunity get \"https://mydomain.affinity.com/opportunities/123\"\nxaffinity opportunity get 123 --details\n</code></pre> <p>Notes: - <code>--details</code> fetches a fuller payload with associations and list entries.</p>"},{"location":"cli/commands/#xaffinity-opportunity-create","title":"<code>xaffinity opportunity create</code>","text":"<p>Create a new opportunity.</p> <pre><code>xaffinity opportunity create --name \"Series A\" --list \"Dealflow\"\nxaffinity opportunity create --name \"Series A\" --list 123 --person-id 1 --company-id 2\n</code></pre>"},{"location":"cli/commands/#xaffinity-opportunity-update-opportunityid","title":"<code>xaffinity opportunity update &lt;opportunityId&gt;</code>","text":"<p>Update an opportunity (replaces association arrays when provided).</p> <pre><code>xaffinity opportunity update 123 --name \"Series A (Closed)\"\nxaffinity opportunity update 123 --person-id 1 --person-id 2\n</code></pre>"},{"location":"cli/commands/#xaffinity-opportunity-delete-opportunityid","title":"<code>xaffinity opportunity delete &lt;opportunityId&gt;</code>","text":"<pre><code>xaffinity opportunity delete 123\n</code></pre>"},{"location":"cli/commands/#xaffinity-opportunity-files-upload-opportunityid","title":"<code>xaffinity opportunity files upload &lt;opportunityId&gt;</code>","text":"<p>Uploads one or more files to an opportunity.</p> <pre><code>xaffinity opportunity files upload 123 --file doc.pdf\nxaffinity opportunity files upload 123 --file a.pdf --file b.pdf\n</code></pre>"},{"location":"cli/commands/#lists","title":"Lists","text":""},{"location":"cli/commands/#xaffinity-list-ls","title":"<code>xaffinity list ls</code>","text":"<pre><code>xaffinity list ls\nxaffinity list ls --all --json\n</code></pre>"},{"location":"cli/commands/#xaffinity-list-create","title":"<code>xaffinity list create</code>","text":"<pre><code>xaffinity list create --name \"Dealflow\" --type opportunity --private\nxaffinity list create --name \"People\" --type person --public --owner-id 42\n</code></pre>"},{"location":"cli/commands/#xaffinity-list-get-list","title":"<code>xaffinity list get &lt;list&gt;</code>","text":"<p>Accepts a list ID or an exact list name.</p> <p>The Fields table includes a <code>valueType</code> column (e.g., <code>dropdown-multi</code>, <code>ranked-dropdown</code>).</p> <pre><code>xaffinity list get 123\nxaffinity list get \"My Pipeline\" --json\n</code></pre>"},{"location":"cli/commands/#xaffinity-list-export-list","title":"<code>xaffinity list export &lt;list&gt;</code>","text":"<p>Exports list entries with selected fields. This is the most powerful CSV export command, supporting custom fields and complex filtering.</p> <p>Options:</p> <ul> <li><code>--csv</code>: output as CSV (to stdout)</li> <li><code>--csv-bom</code>: add UTF-8 BOM for Excel compatibility</li> <li><code>--field &lt;id-or-name&gt;</code> (repeatable): include specific fields</li> <li><code>--saved-view &lt;name&gt;</code>: use a saved view's field selection</li> <li><code>--filter &lt;expression&gt;</code>: filter expression</li> <li><code>--expand &lt;type&gt;</code> (repeatable): expand associated entities or interaction data</li> <li><code>persons</code>, <code>companies</code>, <code>opportunities</code>: Expand related entities</li> <li><code>interactions</code>: Add interaction date summaries (last/next meeting, email dates)</li> <li><code>--check-unreplied</code>: Check for unreplied incoming messages (email/chat) for each list entry</li> <li><code>--unreplied-types &lt;types&gt;</code>: Comma-separated types to check: email, chat, all (default: email,chat)</li> <li><code>--unreplied-lookback-days &lt;days&gt;</code>: Lookback period for unreplied message detection (default: 30)</li> </ul> <pre><code>xaffinity list export 123 --csv &gt; out.csv\nxaffinity list export \"My Pipeline\" --saved-view \"Board\" --csv &gt; out.csv\nxaffinity list export 123 --field Stage --field Amount --filter '\"Stage\" = \"Active\"' --csv &gt; out.csv\nxaffinity list export 123 --csv --csv-bom &gt; out.csv\n\n# Include interaction dates (last meeting, next meeting, email dates)\nxaffinity list export \"Dealflow\" --expand interactions --json\nxaffinity list export \"Dealflow\" --expand interactions --csv &gt; pipeline.csv\n\n# Check for unreplied incoming messages (email + chat)\nxaffinity list export \"Pipeline\" --check-unreplied --json\nxaffinity list export \"Pipeline\" --check-unreplied --unreplied-lookback-days 60 --csv &gt; unreplied.csv\n\n# Check email-only unreplied messages\nxaffinity list export \"Pipeline\" --check-unreplied --unreplied-types email --json\n</code></pre> <p>See the CSV Export Guide for more details.</p>"},{"location":"cli/commands/#list-entry-commands","title":"List Entry Commands","text":"<p>Shorthand: All <code>list entry</code> commands are also available as top-level <code>entry</code> commands: <pre><code>xaffinity entry get 123 456          # Same as: xaffinity list entry get 123 456\nxaffinity entry field 123 456 ...    # Same as: xaffinity list entry field 123 456 ...\n</code></pre></p>"},{"location":"cli/commands/#xaffinity-list-entry-add-list","title":"<code>xaffinity list entry add &lt;list&gt;</code>","text":"<pre><code>xaffinity list entry add 123 --person-id 26229794\nxaffinity list entry add \"Dealflow\" --company-id 224925494\n</code></pre>"},{"location":"cli/commands/#xaffinity-list-entry-delete-list-entryid","title":"<code>xaffinity list entry delete &lt;list&gt; &lt;entryId&gt;</code>","text":"<pre><code>xaffinity list entry delete 123 98765\n</code></pre>"},{"location":"cli/commands/#xaffinity-list-entry-field-list-entryid","title":"<code>xaffinity list entry field &lt;list&gt; &lt;entryId&gt;</code>","text":"<p>Unified command for getting, setting, appending, and unsetting field values.</p> <pre><code># Set a single field\nxaffinity list entry field \"Portfolio\" 123 --set Status \"Active\"\n\n# Set multiple fields\nxaffinity list entry field \"Portfolio\" 123 --set Status \"Active\" --set Priority \"High\"\n\n# Append to a multi-value field (e.g., tags)\nxaffinity list entry field \"Portfolio\" 123 --append Tags \"Priority\"\n\n# Unset a field (remove all values)\nxaffinity list entry field \"Portfolio\" 123 --unset OldField\n\n# Unset a specific value from a multi-value field\nxaffinity list entry field \"Portfolio\" 123 --unset-value Tags \"OldTag\"\n\n# Batch set via JSON\nxaffinity list entry field \"Portfolio\" 123 --set-json '{\"Status\": \"Active\", \"Priority\": \"High\"}'\n\n# Get specific field values\nxaffinity list entry field \"Portfolio\" 123 --get Status --get Priority\n\n# Swap tags (append new, remove old)\nxaffinity list entry field \"Portfolio\" 123 --append Tags \"NewTag\" --unset-value Tags \"OldTag\"\n</code></pre> <p>Notes: - Field names are resolved case-insensitively - Field IDs (<code>field-123</code>) can be used directly - <code>--set</code> replaces all existing values; use <code>--append</code> to add to multi-value fields - <code>--get</code> is exclusive with write operations - Operation order: <code>--set</code>/<code>--set-json</code> \u2192 <code>--append</code> \u2192 <code>--unset</code>/<code>--unset-value</code></p>"},{"location":"cli/commands/#notes","title":"Notes","text":""},{"location":"cli/commands/#xaffinity-note-ls","title":"<code>xaffinity note ls</code>","text":"<pre><code>xaffinity note ls\nxaffinity note ls --person-id 123 --json\n</code></pre>"},{"location":"cli/commands/#xaffinity-note-get-noteid","title":"<code>xaffinity note get &lt;noteId&gt;</code>","text":"<pre><code>xaffinity note get 9876\n</code></pre>"},{"location":"cli/commands/#xaffinity-note-create","title":"<code>xaffinity note create</code>","text":"<pre><code>xaffinity note create --content \"Met with the team\" --person-id 123\nxaffinity note create --content \"&lt;p&gt;Meeting notes&lt;/p&gt;\" --type html --company-id 456\n</code></pre>"},{"location":"cli/commands/#xaffinity-note-update-noteid","title":"<code>xaffinity note update &lt;noteId&gt;</code>","text":"<pre><code>xaffinity note update 9876 --content \"Updated note content\"\n</code></pre>"},{"location":"cli/commands/#xaffinity-note-delete-noteid","title":"<code>xaffinity note delete &lt;noteId&gt;</code>","text":"<pre><code>xaffinity note delete 9876\n</code></pre>"},{"location":"cli/commands/#reminders","title":"Reminders","text":""},{"location":"cli/commands/#xaffinity-reminder-ls","title":"<code>xaffinity reminder ls</code>","text":"<p>The <code>--due-after</code> and <code>--due-before</code> options accept the same date formats as <code>--due-date</code>: - ISO-8601: <code>2025-01-15</code>, <code>2025-01-15T09:00:00Z</code> - Relative: <code>+7d</code>, <code>+2w</code>, <code>+1m</code>, <code>+1y</code> - Keywords: <code>now</code>, <code>today</code>, <code>tomorrow</code>, <code>yesterday</code></p> <pre><code>xaffinity reminder ls\nxaffinity reminder ls --owner-id 42 --status active --json\nxaffinity reminder ls --due-after today --due-before +7d\n</code></pre>"},{"location":"cli/commands/#xaffinity-reminder-get-reminderid","title":"<code>xaffinity reminder get &lt;reminderId&gt;</code>","text":"<pre><code>xaffinity reminder get 12345\n</code></pre>"},{"location":"cli/commands/#xaffinity-reminder-create","title":"<code>xaffinity reminder create</code>","text":"<p>The <code>--due-date</code> option accepts multiple formats: - ISO-8601: <code>2025-01-15</code>, <code>2025-01-15T09:00:00Z</code> - Relative: <code>+7d</code> (7 days), <code>+2w</code> (2 weeks), <code>+1m</code> (1 month), <code>+1y</code> (1 year) - Keywords: <code>now</code>, <code>today</code>, <code>tomorrow</code>, <code>yesterday</code></p> <pre><code>xaffinity reminder create --owner-id 42 --type one-time --due-date +7d --person-id 123\nxaffinity reminder create --owner-id 42 --type one-time --due-date tomorrow --person-id 123\nxaffinity reminder create --owner-id 42 --type one-time --due-date 2025-01-15T09:00:00Z --person-id 123\nxaffinity reminder create --owner-id 42 --type recurring --reset-type interaction --reminder-days 3 --company-id 456\n</code></pre>"},{"location":"cli/commands/#xaffinity-reminder-update-reminderid","title":"<code>xaffinity reminder update &lt;reminderId&gt;</code>","text":"<pre><code>xaffinity reminder update 12345 --content \"Follow up after demo\"\nxaffinity reminder update 12345 --completed\n</code></pre>"},{"location":"cli/commands/#xaffinity-reminder-delete-reminderid","title":"<code>xaffinity reminder delete &lt;reminderId&gt;</code>","text":"<pre><code>xaffinity reminder delete 12345\n</code></pre>"},{"location":"cli/commands/#interactions","title":"Interactions","text":""},{"location":"cli/commands/#xaffinity-interaction-ls","title":"<code>xaffinity interaction ls</code>","text":"<p>List interactions for an entity. Requires <code>--type</code>, one entity selector (<code>--person-id</code>, <code>--company-id</code>, or <code>--opportunity-id</code>), and a date range (<code>--days</code> or <code>--after</code>). Auto-chunks date ranges &gt; 1 year into API-compatible segments.</p> <pre><code>xaffinity interaction ls --type email --person-id 123 --days 30\nxaffinity interaction ls --type meeting --person-id 123 --after 2025-01-01 --before 2025-02-01\nxaffinity interaction ls --type call --company-id 456 --days 365 --json\n</code></pre>"},{"location":"cli/commands/#xaffinity-interaction-get-interactionid","title":"<code>xaffinity interaction get &lt;interactionId&gt;</code>","text":"<pre><code>xaffinity interaction get 2468 --type meeting\n</code></pre>"},{"location":"cli/commands/#xaffinity-interaction-create","title":"<code>xaffinity interaction create</code>","text":"<pre><code>xaffinity interaction create --type meeting --person-id 123 --content \"Met to discuss roadmap\" --date 2025-01-10T14:00:00Z\nxaffinity interaction create --type email --person-id 123 --content \"Intro email\" --date 2025-01-05T09:15:00Z --direction outgoing\n</code></pre>"},{"location":"cli/commands/#xaffinity-interaction-update-interactionid","title":"<code>xaffinity interaction update &lt;interactionId&gt;</code>","text":"<pre><code>xaffinity interaction update 2468 --type meeting --content \"Updated meeting notes\"\n</code></pre>"},{"location":"cli/commands/#xaffinity-interaction-delete-interactionid","title":"<code>xaffinity interaction delete &lt;interactionId&gt;</code>","text":"<pre><code>xaffinity interaction delete 2468 --type meeting\n</code></pre>"},{"location":"cli/commands/#fields","title":"Fields","text":""},{"location":"cli/commands/#xaffinity-field-ls","title":"<code>xaffinity field ls</code>","text":"<pre><code>xaffinity field ls --entity-type company\nxaffinity field ls --list-id 123 --json\n</code></pre>"},{"location":"cli/commands/#xaffinity-field-create","title":"<code>xaffinity field create</code>","text":"<pre><code>xaffinity field create --name \"Stage\" --entity-type opportunity --value-type dropdown --list-specific\n</code></pre>"},{"location":"cli/commands/#xaffinity-field-delete-fieldid","title":"<code>xaffinity field delete &lt;fieldId&gt;</code>","text":"<pre><code>xaffinity field delete field-123\n</code></pre>"},{"location":"cli/commands/#xaffinity-field-history","title":"<code>xaffinity field history</code>","text":"<p>Show field value change history for a specific field on an entity.</p> <pre><code>xaffinity field history FIELD_ID [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>FIELD_ID</code> (required): Field ID (e.g., <code>field-123</code>). Use <code>field ls --list-id LIST</code> to find IDs.</li> </ul> <p>Options:</p> <ul> <li><code>--person-id &lt;id&gt;</code>: Filter by person</li> <li><code>--company-id &lt;id&gt;</code>: Filter by company</li> <li><code>--opportunity-id &lt;id&gt;</code>: Filter by opportunity</li> <li><code>--list-entry-id &lt;id&gt;</code>: Filter by list entry</li> <li><code>--action-type &lt;type&gt;</code>: Filter by action (<code>create</code>, <code>update</code>, <code>delete</code>)</li> <li><code>--max-results &lt;n&gt;</code>: Limit number of results</li> </ul> <p>Exactly one entity selector is required.</p> <pre><code>xaffinity field history field-123 --person-id 456\nxaffinity field history field-123 --company-id 789 --action-type update\nxaffinity --json field history field-123 --list-entry-id 101 --max-results 20\n</code></pre>"},{"location":"cli/commands/#relationship-strengths","title":"Relationship Strengths","text":""},{"location":"cli/commands/#xaffinity-relationship-strength-get","title":"<code>xaffinity relationship-strength get</code>","text":"<pre><code>xaffinity relationship-strength get --external-id 26229794\nxaffinity relationship-strength get --external-id 26229794 --internal-id 42\n</code></pre>"},{"location":"cli/commands/#tasks","title":"Tasks","text":""},{"location":"cli/commands/#xaffinity-task-get-taskurl","title":"<code>xaffinity task get &lt;taskUrl&gt;</code>","text":"<pre><code>xaffinity task get https://api.affinity.co/tasks/person-merges/123\n</code></pre>"},{"location":"cli/commands/#xaffinity-task-wait-taskurl","title":"<code>xaffinity task wait &lt;taskUrl&gt;</code>","text":"<pre><code>xaffinity task wait https://api.affinity.co/tasks/person-merges/123 --timeout 120\n</code></pre>"},{"location":"cli/scripting/","title":"Scripting","text":""},{"location":"cli/scripting/#session-caching-for-pipelines","title":"Session caching for pipelines","text":"<p>When running multiple CLI commands in a pipeline, enable session caching to avoid redundant API calls:</p> <pre><code>#!/bin/bash\nexport AFFINITY_SESSION_CACHE=$(xaffinity session start) || exit 1\ntrap 'xaffinity session end; unset AFFINITY_SESSION_CACHE' EXIT\n\n# Commands share cached metadata (field definitions, list resolution)\nxaffinity list export \"My List\" | xaffinity person get\n</code></pre> <p>See Pipeline Optimization for details.</p>"},{"location":"cli/scripting/#json-output","title":"JSON output","text":"<p>Use <code>--json</code> (or <code>--output json</code>) for machine-readable output:</p> <pre><code>xaffinity whoami --json | jq\n</code></pre>"},{"location":"cli/scripting/#response-envelope","title":"Response envelope","text":"<p>All JSON responses use a standard envelope structure:</p> <pre><code>{\n  \"ok\": true,\n  \"command\": {\"name\": \"person get\", \"inputs\": {\"personSelector\": \"123\"}, \"modifiers\": {}, \"resolved\": null},\n  \"data\": {\"person\": {\"id\": 123, \"firstName\": \"Alice\", ...}},\n  \"meta\": {\"rateLimit\": {...}, \"pagination\": {...}},\n  \"error\": null\n}\n</code></pre> Field Description <code>ok</code> <code>true</code> if command succeeded, <code>false</code> on error <code>command</code> Object with <code>name</code>, <code>inputs</code>, <code>modifiers</code>, and <code>resolved</code> fields <code>data</code> The entity or entities returned (keyed by type) <code>meta</code> Rate limit info, pagination cursors, timing <code>error</code> Error details when <code>ok</code> is <code>false</code>"},{"location":"cli/scripting/#extracting-entity-data","title":"Extracting entity data","text":"<p>Entity data is nested under <code>.data.&lt;entityType&gt;</code>:</p> <pre><code># Get a person's name\nxaffinity person get 123 --json | jq '.data.person.firstName'\n\n# Get company ID after creation\nxaffinity company create --name \"Acme\" --json | jq '.data.company.id'\n\n# List all person IDs\nxaffinity person ls --json | jq '.data.persons[].id'\n</code></pre>"},{"location":"cli/scripting/#error-handling-in-scripts","title":"Error handling in scripts","text":"<p>Check <code>ok</code> before processing data:</p> <pre><code>result=$(xaffinity person get 123 --json)\nif echo \"$result\" | jq -e '.ok' &gt; /dev/null; then\n    echo \"$result\" | jq '.data.person'\nelse\n    echo \"Error: $(echo \"$result\" | jq -r '.error.message')\" &gt;&amp;2\n    exit 1\nfi\n</code></pre> <p>Or use exit codes (non-zero on error):</p> <pre><code>if xaffinity person get 123 --json &gt; /tmp/result.json 2&gt;&amp;1; then\n    jq '.data.person' /tmp/result.json\nelse\n    echo \"Command failed\" &gt;&amp;2\nfi\n</code></pre>"},{"location":"cli/scripting/#common-patterns","title":"Common patterns","text":"<p>Extract and assign to variable:</p> <pre><code>PERSON_ID=$(xaffinity person create --first-name \"Test\" --last-name \"User\" --json | jq -r '.data.person.id')\n</code></pre> <p>Process list results:</p> <pre><code>xaffinity person ls --all --json | jq -r '.data.persons[] | \"\\(.id)\\t\\(.firstName) \\(.lastName)\"'\n</code></pre> <p>Create shell alias for frequent access patterns:</p> <pre><code># Add to ~/.bashrc or ~/.zshrc\nalias xaff-person='xaffinity person get --json | jq .data.person'\n\n# Usage: xaff-person 123\n</code></pre>"},{"location":"cli/scripting/#timezone-safe-datetime-handling","title":"Timezone-safe datetime handling","text":"<p>Date/time flags (<code>--after</code>, <code>--before</code>, etc.) interpret naive strings as local time. For reproducible scripts across timezones, always use explicit UTC:</p> <pre><code># Use Z suffix for explicit UTC\nxaffinity interaction ls --type meeting --person-id 123 --after 2024-01-01T00:00:00Z --json\n\n# Or use explicit timezone offset\nxaffinity interaction ls --type meeting --person-id 123 --after 2024-01-01T00:00:00-05:00 --json\n\n# Or use --days for relative date ranges\nxaffinity interaction ls --type meeting --person-id 123 --days 30 --json\n</code></pre> <p>JSON output always returns datetimes in UTC (with <code>+00:00</code> suffix). See the Datetime Handling Guide for full details on SDK vs CLI behavior.</p> <p>Note: <code>interaction ls</code> auto-chunks date ranges &gt; 1 year into API-compatible segments. For multi-year queries, dates are split transparently.</p>"},{"location":"cli/scripting/#pagination-and-resume","title":"Pagination and resume","text":"<p>Some commands include resume tokens in <code>meta.pagination</code>.</p> <ul> <li><code>meta.pagination</code> is keyed by section name.</li> <li>Resume cursor: <code>meta.pagination.&lt;section&gt;.nextCursor</code> (resume with <code>--cursor &lt;cursor&gt;</code>)</li> <li>Treat cursors as opaque strings (some may look like URLs); don't parse them.</li> </ul> <p>Note: <code>interaction ls</code> does not use pagination cursors. Instead, it auto-fetches all results within the specified date range, chunking as needed for ranges &gt; 1 year.</p> <p>Example (person list with query):</p> <pre><code>xaffinity person ls --query \"alice\" --json | jq -r '.meta.pagination.persons.nextCursor'\nxaffinity person ls --query \"alice\" --cursor \"$CURSOR\" --json\n</code></pre> <p>Example (list inventory):</p> <pre><code>xaffinity list ls --json | jq -r '.meta.pagination.lists.nextCursor'\nxaffinity list ls --cursor \"$CURSOR\" --json\n</code></pre> <p>Note: if you use <code>--max-results</code> and it truncates results mid-page, the CLI may omit pagination to avoid producing an unsafe resume token.</p>"},{"location":"cli/scripting/#csv-output","title":"CSV Output","text":"<p>The <code>--csv</code> flag outputs CSV to stdout, making it composable with UNIX tools:</p> <pre><code># Save to file\nxaffinity list export 123 --csv &gt; out.csv\n\n# Pipe to other tools\nxaffinity person ls --all --csv | wc -l\nxaffinity list export 123 --csv | head -10\n</code></pre> <p>Note: <code>--csv</code> and <code>--json</code> are mutually exclusive. Use one or the other.</p>"},{"location":"cli/scripting/#machine-readable-help","title":"Machine-Readable Help","text":"<p>Use <code>--help --json</code> to get machine-readable command documentation. This is useful for:</p> <ul> <li>Building automation tools that discover CLI capabilities</li> <li>Generating command registries for AI integrations (like MCP servers)</li> <li>Validating command arguments programmatically</li> </ul> <pre><code>xaffinity --help --json\n</code></pre>"},{"location":"cli/scripting/#output-format","title":"Output Format","text":"<pre><code>{\n  \"commands\": [\n    {\n      \"name\": \"person create\",\n      \"description\": \"Create a person.\",\n      \"category\": \"write\",\n      \"destructive\": false,\n      \"parameters\": {\n        \"--first-name\": {\"type\": \"string\", \"required\": false},\n        \"--last-name\": {\"type\": \"string\", \"required\": false},\n        \"--email\": {\"type\": \"string\", \"required\": false, \"multiple\": true}\n      },\n      \"positionals\": []\n    },\n    {\n      \"name\": \"person delete\",\n      \"description\": \"Delete a person.\",\n      \"category\": \"write\",\n      \"destructive\": true,\n      \"parameters\": {\n        \"--yes\": {\"type\": \"flag\", \"required\": false}\n      },\n      \"positionals\": [\n        {\"name\": \"PERSON_ID\", \"type\": \"int\", \"required\": true}\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"cli/scripting/#command-metadata","title":"Command Metadata","text":"Field Description <code>name</code> Full command path (e.g., <code>\"person create\"</code>, <code>\"list entry add\"</code>) <code>description</code> Human-readable description <code>category</code> <code>\"read\"</code>, <code>\"write\"</code>, or <code>\"local\"</code> (no-network) <code>destructive</code> <code>true</code> for delete commands <code>parameters</code> Named options with type info <code>positionals</code> Positional arguments with type info"},{"location":"cli/scripting/#parameter-types","title":"Parameter Types","text":"Type Description <code>string</code> Text value <code>int</code> Integer value <code>flag</code> Boolean flag (no value) <code>choice</code> One of allowed values (see <code>choices</code> array) <p>Parameters with <code>\"multiple\": true</code> can be specified multiple times.</p>"},{"location":"guides/api-versions-and-routing/","title":"API versions &amp; SDK routing","text":"Quick glossary <ul> <li>V1 API: legacy endpoints at <code>https://api.affinity.co</code></li> <li>V2 API: newer endpoints at <code>https://api.affinity.co/v2</code></li> <li>V2 API version: dated versions like <code>2024-01-01</code> within V2 (configured in Affinity)</li> <li>Default API Version: your Affinity setting that selects the V2 version</li> <li>Beta endpoints: newer V2 endpoints that require opt-in</li> </ul> <p>The SDK prefers V2 endpoints where available and falls back to V1 for operations not yet supported in V2.</p>"},{"location":"guides/api-versions-and-routing/#what-this-means-in-practice","title":"What this means in practice","text":"<ul> <li>Reads (list/get/search) are typically V2.</li> <li>Writes (create/update/delete) are often V1 today.</li> </ul> <p>Example: companies</p> <ul> <li><code>client.companies.get(...)</code> uses V2</li> <li><code>client.companies.create(...)</code> uses V1</li> </ul>"},{"location":"guides/api-versions-and-routing/#eventual-consistency-caveat","title":"Eventual consistency caveat","text":"<p>Because writes go to V1 and reads come from V2, there can be a brief delay (typically 100-500ms) before newly created entities appear in V2. A <code>get()</code> immediately after <code>create()</code> may return 404. See V1\u2192V2 eventual consistency for solutions.</p>"},{"location":"guides/api-versions-and-routing/#beta-endpoints","title":"Beta endpoints","text":"<p>Some V2 endpoints are gated behind <code>enable_beta_endpoints=True</code>. If you call a beta endpoint without opt-in, the SDK raises <code>BetaEndpointDisabledError</code>.</p>"},{"location":"guides/api-versions-and-routing/#version-compatibility-errors","title":"Version compatibility errors","text":"<p>If Affinity changes V2 response shapes (or your API key is pinned to an unexpected V2 version), parsing can fail with <code>VersionCompatibilityError</code>.</p> <p>Suggested steps:</p> <ol> <li>Check your API key\u2019s \u201cDefault API Version\u201d in the Affinity dashboard.</li> <li>Set <code>expected_v2_version=...</code> if you want that mismatch called out in errors.</li> </ol> <p>References:</p> <ul> <li>V1 docs: https://api-docs.affinity.co/</li> <li>V2 portal: https://developer.affinity.co/</li> <li>V2 versioning: https://developer.affinity.co/#section/Getting-Started/Versioning</li> <li>Glossary: ../glossary.md</li> </ul>"},{"location":"guides/api-versions-and-routing/#next-steps","title":"Next steps","text":"<ul> <li>Configuration</li> <li>Sync vs async</li> <li>Errors &amp; retries</li> </ul>"},{"location":"guides/authentication/","title":"Authentication","text":"<p>The SDK authenticates using an Affinity API key.</p> <pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    me = client.whoami()\n    print(me.user.email)\n</code></pre>"},{"location":"guides/authentication/#environment-variables","title":"Environment variables","text":"<p>If you prefer reading from the environment:</p> <pre><code>from affinity import Affinity\n\n# Reads AFFINITY_API_KEY by default\nclient = Affinity.from_env()\n\n# Use a custom environment variable name\nclient = Affinity.from_env(env_var=\"MY_AFFINITY_KEY\")\n</code></pre> <p>For local development, you can load a <code>.env</code> file (requires <code>python-dotenv</code>):</p> <pre><code>from affinity import Affinity\n\n# Load .env from current directory\nclient = Affinity.from_env(load_dotenv=True)\n\n# Load from a specific path\nclient = Affinity.from_env(load_dotenv=True, dotenv_path=\".env.local\")\n</code></pre> <p>For defensive \"no writes\" usage (scripts, audits), disable writes via policy:</p> <pre><code>from affinity import Affinity\nfrom affinity.policies import Policies, WritePolicy\n\nclient = Affinity.from_env(policies=Policies(write=WritePolicy.DENY))\n</code></pre>"},{"location":"guides/authentication/#cli-authentication","title":"CLI Authentication","text":"<p>For the CLI, use the built-in setup commands:</p> <pre><code># Check if a key is configured\nxaffinity config check-key\n\n# Set up a new key securely (hidden input)\nxaffinity config setup-key\n</code></pre> <p>See CLI Authentication for details.</p>"},{"location":"guides/authentication/#next-steps","title":"Next steps","text":"<ul> <li>Getting started</li> <li>Configuration</li> <li>Examples</li> <li>Errors &amp; retries</li> <li>API reference</li> </ul>"},{"location":"guides/claude-code-plugins/","title":"Claude Code Plugins &amp; Skills","text":"<p>Two Claude Code plugins provide skills that teach Claude best practices for the Affinity SDK and CLI:</p> Plugin Best For Key Feature sdk Python developers Type-safe SDK patterns cli CLI power users <code>/affinity-help</code> quick reference <p>All plugins are installed from the <code>xaffinity</code> marketplace.</p> <p>What are skills?</p> <p>Skills are knowledge packages that Claude loads when relevant. They teach Claude domain-specific patterns, best practices, and gotchas\u2014so you don't have to explain them in every prompt.</p> <p>Looking for MCP?</p> <p>For agentic workflows (meeting prep, pipeline management, warm intros), see the MCP Server documentation. The MCP server works with any MCP client, not just Claude.</p>"},{"location":"guides/claude-code-plugins/#installation","title":"Installation","text":"<p>Add the marketplace (one-time):</p> <pre><code>/plugin marketplace add yaniv-golan/affinity-sdk\n</code></pre> <p>Install the plugin(s) you need:</p> <pre><code># For Python SDK development\n/plugin install sdk@xaffinity\n\n# For CLI usage + /affinity-help command\n/plugin install cli@xaffinity\n</code></pre> <p>You can install both plugins. They complement each other.</p>"},{"location":"guides/claude-code-plugins/#sdk-plugin-affinity-python-sdk-skill","title":"SDK Plugin (affinity-python-sdk skill)","text":"<p>Teaches Claude the correct patterns for writing Python scripts with the Affinity SDK.</p>"},{"location":"guides/claude-code-plugins/#what-the-skill-teaches-claude","title":"What the skill teaches Claude","text":"<p>Use typed IDs (not raw integers)</p> <pre><code>from affinity.types import PersonId, CompanyId\n\nclient.persons.get(PersonId(123))     # Correct\nclient.persons.get(123)               # Wrong - type error\n</code></pre> <p>Use context managers</p> <pre><code>with Affinity.from_env() as client:   # Correct\n    ...\n\nclient = Affinity.from_env()          # May leak resources\n</code></pre> <p>Use read-only mode by default</p> <pre><code>from affinity.policies import Policies, WritePolicy\n\n# Default: read-only (prevents accidental data modification)\nwith Affinity.from_env(policies=Policies(write=WritePolicy.DENY)) as client:\n    ...\n</code></pre> <p>Filters only work on custom fields</p> <pre><code>from affinity import F\n\n# Works - custom fields\nclient.persons.list(filter=F.field(\"Department\").equals(\"Sales\"))\n\n# Won't work - built-in properties like firstName, lastName, domain, etc.\n</code></pre>"},{"location":"guides/claude-code-plugins/#example-prompts","title":"Example prompts","text":"<ul> <li>\"Write a script to export all companies to CSV\"</li> <li>\"How do I filter persons by a custom field?\"</li> <li>\"Get all entries from my Deal Pipeline list\"</li> </ul>"},{"location":"guides/claude-code-plugins/#cli-plugin-xaffinity-cli-usage-skill","title":"CLI Plugin (xaffinity-cli-usage skill)","text":"<p>Teaches Claude the correct patterns for running <code>xaffinity</code> CLI commands.</p>"},{"location":"guides/claude-code-plugins/#affinity-help-command","title":"/affinity-help command","text":"<p>Run <code>/affinity-help</code> in Claude Code for a quick reference of CLI patterns.</p>"},{"location":"guides/claude-code-plugins/#what-the-skill-teaches-claude_1","title":"What the skill teaches Claude","text":"<ul> <li>Always use <code>--readonly</code> by default</li> <li>Use <code>--json</code> for structured, parseable output</li> <li>Run <code>xaffinity config check-key --json</code> to verify API key configuration</li> <li>Use <code>--all</code> with caution (can be slow for large datasets)</li> <li>Filters only work on custom fields</li> </ul>"},{"location":"guides/claude-code-plugins/#example-prompts_1","title":"Example prompts","text":"<ul> <li>\"Export all my contacts to CSV\"</li> <li>\"Find the company with domain acme.com\"</li> <li>\"Show me all entries in my Deal Pipeline\"</li> </ul>"},{"location":"guides/claude-code-plugins/#mcp-server","title":"MCP Server","text":"<p>For agentic workflows like meeting preparation, interaction logging, and pipeline management, use the MCP server.</p> <p>The MCP server is protocol-agnostic and works with any MCP client (Claude Desktop, Cursor, Windsurf, VS Code + Copilot, ChatGPT Desktop, and others).</p> <p>Install via Claude Code:</p> <pre><code>/plugin install mcp@xaffinity\n</code></pre> <p>Full documentation: MCP Server</p>"},{"location":"guides/claude-code-plugins/#managing-plugins","title":"Managing Plugins","text":""},{"location":"guides/claude-code-plugins/#updating","title":"Updating","text":"<pre><code>/plugin marketplace update\n/plugin update sdk@xaffinity\n/plugin update cli@xaffinity\n</code></pre>"},{"location":"guides/claude-code-plugins/#uninstalling","title":"Uninstalling","text":"<pre><code>/plugin uninstall sdk@xaffinity\n/plugin uninstall cli@xaffinity\n</code></pre>"},{"location":"guides/configuration/","title":"Configuration","text":"<p>This guide documents the knobs exposed on <code>Affinity</code> / <code>AsyncAffinity</code>.</p>"},{"location":"guides/configuration/#load-from-environment","title":"Load from environment","text":"<pre><code>from affinity import Affinity\n\nclient = Affinity.from_env()\n</code></pre> <p>By default, <code>from_env()</code> reads the <code>AFFINITY_API_KEY</code> environment variable. You can customize this:</p> <pre><code>from affinity import Affinity\n\n# Use a different environment variable\nclient = Affinity.from_env(env_var=\"MY_AFFINITY_KEY\")\n</code></pre>"},{"location":"guides/configuration/#using-env-files","title":"Using .env files","text":"<p>To load a local <code>.env</code> file, install the optional extra and set <code>load_dotenv=True</code>:</p> <pre><code>pip install \"affinity-sdk[dotenv]\"\n</code></pre> <pre><code>from affinity import Affinity\n\n# Load from .env in current directory\nclient = Affinity.from_env(load_dotenv=True)\n\n# Load from a specific .env file\nclient = Affinity.from_env(load_dotenv=True, dotenv_path=\"/path/to/.env.local\")\n\n# Override existing environment variables with .env values\nclient = Affinity.from_env(load_dotenv=True, dotenv_override=True)\n</code></pre>"},{"location":"guides/configuration/#timeouts","title":"Timeouts","text":"<pre><code>from affinity import Affinity\n\nclient = Affinity(api_key=\"your-api-key\", timeout=60.0)\n</code></pre> <p>For file downloads, you can override timeouts per call, and (for streaming downloads) set a total time budget:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import FileId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    for chunk in client.files.download_stream(FileId(123), timeout=60.0, deadline_seconds=300):\n        ...\n</code></pre>"},{"location":"guides/configuration/#streaming-download-parameters","title":"Streaming download parameters","text":"Parameter Description <code>timeout</code> Per-request timeout in seconds (default: client timeout) <code>deadline_seconds</code> Total time budget for the entire download including retries <p>If <code>deadline_seconds</code> is exceeded, the SDK raises <code>TimeoutError</code>.</p>"},{"location":"guides/configuration/#preserving-file-metadata","title":"Preserving file metadata","text":"<p>To preserve server-provided file metadata (like filename and size), use <code>download_stream_with_info(...)</code>:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import FileId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    downloaded = client.files.download_stream_with_info(FileId(123), timeout=60.0, deadline_seconds=300)\n    filename = downloaded.filename or client.files.get(FileId(123)).name\n    for chunk in downloaded.iter_bytes:\n        ...\n</code></pre> <p>The <code>DownloadedFile</code> object provides:</p> <ul> <li><code>filename</code>: Original filename from Content-Disposition header (may be <code>None</code>)</li> <li><code>content_type</code>: MIME type from Content-Type header</li> <li><code>size</code>: File size in bytes (may be <code>None</code> if server doesn't provide it)</li> <li><code>iter_bytes</code>: Iterator yielding file content chunks</li> </ul>"},{"location":"guides/configuration/#error-handling-for-downloads","title":"Error handling for downloads","text":"<pre><code>from affinity import Affinity\nfrom affinity.types import FileId\nfrom affinity.exceptions import AffinityError\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    try:\n        with open(\"output.pdf\", \"wb\") as f:\n            for chunk in client.files.download_stream(FileId(123), deadline_seconds=120):\n                f.write(chunk)\n    except TimeoutError:\n        print(\"Download timed out - file may be too large or connection too slow\")\n    except AffinityError as e:\n        print(f\"Download failed: {e}\")\n</code></pre> <p>No resume support</p> <p>The SDK does not currently support resuming partial downloads. If a download fails, you must restart from the beginning.</p>"},{"location":"guides/configuration/#retries","title":"Retries","text":"<ul> <li>Retries apply to safe/idempotent methods (by default <code>GET</code>/<code>HEAD</code>).</li> <li>Tune with <code>max_retries</code>.</li> </ul> <pre><code>from affinity import Affinity\n\nclient = Affinity(api_key=\"your-api-key\", max_retries=5)\n</code></pre>"},{"location":"guides/configuration/#download-redirects-files","title":"Download redirects (files)","text":"<p>Affinity file downloads may redirect to externally-hosted signed URLs. By default, the SDK refuses <code>http://</code> redirects.</p> <p>If you must allow insecure redirects (not recommended), opt in explicitly:</p> <pre><code>from affinity import Affinity\n\nclient = Affinity(api_key=\"your-api-key\", allow_insecure_download_redirects=True)\n</code></pre>"},{"location":"guides/configuration/#caching","title":"Caching","text":"<p>Caching is optional and currently targets metadata-style responses (e.g., field metadata). Default TTL is 300 seconds (5 minutes).</p> <pre><code>from affinity import Affinity\n\n# Enable with default 5-minute TTL\nclient = Affinity(api_key=\"your-api-key\", enable_cache=True)\n\n# Custom TTL (in seconds)\nclient = Affinity(api_key=\"your-api-key\", enable_cache=True, cache_ttl=600.0)\n</code></pre>"},{"location":"guides/configuration/#logging-and-hooks","title":"Logging and hooks","text":"<pre><code>from affinity import Affinity\nfrom affinity.hooks import HookEvent\n\ndef on_event(event: HookEvent) -&gt; None:\n    print(event.type)\n\nclient = Affinity(\n    api_key=\"your-api-key\",\n    log_requests=True,\n    on_event=on_event,\n    hook_error_policy=\"swallow\",  # or \"raise\"\n)\n</code></pre> <p>Notes:</p> <ul> <li>For the synchronous client (<code>Affinity</code>), <code>on_event</code> must be a synchronous function. If it returns an awaitable, the SDK raises <code>ConfigurationError</code>.</li> <li>For the async client (<code>AsyncAffinity</code>), <code>on_event</code> can be sync or async.</li> </ul> <p>Affinity downloads may redirect to externally-hosted signed URLs; external URLs are redacted in events by default. If you want to change that behavior, configure <code>Policies(external_hooks=...)</code>:</p> <pre><code>from affinity import Affinity, ExternalHookPolicy\nfrom affinity.policies import Policies\n\nclient = Affinity(\n    api_key=\"your-api-key\",\n    on_event=lambda e: print(e.type),\n    policies=Policies(external_hooks=ExternalHookPolicy.REDACT),  # or SUPPRESS / EMIT_UNSAFE\n)\n</code></pre>"},{"location":"guides/configuration/#disable-writes-policy","title":"Disable writes (policy)","text":"<p>To guarantee the SDK does not perform write operations (POST/PUT/PATCH/DELETE, including uploads), disable writes via policy:</p> <pre><code>from affinity import Affinity\nfrom affinity.policies import Policies, WritePolicy\n\nclient = Affinity(api_key=\"your-api-key\", policies=Policies(write=WritePolicy.DENY))\n</code></pre>"},{"location":"guides/configuration/#http-transport-injection-advanced","title":"HTTP transport injection (advanced)","text":"<p>For testing/mocking without real network calls, inject an <code>httpx</code> transport:</p> <pre><code>import httpx\nfrom affinity import Affinity\n\ndef handler(request: httpx.Request) -&gt; httpx.Response:\n    if request.method == \"GET\" and request.url.path.endswith(\"/lists\"):\n        return httpx.Response(200, json={\"data\": [], \"pagination\": {}}, request=request)\n    return httpx.Response(404, json={}, request=request)\n\nclient = Affinity(api_key=\"your-api-key\", transport=httpx.MockTransport(handler))\n</code></pre>"},{"location":"guides/configuration/#v1v2-urls-and-auth-mode","title":"V1/V2 URLs and auth mode","text":"<pre><code>from affinity import Affinity\n\nclient = Affinity(\n    api_key=\"your-api-key\",\n    v1_base_url=\"https://api.affinity.co\",\n    v2_base_url=\"https://api.affinity.co/v2\",\n    v1_auth_mode=\"bearer\",  # or \"basic\"\n)\n</code></pre>"},{"location":"guides/configuration/#beta-endpoints-and-version-diagnostics","title":"Beta endpoints and version diagnostics","text":"<p>If you opt into beta endpoints or want stricter diagnostics around v2 response shapes:</p> <pre><code>from affinity import Affinity\n\nclient = Affinity(\n    api_key=\"your-api-key\",\n    enable_beta_endpoints=True,\n    expected_v2_version=\"2024-01-01\",\n)\n</code></pre> <p>See also:</p> <ul> <li>API versions &amp; routing</li> <li>Errors &amp; retries</li> </ul>"},{"location":"guides/configuration/#next-steps","title":"Next steps","text":"<ul> <li>Getting started</li> <li>Debugging hooks</li> <li>Rate limits</li> <li>API reference</li> </ul>"},{"location":"guides/csv-export/","title":"CSV Export Guide","text":"<p>This guide shows you how to export data from the Affinity CLI to CSV format for use in spreadsheets, data analysis tools, or other applications.</p>"},{"location":"guides/csv-export/#quick-start","title":"Quick Start","text":"<p>Export data to CSV using the <code>--csv</code> flag with shell redirection:</p> <pre><code># Export all people to CSV\nxaffinity person ls --all --csv &gt; people.csv\n\n# Export all companies to CSV\nxaffinity company ls --all --csv &gt; companies.csv\n\n# Export all opportunities to CSV\nxaffinity opportunity ls --all --csv &gt; opportunities.csv\n\n# Export list entries with custom fields\nxaffinity list export 12345 --all --csv &gt; entries.csv\n</code></pre>"},{"location":"guides/csv-export/#excel-compatibility","title":"Excel Compatibility","text":"<p>If you're opening CSV files in Microsoft Excel, use the <code>--csv-bom</code> flag to ensure proper character encoding:</p> <pre><code>xaffinity person ls --all --csv --csv-bom &gt; people.csv\n</code></pre> <p>This adds a UTF-8 Byte Order Mark (BOM) to the file, which helps Excel correctly display special characters, accents, and non-English text.</p>"},{"location":"guides/csv-export/#commands-with-built-in-csv-support","title":"Commands with Built-in CSV Support","text":"Command CSV Flag Example <code>person ls</code> <code>--csv</code> <code>xaffinity person ls --all --csv &gt; people.csv</code> <code>company ls</code> <code>--csv</code> <code>xaffinity company ls --all --csv &gt; companies.csv</code> <code>opportunity ls</code> <code>--csv</code> <code>xaffinity opportunity ls --all --csv &gt; opps.csv</code> <code>list export</code> <code>--csv</code> <code>xaffinity list export 12345 --all --csv &gt; entries.csv</code> <p>Note: The <code>--csv</code> flag outputs CSV to stdout. Use shell redirection (<code>&gt;</code>) to save to a file, or pipe (<code>|</code>) to other tools.</p>"},{"location":"guides/csv-export/#csv-column-reference","title":"CSV Column Reference","text":""},{"location":"guides/csv-export/#person-ls","title":"person ls","text":"<p>The <code>person ls</code> command exports these columns:</p> <ul> <li>id - Person ID</li> <li>name - Full name (first + last)</li> <li>primaryEmail - Primary email address</li> <li>emails - All email addresses (semicolon-separated)</li> </ul> <p>Example output: <pre><code>id,name,primaryEmail,emails\n123,Alice Smith,alice@example.com,alice@example.com\n456,Bob Jones,bob@company.com,bob@company.com; bjones@company.com\n</code></pre></p>"},{"location":"guides/csv-export/#company-ls","title":"company ls","text":"<p>The <code>company ls</code> command exports these columns:</p> <ul> <li>id - Company ID</li> <li>name - Company name</li> <li>domain - Primary domain</li> <li>domains - All domains (semicolon-separated)</li> </ul> <p>Example output: <pre><code>id,name,domain,domains\n100,Acme Corp,acme.com,acme.com\n101,Beta Inc,beta.com,beta.com; beta.co\n</code></pre></p>"},{"location":"guides/csv-export/#opportunity-ls","title":"opportunity ls","text":"<p>The <code>opportunity ls</code> command exports these columns:</p> <ul> <li>id - Opportunity ID</li> <li>name - Opportunity name</li> <li>listId - List ID the opportunity belongs to</li> </ul> <p>Example output: <pre><code>id,name,listId\n10,Series A,41780\n11,Seed Round,41780\n</code></pre></p>"},{"location":"guides/csv-export/#list-export","title":"list export","text":"<p>The <code>list export</code> command is the most powerful CSV export option. It includes:</p> <ul> <li>Entity ID and name</li> <li>All custom field values</li> <li>List entry metadata</li> </ul> <p>See <code>xaffinity list export --help</code> for details.</p>"},{"location":"guides/csv-export/#advanced-using-jq-for-custom-csv-exports","title":"Advanced: Using jq for Custom CSV Exports","text":"<p>For commands without built-in <code>--csv</code> support, you can use <code>jq</code> to convert JSON output to CSV format.</p>"},{"location":"guides/csv-export/#basic-pattern","title":"Basic Pattern","text":"<pre><code>xaffinity &lt;command&gt; --json --all | \\\n  jq -r '.data.&lt;entity&gt;[] | [.field1, .field2, .field3] | @csv' &gt; output.csv\n</code></pre> <p>The <code>-r</code> flag is crucial - it outputs raw strings instead of JSON-quoted values.</p>"},{"location":"guides/csv-export/#examples","title":"Examples","text":"<p>Export list entries with field values: <pre><code>xaffinity list export \"My List\" --json | \\\n  jq -r '.data.entries[] | [.id, .fields[\"Status\"], .fields[\"Owner\"]] | @csv'\n</code></pre></p> <p>Export notes: <pre><code>xaffinity note ls --person-id 123 --json --all | \\\n  jq -r '.data[] | [.id, .content, .createdAt] | @csv'\n</code></pre></p> <p>Export interactions: <pre><code># Use --days for relative date range (auto-chunks if &gt; 1 year)\nxaffinity interaction ls --type meeting --person-id 123 --days 365 --json | \\\n  jq -r '.data[] | [.id, .date, .type] | @csv'\n\n# Or use built-in --csv flag\nxaffinity interaction ls --type meeting --person-id 123 --days 365 --csv\n</code></pre></p> <p>Add headers manually: <pre><code>xaffinity person ls --json --all | \\\n  jq -r '[\"ID\",\"Name\",\"Email\"],\n         (.data.persons[] | [.id, .name, .primaryEmail]) | @csv'\n</code></pre></p> <p>Handle arrays (join with semicolons): <pre><code>xaffinity person ls --json --all | \\\n  jq -r '.data.persons[] | [.id, .name, (.emails | join(\"; \"))] | @csv'\n</code></pre></p> <p>Extract from nested structures: <pre><code>xaffinity person get 123 --json | \\\n  jq -r '.data.person.fields[] | [.fieldId, .value, .listEntryId] | @csv'\n</code></pre></p>"},{"location":"guides/csv-export/#json-data-structure-reference","title":"JSON Data Structure Reference","text":"<p>Most CLI commands return data in this structure:</p> <pre><code>{\n  \"data\": {\n    \"&lt;entity-plural&gt;\": [ ... ]\n  }\n}\n</code></pre> <p>Some commands (<code>note ls</code>, <code>interaction ls</code>) return data as a direct array:</p> <pre><code>{\n  \"data\": [ ... ]\n}\n</code></pre> <p>Entity paths for jq: - persons: <code>.data.persons[]</code> - companies: <code>.data.companies[]</code> - opportunities: <code>.data.opportunities[]</code> - fieldValues: <code>.data.fieldValues[]</code> - fieldValueChanges: <code>.data.fieldValueChanges[]</code> - notes: <code>.data[]</code> (direct array) - interactions: <code>.data[]</code> (direct array) - tasks: <code>.data.tasks[]</code></p>"},{"location":"guides/csv-export/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/csv-export/#empty-output","title":"Empty Output","text":"<p>Make sure you're accessing the correct JSON path:</p> <pre><code># Wrong - missing .data\nxaffinity person ls --json | jq '.persons'\n\n# Correct\nxaffinity person ls --json | jq '.data.persons'\n</code></pre>"},{"location":"guides/csv-export/#csv-shows-json-strings","title":"CSV shows JSON strings","text":"<p>Use the <code>-r</code> flag with jq:</p> <pre><code># Wrong - produces \"[1,\\\"Alice\\\"]\"\nxaffinity person ls --json | jq '.data.persons[] | [.id, .name] | @csv'\n\n# Correct - produces \"1,Alice\"\nxaffinity person ls --json | jq -r '.data.persons[] | [.id, .name] | @csv'\n</code></pre>"},{"location":"guides/csv-export/#special-characters-broken-in-excel","title":"Special characters broken in Excel","text":"<p>Use the <code>--csv-bom</code> flag:</p> <pre><code>xaffinity person ls --all --csv --csv-bom &gt; people.csv\n</code></pre>"},{"location":"guides/csv-export/#empty-csv-file-has-no-headers","title":"Empty CSV file has no headers","text":"<p>This is expected behavior when there are no results. The CLI cannot determine column names without data. If you need headers even for empty results, use <code>list export</code> which has a known schema.</p>"},{"location":"guides/csv-export/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"guides/csv-export/#1-use-all-for-complete-exports","title":"1. Use --all for complete exports","text":"<p>For large datasets, use <code>--all</code> to fetch all pages:</p> <pre><code># Fetch all pages\nxaffinity person ls --all --csv &gt; people.csv\n\n# Or limit results\nxaffinity person ls --max-results 100 --csv &gt; people.csv\n</code></pre>"},{"location":"guides/csv-export/#2-combine-with-filters","title":"2. Combine with filters","text":"<p>Filtering on custom fields (recommended):</p> <p>When filtering on custom fields, use <code>--filter</code> for server-side filtering. This is more efficient as Affinity filters the data before sending it:</p> <pre><code># Efficient: Server-side filtering on custom field\nxaffinity person ls --filter 'Department = \"Sales\"' --all --csv &gt; sales-people.csv\n</code></pre> <p>You can also combine <code>--filter</code> with jq for additional client-side processing:</p> <pre><code># Filter server-side, then process with jq\nxaffinity person ls --filter 'Department = \"Sales\"' --json --all | \\\n  jq -r '.data.persons[] | [.id, .name, .primaryEmail] | @csv'\n</code></pre> <p>Filtering on built-in properties:</p> <p>Built-in properties like <code>type</code>, <code>firstName</code>, <code>primaryEmail</code>, etc. cannot be filtered using <code>--filter</code> (which only works with custom fields). Use jq for client-side filtering:</p> <pre><code># Less efficient: Client-side filtering on built-in 'type' property\n# (downloads all data, then filters locally)\nxaffinity person ls --json --all | \\\n  jq -r '.data.persons[] | select(.type == \"internal\") | [.id, .name] | @csv'\n</code></pre> <p>Combining both approaches:</p> <p>For complex scenarios, combine server-side custom field filtering with client-side built-in property filtering:</p> <pre><code># Filter on custom field server-side, then filter on type client-side\nxaffinity person ls --filter 'Department = \"Sales\"' --json --all | \\\n  jq -r '.data.persons[] | select(.type == \"internal\") | [.id, .name] | @csv'\n</code></pre>"},{"location":"guides/csv-export/#3-save-queries-as-scripts","title":"3. Save queries as scripts","text":"<p>Create reusable export scripts:</p> <pre><code>#!/bin/bash\n# export-pipeline.sh\n\nxaffinity person ls --all --csv --csv-bom &gt; people.csv\nxaffinity company ls --all --csv --csv-bom &gt; companies.csv\nxaffinity opportunity ls --all --csv --csv-bom &gt; opportunities.csv\n\necho \"Export complete!\"\n</code></pre>"},{"location":"guides/csv-export/#4-schedule-regular-exports","title":"4. Schedule regular exports","text":"<p>Use cron or task scheduler for automated exports:</p> <pre><code># Daily export at 2 AM\n0 2 * * * /path/to/export-pipeline.sh\n</code></pre>"},{"location":"guides/csv-export/#5-handle-large-datasets","title":"5. Handle large datasets","text":"<p>For very large exports, monitor progress:</p> <pre><code># The CLI will show API call counts for large exports\nxaffinity list export 12345 --all --csv &gt; large-export.csv\n</code></pre>"},{"location":"guides/csv-export/#6-composable-with-unix-tools","title":"6. Composable with UNIX tools","text":"<p>Since CSV goes to stdout, you can pipe to other tools:</p> <pre><code># Count rows\nxaffinity person ls --all --csv | wc -l\n\n# Preview first 10 rows\nxaffinity person ls --all --csv | head -10\n\n# Filter with awk\nxaffinity list export 123 --all --csv | awk -F',' '$3 &gt; 1000'\n</code></pre>"},{"location":"guides/csv-export/#getting-help","title":"Getting Help","text":"<ul> <li>Run <code>xaffinity &lt;command&gt; --help</code> to see all available options</li> <li>Check <code>xaffinity --version</code> to ensure you have the latest version</li> <li>Report issues at https://github.com/yaniv-golan/affinity-sdk/issues</li> </ul>"},{"location":"guides/csv-export/#related-documentation","title":"Related Documentation","text":"<ul> <li>CLI Scripting Guide - JSON output and automation</li> <li>CLI Commands Reference - Complete command documentation</li> <li>Field Values Guide - Working with custom fields</li> <li>Filtering Guide - Server-side and client-side filtering</li> </ul>"},{"location":"guides/datetime-handling/","title":"Datetime Handling","text":"<p>This guide explains how the SDK and CLI handle datetime values, including timezone behavior.</p> <p>SDK and CLI interpret naive datetimes differently</p> <p>SDK (Python): Naive datetime strings like <code>\"2024-01-01\"</code> are assumed to be UTC.</p> <p>CLI: Naive datetime strings like <code>--after 2024-01-01</code> are assumed to be local time.</p> <p>This difference can cause subtle bugs if you're not aware of it. For portable, reproducible behavior, always use explicit timezone suffixes (<code>Z</code> for UTC or <code>+HH:MM</code> offset).</p>"},{"location":"guides/datetime-handling/#sdk-python-api","title":"SDK (Python API)","text":"<p>All datetime fields in SDK models are UTC-aware:</p> <ul> <li>API responses: Parsed as UTC-aware datetime objects</li> <li>Naive datetimes: Assumed UTC when passed to models</li> <li>Serialization: Output uses ISO-8601 with <code>+00:00</code> offset</li> </ul> <pre><code>from affinity.models.secondary import Note\n\n# API response with Z suffix - parsed as UTC\nnote = Note.model_validate({\"id\": 1, \"createdAt\": \"2024-01-01T12:00:00Z\", ...})\nassert note.created_at.tzinfo is not None  # UTC-aware\n\n# You can safely compare datetimes\nfrom datetime import datetime, timezone\ncutoff = datetime(2024, 1, 1, tzinfo=timezone.utc)\nif note.created_at &gt; cutoff:\n    print(\"Recent note\")\n</code></pre>"},{"location":"guides/datetime-handling/#passing-datetimes-to-models","title":"Passing datetimes to models","text":"<p>When constructing models directly, naive datetimes are assumed UTC:</p> <pre><code>from datetime import datetime, timezone, timedelta\n\n# These are all equivalent:\ndt1 = datetime(2024, 1, 1, 12, 0, 0)  # Naive - assumed UTC\ndt2 = datetime(2024, 1, 1, 12, 0, 0, tzinfo=timezone.utc)  # Explicit UTC\ndt3 = datetime(2024, 1, 1, 7, 0, 0, tzinfo=timezone(timedelta(hours=-5)))  # EST \u2192 converted to UTC\n</code></pre>"},{"location":"guides/datetime-handling/#cli-command-line","title":"CLI (Command Line)","text":"<p>The CLI uses local time for user convenience:</p> <ul> <li>Input (naive strings): Interpreted as local time</li> <li>Input (with timezone): Respected exactly as specified</li> <li>Output (tables): Displayed in local time</li> <li>Output (CSV): Displayed in local time (for Excel/sharing)</li> <li>Output (JSON): Always UTC for machine consumption</li> </ul> <pre><code># Date only = midnight in YOUR timezone\nxaffinity interaction ls --type email --person-id 123 --after 2024-01-01\n\n# Explicit UTC (Z suffix)\nxaffinity interaction ls --type email --person-id 123 --after 2024-01-01T00:00:00Z\n\n# Explicit timezone offset\nxaffinity interaction ls --type email --person-id 123 --after 2024-01-01T00:00:00-05:00\n</code></pre>"},{"location":"guides/datetime-handling/#example","title":"Example","text":"<p>If you're in EST (UTC-5) and run <code>--after 2024-01-01</code>:</p> Stage Value CLI interprets as midnight EST on Jan 1 API receives <code>2024-01-01T05:00:00Z</code> (converted to UTC) Table output times in EST CSV output times in EST JSON output times in UTC (for scripting)"},{"location":"guides/datetime-handling/#why-local-time-for-cli","title":"Why local time for CLI?","text":"<p>This matches how other CLI tools work (<code>git log</code>, <code>docker logs</code>, <code>ls -la</code> all display local time). When users type <code>--after 2024-01-01</code>, they think \"midnight on January 1st in my timezone\", not \"midnight UTC\".</p>"},{"location":"guides/datetime-handling/#sdk-vs-cli-summary","title":"SDK vs CLI Summary","text":"Input SDK (Pydantic model) CLI (command flag) <code>\"2024-01-01\"</code> midnight UTC midnight local time \u2192 UTC <code>\"2024-01-01T12:00:00\"</code> 12:00 UTC 12:00 local time \u2192 UTC <code>\"2024-01-01T12:00:00Z\"</code> 12:00 UTC 12:00 UTC <code>\"2024-01-01T12:00:00-05:00\"</code> 17:00 UTC 17:00 UTC <p>Key difference: SDK assumes naive strings are UTC (matches API behavior). CLI assumes naive strings are local time (matches user expectations).</p>"},{"location":"guides/datetime-handling/#scripting-best-practices","title":"Scripting Best Practices","text":"<p>For reproducible scripts that work regardless of timezone:</p> <pre><code># Always use explicit UTC for scripting\nxaffinity interaction ls --type email --person-id 123 --after 2024-01-01T00:00:00Z --json &gt; interactions.json\n\n# Or use explicit timezone offset\nxaffinity interaction ls --type email --person-id 123 --after 2024-01-01T00:00:00-05:00 --json &gt; interactions.json\n</code></pre> <p>For machine consumption, use <code>--json</code> output which always provides UTC timestamps.</p>"},{"location":"guides/debugging-hooks/","title":"Debugging hooks","text":"<p>You can attach hooks for debugging and observability.</p> <p>Recommended: use <code>on_event</code>, which provides richer lifecycle events (retries, redirects, streaming).</p> <pre><code>from affinity import Affinity\nfrom affinity.hooks import HookEvent\n\ndef on_event(event: HookEvent) -&gt; None:\n    # Each event has a `.type` discriminator (e.g., \"request_started\", \"request_failed\", ...)\n    print(event.type)\n\nwith Affinity(api_key=\"your-api-key\", on_event=on_event) as client:\n    client.companies.list()\n</code></pre>"},{"location":"guides/debugging-hooks/#common-event-types","title":"Common event types","text":"<ul> <li>Requests: <code>request_started</code>, <code>request_retrying</code>, <code>request_succeeded</code>, <code>request_failed</code></li> <li>Redirects (downloads): <code>redirect_followed</code></li> <li>Responses: <code>response_headers_received</code></li> <li>Streaming downloads: <code>stream_completed</code>, <code>stream_aborted</code>, <code>stream_failed</code></li> </ul> <p>For streaming downloads, <code>response_headers_received</code> fires when headers arrive; one terminal stream event is emitted when iteration ends:</p> <ul> <li><code>stream_completed</code>: the full body was consumed</li> <li><code>stream_aborted</code>: iteration was interrupted (e.g., cancellation, keyboard interrupt, iterator closed)</li> <li><code>stream_failed</code>: an error occurred mid-stream</li> </ul> <p>The older <code>on_request/on_response/on_error</code> hooks are still supported:</p> <pre><code>from affinity import Affinity\n\ndef on_request(req) -&gt; None:\n    print(\"-&gt;\", req.method, req.url)\n\ndef on_response(res) -&gt; None:\n    cache = \" (cache hit)\" if res.cache_hit else \"\"\n    print(\"&lt;-\", res.status_code, res.request.url, cache)\n\ndef on_error(err) -&gt; None:\n    print(\"!!\", type(err.error).__name__, err.request.url)\n\nwith Affinity(api_key=\"your-api-key\", on_request=on_request, on_response=on_response, on_error=on_error) as client:\n    client.companies.list()\n</code></pre>"},{"location":"guides/debugging-hooks/#external-signed-download-urls","title":"External (signed) download URLs","text":"<p>File downloads may redirect to externally-hosted signed URLs. By default, the SDK redacts external URLs in hook events (query/fragment are removed). You can change this behavior with <code>Policies(external_hooks=...)</code>:</p> <ul> <li><code>ExternalHookPolicy.REDACT</code> (default): emit events, but redact external URLs</li> <li><code>ExternalHookPolicy.SUPPRESS</code>: do not emit events for external hops</li> <li><code>ExternalHookPolicy.EMIT_UNSAFE</code>: emit full external URLs (unsafe; may leak signed query params)</li> </ul> <pre><code>from affinity import Affinity, ExternalHookPolicy\nfrom affinity.policies import Policies\n\nclient = Affinity(\n    api_key=\"your-api-key\",\n    on_event=lambda e: print(e.type),\n    policies=Policies(external_hooks=ExternalHookPolicy.REDACT),\n)\n</code></pre> <p>If you need request interception for tests (without real network calls), use transport injection:</p> <pre><code>import httpx\nfrom affinity import Affinity\n\nclient = Affinity(api_key=\"your-api-key\", transport=httpx.MockTransport(lambda req: httpx.Response(200)))\n</code></pre>"},{"location":"guides/debugging-hooks/#cli","title":"CLI","text":"<p>The <code>xaffinity</code> CLI can also trace requests/responses/errors:</p> <pre><code>xaffinity --trace --no-progress whoami\n</code></pre>"},{"location":"guides/debugging-hooks/#next-steps","title":"Next steps","text":"<ul> <li>Configuration</li> <li>Troubleshooting</li> <li>Errors &amp; retries</li> </ul>"},{"location":"guides/errors-and-retries/","title":"Errors and retries","text":"<p>The SDK raises typed exceptions (subclasses of <code>AffinityError</code>) and retries some transient failures for safe methods (<code>GET</code>/<code>HEAD</code>).</p>"},{"location":"guides/errors-and-retries/#exception-taxonomy-common","title":"Exception taxonomy (common)","text":"<ul> <li><code>AuthenticationError</code> (401): invalid/missing API key</li> <li><code>AuthorizationError</code> (403): insufficient permissions</li> <li><code>NotFoundError</code> (404): entity or endpoint not found</li> <li><code>ValidationError</code> (400/422): invalid parameters/payload</li> <li><code>ConflictError</code> (409): resource conflict (e.g., duplicate email)</li> <li><code>RateLimitError</code> (429): you are being rate limited (may include <code>retry_after</code>)</li> <li><code>ServerError</code> (500/502/503/504): transient server-side errors</li> <li><code>NetworkError</code>: connection or network-level failure</li> <li><code>TimeoutError</code>: request or download deadline exceeded</li> <li><code>WriteNotAllowedError</code>: you attempted a write while writes are disabled by policy</li> <li><code>BetaEndpointDisabledError</code>: you called a beta V2 endpoint without <code>enable_beta_endpoints=True</code></li> <li><code>VersionCompatibilityError</code>: response parsing failed, often due to V2 API version mismatch</li> </ul> <p>See Exceptions for the full hierarchy.</p>"},{"location":"guides/errors-and-retries/#retry-policy-what-is-retried","title":"Retry policy (what is retried)","text":"<p>By default, retries apply to:</p> <ul> <li><code>GET</code>/<code>HEAD</code> only (safe/idempotent methods)</li> <li>429 responses (rate limits): respects <code>Retry-After</code> when present</li> <li>transient network/timeouts for <code>GET</code>/<code>HEAD</code></li> <li>transient server errors (e.g., 5xx) for <code>GET</code>/<code>HEAD</code></li> </ul> <p>Retries are controlled by <code>max_retries</code> (default: 3).</p>"},{"location":"guides/errors-and-retries/#download-deadlines","title":"Download deadlines","text":"<p>For large file downloads, <code>timeout</code> controls per-request timeouts, and <code>deadline_seconds</code> enforces a total time budget for streaming downloads (including retries/backoff). When exceeded, the SDK raises <code>TimeoutError</code>.</p>"},{"location":"guides/errors-and-retries/#diagnostics","title":"Diagnostics","text":"<p>Many errors include diagnostics (method/URL/status and more). When you catch an <code>AffinityError</code>, you can log it and inspect attached context.</p> <pre><code>from affinity import Affinity\nfrom affinity.exceptions import AffinityError, RateLimitError\n\ntry:\n    with Affinity(api_key=\"your-api-key\") as client:\n        client.companies.list()\nexcept RateLimitError as e:\n    print(\"Rate limited:\", e)\n    print(\"Retry after:\", e.retry_after)\nexcept AffinityError as e:\n    print(\"Affinity error:\", e)\n    if e.diagnostics:\n        print(\"Request:\", e.diagnostics.method, e.diagnostics.url)\n        print(\"Status:\", e.status_code)\n        print(\"Request ID:\", e.diagnostics.request_id)\n</code></pre>"},{"location":"guides/errors-and-retries/#production-playbook","title":"Production playbook","text":"<p>The SDK retries some failures for safe reads (<code>GET</code>/<code>HEAD</code>), but production systems typically need additional policies: alerting, bounded retries, idempotency for writes, and circuit breaking during outages.</p>"},{"location":"guides/errors-and-retries/#recommended-handling-by-error-type","title":"Recommended handling by error type","text":"<ul> <li>AuthenticationError (401), AuthorizationError (403): do not retry; fix credentials/permissions; alert immediately.</li> <li>ValidationError (400/422): do not retry; treat as a bug or bad input; log the response body snippet for debugging.</li> <li>NotFoundError (404): generally do not retry; treat as \"missing\" and handle at the business layer. Exception: see V1\u2192V2 eventual consistency below for 404s immediately after create.</li> <li>ConflictError (409): do not retry; handle the conflict (e.g., duplicate email, concurrent modification). May indicate you need to fetch-then-update instead of blind update.</li> <li>RateLimitError (429): retry only after <code>retry_after</code> (when present), reduce concurrency, and consider queueing/batching to smooth bursts.</li> <li>Server errors (5xx) / transient network errors / timeouts:</li> <li>Reads (<code>GET</code>/<code>HEAD</code>): retry with backoff (the SDK already does).</li> <li>Writes (<code>POST</code>/<code>PATCH</code>/<code>PUT</code>/<code>DELETE</code>): only retry if you can make the operation idempotent.</li> <li>NetworkError / TimeoutError: for reads, retry with backoff; for writes, only retry if idempotent.</li> <li>VersionCompatibilityError: do not retry; fix API-version configuration (see below).</li> </ul>"},{"location":"guides/errors-and-retries/#retrying-writes-safely-idempotency","title":"Retrying writes safely (idempotency)","text":"<p>By default, the SDK does not retry non-<code>GET</code>/<code>HEAD</code> requests, because a retry can duplicate side effects (e.g., \u201ccreate note\u201d twice).</p> <p>If you implement retries around writes, make them idempotent:</p> <ul> <li>Prefer endpoints that are naturally idempotent (e.g., \u201cset field value to X\u201d rather than \u201cappend note\u201d).</li> <li>If the API supports an idempotency key header, use it (store the key per logical operation and reuse it on retry).</li> <li>If the API does not support idempotency keys, consider application-level deduping (e.g., deterministic external IDs, or checking for an existing resource before creating a new one).</li> </ul>"},{"location":"guides/errors-and-retries/#circuit-breaker-fail-fast-during-outages","title":"Circuit breaker (fail fast during outages)","text":"<p>For sustained 5xx/timeout/network failures, a circuit breaker can protect your system (and Affinity) from retry storms.</p> <p>Minimal pattern:</p> <pre><code>import time\n\nclass SimpleCircuitBreaker:\n    def __init__(self, *, failure_threshold: int = 10, open_seconds: float = 30.0):\n        self.failure_threshold = failure_threshold\n        self.open_seconds = open_seconds\n        self._failures = 0\n        self._open_until: float | None = None\n\n    def allow(self) -&gt; bool:\n        if self._open_until is None:\n            return True\n        if time.monotonic() &gt;= self._open_until:\n            self._open_until = None\n            self._failures = 0\n            return True\n        return False\n\n    def record_success(self) -&gt; None:\n        self._failures = 0\n        self._open_until = None\n\n    def record_failure(self) -&gt; None:\n        self._failures += 1\n        if self._failures &gt;= self.failure_threshold:\n            self._open_until = time.monotonic() + self.open_seconds\n</code></pre>"},{"location":"guides/errors-and-retries/#alerting-guidance","title":"Alerting guidance","text":"<p>Common triggers:</p> <ul> <li>Any sustained 401/403 (credentials/permissions regressions).</li> <li>Sustained 429s (rate-limit pressure): alert and reduce concurrency / increase backoff.</li> <li>Elevated 5xx/timeouts/network errors (provider outage or network problem).</li> </ul> <p>When alerting, include <code>e.diagnostics.request_id</code> (when present) to speed up support/debugging.</p>"},{"location":"guides/errors-and-retries/#v1v2-eventual-consistency","title":"V1\u2192V2 eventual consistency","text":"<p>The SDK uses V1 API for writes (create/update/delete) and V2 API for reads (get/list). Due to eventual consistency between V1 and V2 backends, a <code>get()</code> call immediately after <code>create()</code> may return a 404 <code>NotFoundError</code> even though the entity was successfully created.</p> <p>This typically resolves within 100-500ms, but under load the delay can be longer.</p>"},{"location":"guides/errors-and-retries/#solutions","title":"Solutions","text":"<p>Option 1: Use the returned object (recommended)</p> <p>The <code>create()</code> method returns the created entity - use it directly instead of re-fetching:</p> <pre><code>person = client.persons.create(PersonCreate(first_name=\"Jane\", last_name=\"Doe\"))\n# Use person directly - no need to call get()\nprint(person.id, person.first_name)\n</code></pre> <p>Option 2: Use the <code>retries</code> parameter</p> <p>The <code>get()</code> methods on <code>persons</code>, <code>companies</code>, and <code>opportunities</code> accept a <code>retries</code> parameter:</p> <pre><code>person = client.persons.create(PersonCreate(first_name=\"Jane\", last_name=\"Doe\"))\n# Retry up to 3 times on 404 with exponential backoff\nfetched = client.persons.get(person.id, retries=3)\n</code></pre> <p>With <code>retries=3</code>, the SDK will retry up to 3 times on 404 with exponential backoff (0.5s, 1s, 1.5s).</p> <p>Note: The default is <code>retries=0</code> (fail fast). This is intentional - it keeps the SDK predictable and avoids hidden delays. Only use <code>retries &gt; 0</code> when you specifically need to handle eventual consistency after writes.</p>"},{"location":"guides/errors-and-retries/#stale-data-after-update","title":"Stale data after update","text":"<p>A related issue: after calling <code>update()</code>, a subsequent <code>get()</code> may return stale data (the old values) even though the update succeeded. Unlike the 404 case, the request succeeds with <code>200 OK</code> but returns outdated information.</p> <p>The <code>retries</code> parameter doesn't help here because the request succeeds - it just returns stale data.</p> <p>Solution: Trust the write response</p> <p>The <code>update()</code> method returns the updated entity from V1 (strongly consistent). Use it directly:</p> <pre><code># Good: Use the response from update()\nupdated_person = client.persons.update(person.id, PersonUpdate(first_name=\"Jane\"))\nprint(updated_person.first_name)  # \"Jane\" - immediate, from V1 response\n\n# Risky: Re-fetching may return stale data\nclient.persons.update(person.id, PersonUpdate(first_name=\"Jane\"))\nperson = client.persons.get(person.id)  # May still show old name!\n</code></pre> <p>This applies to all <code>update()</code> methods: persons, companies, opportunities, notes, etc.</p>"},{"location":"guides/errors-and-retries/#rate-limits","title":"Rate limits","text":"<p>If you are consistently hitting 429s, see Rate limits for strategies and the rate limit APIs.</p>"},{"location":"guides/errors-and-retries/#api-versions-and-beta-endpoints","title":"API versions and beta endpoints","text":"<p>If you see <code>BetaEndpointDisabledError</code>, enable beta endpoints:</p> <pre><code>from affinity import Affinity\n\nclient = Affinity(api_key=\"your-api-key\", enable_beta_endpoints=True)\n</code></pre> <p>If you see <code>VersionCompatibilityError</code>, this often indicates a V2 API version mismatch between your API key settings and what the SDK expects. Check your API key\u2019s \u201cDefault API Version\u201d, and consider setting <code>expected_v2_version</code> for clearer diagnostics:</p> <pre><code>from affinity import Affinity\n\nclient = Affinity(api_key=\"your-api-key\", expected_v2_version=\"2024-01-01\")\n</code></pre> <p>See API versions &amp; routing and the Glossary.</p>"},{"location":"guides/errors-and-retries/#next-steps","title":"Next steps","text":"<ul> <li>Rate limits</li> <li>Troubleshooting</li> <li>Configuration</li> <li>API versions &amp; routing</li> <li>Exceptions reference</li> </ul>"},{"location":"guides/field-types-and-values/","title":"Field types and values","text":"<p>Many endpoints can return \u201cfield values\u201d in addition to the core entity shape.</p>"},{"location":"guides/field-types-and-values/#field-types","title":"Field types","text":"<p>Use <code>FieldType</code> to request which field scopes you want:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import FieldType, PersonId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    person = client.persons.get(PersonId(123), field_types=[FieldType.ENRICHED, FieldType.GLOBAL])\n    if person.fields.requested:\n        print(person.fields.data)\n</code></pre> <p>Common values include:</p> <ul> <li><code>FieldType.ENRICHED</code></li> <li><code>FieldType.GLOBAL</code></li> <li><code>FieldType.LIST</code></li> <li><code>FieldType.LIST_SPECIFIC</code></li> </ul> <p>Notes:</p> <ul> <li><code>FieldType.LIST_SPECIFIC</code> is an alternate string value the API uses for list-scoped fields (you may see   it in responses as <code>\"list-specific\"</code>). Treat it as equivalent to <code>FieldType.LIST</code> for most use cases.</li> </ul>"},{"location":"guides/field-types-and-values/#field-ids","title":"Field IDs","text":"<p>If you know specific field IDs, you can request only those:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import FieldId, FieldType\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    page = client.companies.list(field_ids=[FieldId(101)], field_types=[FieldType.GLOBAL])\n    for company in page.data:\n        if company.fields.requested:\n            print(company.fields.data.get(\"101\"))\n</code></pre>"},{"location":"guides/field-types-and-values/#accepted-fieldid-formats","title":"Accepted FieldId formats","text":"<p><code>FieldId</code> accepts several input formats and normalizes them to <code>field-&lt;digits&gt;</code>:</p> Input Normalized to Valid <code>FieldId(123)</code> <code>\"field-123\"</code> Yes <code>FieldId(\"456\")</code> <code>\"field-456\"</code> Yes <code>FieldId(\"field-789\")</code> <code>\"field-789\"</code> Yes <code>FieldId(\"invalid\")</code> \u2014 No, raises <code>ValueError</code> <p>Invalid formats raise <code>ValueError</code> immediately at construction time.</p>"},{"location":"guides/field-types-and-values/#fieldid-comparison-semantics","title":"FieldId comparison semantics","text":"<p><code>FieldId</code> normalizes values at construction time, enabling direct equality comparisons without manual string conversion:</p> <pre><code>from affinity.types import FieldId\n\n# All these are equal - normalized to \"field-123\"\nassert FieldId(123) == FieldId(\"123\") == FieldId(\"field-123\")\n\n# Works in sets and dicts\nseen = {FieldId(123)}\nassert FieldId(\"field-123\") in seen  # True\n\n# Compare API response IDs directly\nfield_id = FieldId(123)\nif field_id == api_response_field_id:  # No str() conversion needed\n    process(field_id)\n</code></pre> <p>This normalization eliminates common comparison bugs where <code>FieldId(123) != FieldId(\"field-123\")</code> due to type differences.</p>"},{"location":"guides/field-types-and-values/#v1-only-writes-and-numeric-field-ids","title":"V1-only writes and numeric field IDs","text":"<p>The SDK uses V2 field metadata endpoints for reads. Some write operations still use V1 endpoints under the hood (for example, field value writes and field deletes). Those V1 endpoints require numeric field IDs.</p> <p>Rules:</p> <ul> <li>IDs of the form <code>field-&lt;digits&gt;</code> are convertible to V1 numeric IDs.</li> <li>Enriched and relationship-intelligence IDs (for example, <code>affinity-data-*</code> or   <code>source-of-introduction</code>) have no V1 numeric equivalent and will raise an error   if used in V1-only write paths.</li> </ul>"},{"location":"guides/field-types-and-values/#requested-vs-not-requested","title":"Requested vs not requested","text":"<p>Entities expose a <code>fields</code> container that preserves whether the API returned field data:</p> <ul> <li><code>entity.fields.requested == False</code>: you didn\u2019t request fields (or the API omitted them)</li> <li><code>entity.fields.requested == True</code>: field data was requested and returned (possibly empty)</li> </ul>"},{"location":"guides/field-types-and-values/#field-value-type-mapping","title":"Field value type mapping","text":"<p>When you read <code>entity.fields.data</code>, values are typed as <code>Any</code>. The expected shape depends on the field\u2019s <code>valueType</code> (<code>FieldValueType</code>) and whether the field allows multiple values.</p> <p><code>FieldValueType</code> is V2-first and string-based (for example: <code>dropdown-multi</code>, <code>ranked-dropdown</code>). Unknown future values are treated as open enums and preserved as strings.</p> Affinity <code>FieldValueType</code> Typical Python value Notes <code>text</code> <code>str</code> Plain text <code>filterable-text</code> / <code>filterable-text-multi</code> <code>str</code> / <code>list[str]</code> Reserved for Affinity-populated fields <code>number</code> / <code>number-multi</code> <code>int \\| float</code> / <code>list[int \\| float]</code> JSON numbers <code>datetime</code> <code>str</code> / <code>datetime.datetime</code> Typically ISO-8601 datetime strings on read <code>person</code> / <code>person-multi</code> <code>PersonId</code> / <code>list[PersonId]</code> Under the hood: <code>int</code> or <code>list[int]</code> <code>company</code> / <code>company-multi</code> <code>CompanyId</code> / <code>list[CompanyId]</code> Under the hood: <code>int</code> or <code>list[int]</code> <code>dropdown</code> / <code>dropdown-multi</code> <code>DropdownOptionId</code> / <code>list[DropdownOptionId]</code> Under the hood: <code>int</code> or <code>list[int]</code> <code>ranked-dropdown</code> <code>DropdownOptionId</code> Under the hood: <code>int</code> <code>location</code> / <code>location-multi</code> <code>dict[str, Any]</code> / <code>list[dict[str, Any]]</code> Structured location object(s); shape varies by API <code>interaction</code> <code>Any</code> Relationship-intelligence fields; shape varies by API"},{"location":"guides/field-types-and-values/#next-steps","title":"Next steps","text":"<ul> <li>Filtering</li> <li>Models</li> <li>Types reference</li> </ul>"},{"location":"guides/field-values/","title":"Field Values","text":"<p>Field values store custom data on entities (persons, companies, opportunities, list entries). This guide covers common patterns for working with field values.</p>"},{"location":"guides/field-values/#getting-field-values-for-an-entity","title":"Getting field values for an entity","text":"<p>Use <code>field_values.list()</code> to get all field values for a specific entity:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import PersonId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    field_values = client.field_values.list(person_id=PersonId(123))\n    for fv in field_values:\n        print(f\"{fv.field_id}: {fv.value}\")\n</code></pre> <p>Exactly one entity ID must be provided (<code>person_id</code>, <code>company_id</code>, <code>opportunity_id</code>, or <code>list_entry_id</code>).</p>"},{"location":"guides/field-values/#looking-up-a-specific-field-value","title":"Looking up a specific field value","text":"<p>Use <code>get_for_entity()</code> to get a single field value without iterating:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import FieldId, PersonId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    # Returns FieldValue or None if not found\n    status = client.field_values.get_for_entity(\n        FieldId(\"field-123\"),\n        person_id=PersonId(456),\n    )\n\n    if status is None:\n        print(\"Field is empty\")\n    else:\n        print(f\"Value: {status.value}\")\n\n    # With default value\n    status = client.field_values.get_for_entity(\n        FieldId(\"field-123\"),\n        person_id=PersonId(456),\n        default=\"N/A\",\n    )\n</code></pre>"},{"location":"guides/field-values/#batch-field-value-queries","title":"Batch field value queries","text":"<p>Use <code>list_batch()</code> to get field values for multiple entities:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import PersonId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    person_ids = [PersonId(1), PersonId(2), PersonId(3)]\n\n    # Returns dict mapping entity_id -&gt; list of field values\n    fv_map = client.field_values.list_batch(person_ids=person_ids)\n\n    for person_id, field_values in fv_map.items():\n        print(f\"Person {person_id}: {len(field_values)} field values\")\n</code></pre> <p>Handle errors gracefully with <code>on_error</code>:</p> <pre><code># Skip entities that fail (e.g., deleted or inaccessible)\nfv_map = client.field_values.list_batch(\n    person_ids=person_ids,\n    on_error=\"skip\",  # or \"raise\" (default)\n)\n</code></pre> <p>Performance note: This makes one API call per entity (O(n) calls). For parallel execution, use the async client.</p>"},{"location":"guides/field-values/#field-validation","title":"Field validation","text":"<p>Check if a field exists before using it:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import FieldId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    if client.fields.exists(FieldId(\"field-123\")):\n        # Field exists, safe to use\n        pass\n</code></pre> <p>Look up a field by name:</p> <pre><code># Case-insensitive name lookup\nfield = client.fields.get_by_name(\"Primary Email Status\")\n\nif field:\n    # Use field.id for subsequent operations\n    fv = client.field_values.get_for_entity(field.id, person_id=pid)\n</code></pre>"},{"location":"guides/field-values/#getting-person-with-field-values","title":"Getting person with field values","text":"<p>When you need both person data and field values, use <code>include_field_values</code> to save an API call:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import PersonId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    # Single API call returns person + field values\n    person = client.persons.get(\n        PersonId(123),\n        include_field_values=True,\n    )\n\n    # Field values are attached to the person object (may be None if not returned)\n    if person.field_values:\n        for fv in person.field_values:\n            print(f\"{fv.field_id}: {fv.value}\")\n</code></pre>"},{"location":"guides/field-values/#resource-management","title":"Resource management","text":"<p>Always use the client as a context manager to ensure proper cleanup:</p> <pre><code># Recommended: context manager ensures cleanup\nwith Affinity(api_key=\"your-api-key\") as client:\n    field_values = client.field_values.list(person_id=PersonId(123))\n\n# Or close explicitly\nclient = Affinity(api_key=\"your-api-key\")\ntry:\n    field_values = client.field_values.list(person_id=PersonId(123))\nfinally:\n    client.close()\n</code></pre> <p>If a client is not properly closed, a <code>ResourceWarning</code> will be raised during garbage collection. For async code, use <code>async with</code> or <code>await client.close()</code>.</p>"},{"location":"guides/field-values/#next-steps","title":"Next steps","text":"<ul> <li>Field types &amp; values - Field type mapping and FieldId semantics</li> <li>Filtering - Filter entities by field values</li> <li>Pagination - Iterate through large result sets</li> </ul>"},{"location":"guides/filtering/","title":"Filtering","text":"<p>V2 list endpoints accept <code>filter</code> expressions to query custom fields.</p> <p>Important: V2 filters only work with custom fields, not built-in entity properties. Built-in properties like <code>type</code>, <code>firstName</code>, <code>domain</code>, etc. cannot be filtered.</p>"},{"location":"guides/filtering/#recommended-use-the-filter-builder","title":"Recommended: Use the Filter Builder","text":"<p>Use <code>affinity.F</code> to build type-safe filter expressions:</p> <pre><code>from affinity import Affinity, F\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    # Recommended: Type-safe filter builder\n    companies = client.companies.list(\n        filter=F.field(\"Industry\").equals(\"Software\")\n    )\n</code></pre> <p>Benefits of the filter builder: - Prevents syntax errors with type checking - Handles escaping automatically - Makes it clear you're filtering custom fields (via <code>field()</code> method) - Provides IDE autocomplete for filter operations</p> <p>CLI users: The CLI uses raw filter string syntax. See examples below.</p>"},{"location":"guides/filtering/#filter-builder-examples","title":"Filter Builder Examples","text":"<p>Simple comparisons:</p> <pre><code>from affinity import Affinity, F\n\n# Equals\npersons = client.persons.list(filter=F.field(\"Department\").equals(\"Sales\"))\n\n# Contains (case-insensitive substring match)\ncompanies = client.companies.list(filter=F.field(\"Industry\").contains(\"Tech\"))\n\n# Starts with\npersons = client.persons.list(filter=F.field(\"Title\").starts_with(\"VP\"))\n\n# Ends with\npersons = client.persons.list(filter=F.field(\"Email\").ends_with(\"@acme.com\"))\n\n# Greater than (for numbers/dates)\nopportunities = client.opportunities.list(filter=F.field(\"Amount\").greater_than(100000))\n\n# Is null / is not null\npersons = client.persons.list(filter=F.field(\"Manager\").is_null())\n</code></pre> <p>Complex logic (AND/OR/NOT):</p> <pre><code># AND: Both conditions must be true\nactive_sales = client.persons.list(\n    filter=F.field(\"Department\").equals(\"Sales\") &amp; F.field(\"Status\").equals(\"Active\")\n)\n\n# OR: Either condition can be true\ntech_or_finance = client.companies.list(\n    filter=F.field(\"Industry\").equals(\"Technology\") | F.field(\"Industry\").equals(\"Finance\")\n)\n\n# NOT: Negate a condition\nnon_archived = client.persons.list(\n    filter=~F.field(\"Archived\").equals(True)\n)\n\n# Complex: (A AND B) OR (C AND D)\nresult = client.companies.list(\n    filter=(\n        (F.field(\"Industry\").equals(\"Software\") &amp; F.field(\"Region\").equals(\"US\"))\n        | (F.field(\"Industry\").equals(\"Hardware\") &amp; F.field(\"Region\").equals(\"EU\"))\n    )\n)\n</code></pre> <p>In list (multiple values):</p> <pre><code># Match any value in the list\nmulti_region = client.companies.list(\n    filter=F.field(\"Region\").in_list([\"US\", \"Canada\", \"Mexico\"])\n)\n</code></pre>"},{"location":"guides/filtering/#raw-filter-strings","title":"Raw Filter Strings","text":"<p>For CLI or advanced SDK use, you can use raw filter strings. The SDK supports both official Affinity V2 API syntax and SDK-specific extensions.</p>"},{"location":"guides/filtering/#standard-operators-affinity-v2-api-compatible","title":"Standard Operators (Affinity V2 API compatible)","text":"<p>These operators work both with the Affinity API and SDK client-side filtering:</p> Meaning Operator Example and <code>&amp;</code> <code>field(\"A\") = 1 &amp; field(\"B\") = 2</code> or <code>\\|</code> <code>field(\"A\") = 1 \\| field(\"B\") = 2</code> not <code>!</code> <code>!(field(\"A\") = 1)</code> equals <code>=</code> <code>field(\"Industry\") = \"Software\"</code> not equals <code>!=</code> <code>field(\"Status\") != \"inactive\"</code> starts with <code>=^</code> <code>field(\"Name\") =^ \"Ac\"</code> ends with <code>=$</code> <code>field(\"Name\") =$ \"Inc\"</code> contains <code>=~</code> <code>field(\"Title\") =~ \"Manager\"</code> greater than <code>&gt;</code> <code>field(\"Count\") &gt; 5</code> greater than or equal <code>&gt;=</code> <code>field(\"Count\") &gt;= 5</code> less than <code>&lt;</code> <code>field(\"Count\") &lt; 10</code> less than or equal <code>&lt;=</code> <code>field(\"Count\") &lt;= 10</code> is NULL <code>!= *</code> <code>field(\"Email\") != *</code> is not NULL <code>= *</code> <code>field(\"Email\") = *</code> is empty string <code>= \"\"</code> <code>field(\"Notes\") = \"\"</code> collection exact match <code>= [A, B]</code> <code>field(\"Tags\") = [tech, startup]</code> collection contains all <code>=~ [A, B]</code> <code>field(\"Tags\") =~ [tech, startup]</code> collection empty <code>= []</code> <code>field(\"Tags\") = []</code>"},{"location":"guides/filtering/#sdk-extensions-client-side-filtering-only","title":"SDK Extensions (client-side filtering only)","text":"<p>These operators are SDK-specific and only work for client-side filtering with <code>--expand-filter</code> or <code>matches()</code>. They do NOT work with the Affinity API.</p>"},{"location":"guides/filtering/#word-based-aliases-sdk-extension","title":"Word-Based Aliases <code>[SDK Extension]</code>","text":"<p>Human/LLM-friendly aliases for official operators:</p> Alias Equivalent Example <code>contains</code> <code>=~</code> <code>name contains \"Corp\"</code> <code>starts_with</code> <code>=^</code> <code>name starts_with \"Acme\"</code> <code>ends_with</code> <code>=$</code> <code>email ends_with \"@acme.com\"</code> <code>gt</code> <code>&gt;</code> <code>count gt 5</code> <code>gte</code> <code>&gt;=</code> <code>count gte 5</code> <code>lt</code> <code>&lt;</code> <code>count lt 10</code> <code>lte</code> <code>&lt;=</code> <code>count lte 10</code> <code>is null</code> <code>!= *</code> <code>email is null</code> <code>is not null</code> <code>= *</code> <code>email is not null</code> <code>is empty</code> <code>= \"\"</code> or <code>= []</code> <code>tags is empty</code>"},{"location":"guides/filtering/#additional-collection-operators-sdk-extension","title":"Additional Collection Operators <code>[SDK Extension]</code>","text":"Operator Syntax Description in list <code>in [A, B, C]</code> Value equals any in list between <code>between [1, 10]</code> Value in range (inclusive) has any <code>has_any [A, B]</code> Array contains any of values (exact match) has all <code>has_all [A, B]</code> Array contains all values (exact match) contains any <code>contains_any [A, B]</code> Any element contains any substring contains all <code>contains_all [A, B]</code> Any element contains all substrings <p>Example equivalents (prefer official syntax for API portability):</p> <pre><code># These are equivalent:\nxaffinity list export 123 --expand-filter '\"Team Member\" =~ LB'       # Official V2 API\nxaffinity list export 123 --expand-filter '\"Team Member\" contains LB' # SDK alias\n\nxaffinity list export 123 --expand-filter 'email = *'           # Official V2 API\nxaffinity list export 123 --expand-filter 'email is not null'   # SDK alias\n\nxaffinity list export 123 --expand-filter 'count &gt; 5'   # Official V2 API\nxaffinity list export 123 --expand-filter 'count gt 5'  # SDK alias\n</code></pre>"},{"location":"guides/filtering/#cli-examples","title":"CLI Examples","text":"<pre><code># Simple filter\nxaffinity person ls --filter 'Department = \"Sales\"'\n\n# Contains (case-insensitive)\nxaffinity company ls --filter 'Industry =~ \"tech\"'\n\n# Numeric comparison\nxaffinity opportunity ls --filter 'Amount &gt; 100000'\n\n# Multiple conditions with AND\nxaffinity person ls --filter 'Status = \"Active\" &amp; Department = \"Sales\"'\n\n# Multiple conditions with OR\nxaffinity company ls --filter 'Region = \"US\" | Region = \"Canada\"'\n\n# Null check\nxaffinity person ls --filter 'Manager != *'\n\n# Collection operators (SDK extension)\nxaffinity list export 123 --expand-filter 'Status in [Active, Pending]'\nxaffinity list export 123 --expand-filter 'Tags has_any [priority, urgent]'\n</code></pre>"},{"location":"guides/filtering/#what-can-be-filtered","title":"What Can Be Filtered?","text":"<p>Custom fields (added to entities in Affinity):</p> <p>Python SDK: - <code>F.field(\"Department\").equals(\"Sales\")</code> - <code>F.field(\"Status\").contains(\"Active\")</code></p> <p>CLI (raw filter syntax): - <code>Department = \"Sales\"</code> - <code>Status =~ \"Active\"</code></p> <p>Built-in properties (cannot be filtered with V2 filter expressions): - Person: <code>type</code>, <code>firstName</code>, <code>lastName</code>, <code>primaryEmail</code>, <code>emailAddresses</code> - Company: <code>name</code>, <code>domain</code>, <code>domains</code> - Opportunity: <code>name</code>, <code>listId</code></p> <p>For built-in properties, retrieve all data and filter client-side (see CSV Export Guide for examples).</p>"},{"location":"guides/filtering/#filtering-in-list-exports-cli","title":"Filtering in List Exports (CLI)","text":"<p>The <code>list export</code> command supports two filter options with identical syntax but different behavior:</p> Option What It Filters Where Filtering Happens <code>--filter</code> List entries Server-side (API) <code>--expand-filter</code> Expanded entities (people, companies) Client-side (after fetch)"},{"location":"guides/filtering/#why-the-difference","title":"Why the difference?","text":"<p>The Affinity API supports filtering for list entries, but does not support filtering associations.</p> <p>When you use <code>--expand persons</code>, the CLI:</p> <ol> <li>Fetches the list entries (can be filtered with <code>--filter</code>)</li> <li>For each entry, fetches ALL associated people (API returns all, no filter option)</li> <li>Filters the people locally based on <code>--expand-filter</code></li> </ol> <p>This means <code>--expand-filter</code>:</p> <ul> <li>Uses the same syntax as <code>--filter</code> for consistency</li> <li>Is applied after fetching data (doesn't reduce API calls)</li> <li>Supports SDK extension operators (word aliases, collection operators)</li> <li>Still useful for reducing output size and focusing on relevant associations</li> </ul>"},{"location":"guides/filtering/#example","title":"Example","text":"<pre><code># Server-side: only fetch Active opportunities\n# Client-side: only include people with valid email status\nxaffinity list export 275454 \\\n  --filter \"Status=Active\" \\\n  --expand persons \\\n  --expand-filter '\"Primary Email Status\"=Valid | \"Primary Email Status\"=Unknown | \"Primary Email Status\" is null' \\\n  --all --csv &gt; output.csv\n</code></pre>"},{"location":"guides/filtering/#performance-consideration","title":"Performance consideration","text":"<p>Since <code>--expand-filter</code> is client-side, all associations are still fetched from the API. For large lists with many associations, the export may take time even if the filter reduces the final output significantly. Use <code>--dry-run</code> to estimate API calls.</p>"},{"location":"guides/filtering/#next-steps","title":"Next steps","text":"<ul> <li>Pagination</li> <li>Field types &amp; values</li> <li>Examples</li> <li>Filters reference</li> </ul>"},{"location":"guides/ids-and-types/","title":"IDs and types","text":"<p>The SDK uses strongly-typed ID classes to reduce accidental ID mixups and enable better static analysis.</p>"},{"location":"guides/ids-and-types/#basic-usage","title":"Basic usage","text":"<pre><code>from affinity import Affinity\nfrom affinity.types import CompanyId, PersonId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    company = client.companies.get(CompanyId(123))\n    person = client.persons.get(PersonId(456))\n</code></pre>"},{"location":"guides/ids-and-types/#available-id-types","title":"Available ID types","text":"Type Description <code>PersonId</code> Person identifier <code>CompanyId</code> Company identifier <code>OpportunityId</code> Opportunity identifier <code>ListId</code> List identifier <code>ListEntryId</code> List entry identifier <code>FieldId</code> Field definition identifier <code>FieldValueId</code> Field value identifier <code>NoteId</code> Note identifier <code>InteractionId</code> Interaction identifier <code>FileId</code> File attachment identifier"},{"location":"guides/ids-and-types/#why-typed-ids","title":"Why typed IDs?","text":"<p>Typed IDs help catch bugs at development time:</p> <pre><code>from affinity.types import PersonId, CompanyId\n\nperson_id = PersonId(123)\ncompany_id = CompanyId(456)\n\n# Static type checkers will flag this as an error:\n# client.persons.get(company_id)  # Wrong type!\n</code></pre>"},{"location":"guides/ids-and-types/#behavior","title":"Behavior","text":"<p>Typed IDs behave like integers at runtime:</p> <pre><code>from affinity.types import PersonId\n\npid = PersonId(123)\nprint(pid)       # 123\nprint(int(pid))  # 123\nprint(pid + 1)   # 124 (regular int)\n</code></pre>"},{"location":"guides/ids-and-types/#next-steps","title":"Next steps","text":"<ul> <li>Field types &amp; values</li> <li>Models</li> <li>Examples</li> <li>Types reference</li> </ul>"},{"location":"guides/models/","title":"Models","text":"<p>Models are Pydantic v2 models. They validate API responses and give you typed attributes.</p>"},{"location":"guides/models/#dumping-data","title":"Dumping data","text":"<p>Use <code>model_dump()</code> for Python objects and <code>model_dump(mode=\"json\")</code> for JSON-safe output:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import PersonId\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    person = client.persons.get(PersonId(123))\n    print(person.model_dump())\n    print(person.model_dump(mode=\"json\"))\n</code></pre>"},{"location":"guides/models/#aliases-camelcase-vs-snake_case","title":"Aliases (camelCase vs snake_case)","text":"<p>The SDK accepts and populates both API-style keys (camelCase) and Python attribute names (snake_case) when parsing.</p>"},{"location":"guides/models/#typed-ids","title":"Typed IDs","text":"<p>Many model <code>.id</code> fields use strongly-typed ID wrappers (for example: <code>PersonId</code>, <code>CompanyId</code>, <code>ListId</code>, <code>FieldValueId</code>). They behave like <code>int</code> at runtime, but help static type checkers prevent mixing IDs across entity types.</p> <pre><code>from affinity.types import (\n    DropdownOptionId,\n    FieldValueChangeId,\n    FieldValueId,\n    InteractionId,\n    PersonId,\n    TenantId,\n)\n\nperson_id = PersonId(123)\ninteraction_id = InteractionId(456)\nfield_value_id = FieldValueId(789)\nfield_value_change_id = FieldValueChangeId(321)\ndropdown_option_id = DropdownOptionId(10)\ntenant_id = TenantId(99)\n</code></pre>"},{"location":"guides/models/#field-values-container","title":"Field values container","text":"<p>Entities like <code>Person</code>, <code>Company</code>, and <code>Opportunity</code> expose <code>fields</code>, which preserves whether you requested field data:</p> <pre><code>from affinity import Affinity\nfrom affinity.types import FieldType\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    page = client.companies.list(field_types=[FieldType.GLOBAL])\n    company = page.data[0]\n    if company.fields.requested:\n        print(company.fields.data)\n</code></pre>"},{"location":"guides/models/#next-steps","title":"Next steps","text":"<ul> <li>Field types &amp; values</li> <li>Models reference</li> </ul>"},{"location":"guides/opportunity-associations/","title":"Working with Opportunity Associations","text":"<p>Opportunities in Affinity can be linked to People and Companies. Due to API limitations, these associations require special handling.</p>"},{"location":"guides/opportunity-associations/#the-v2-limitation","title":"The V2 Limitation","text":"<p>When you retrieve opportunities via standard methods, person and company associations may be empty:</p> <pre><code>opp = client.opportunities.get(OpportunityId(123))\nprint(opp.person_ids)  # [] - empty!\n</code></pre> <p>This is because the V2 API returns a \"partial representation\" that omits association data.</p> Why does this happen? <p>The Affinity V2 API returns opportunities without <code>personIds</code> or <code>companyIds</code> fields. This is a known limitation. The V1 API includes these associations, so the SDK provides explicit methods to fetch them.</p>"},{"location":"guides/opportunity-associations/#getting-associations","title":"Getting Associations","text":"<p>Use the dedicated association methods:</p> <pre><code>from affinity.types import OpportunityId\n\n# Get person IDs only (1 API call)\nperson_ids = client.opportunities.get_associated_person_ids(OpportunityId(123))\n\n# Get full Person objects (1 + N API calls)\npeople = client.opportunities.get_associated_people(OpportunityId(123))\n\n# Same for companies\ncompany_ids = client.opportunities.get_associated_company_ids(OpportunityId(123))\ncompanies = client.opportunities.get_associated_companies(OpportunityId(123))\n</code></pre>"},{"location":"guides/opportunity-associations/#getting-both-at-once","title":"Getting Both at Once","text":"<p>If you need both person and company associations, use <code>get_associations()</code> to save an API call:</p> <pre><code># Single V1 call returns both\nassoc = client.opportunities.get_associations(OpportunityId(123))\nprint(assoc.person_ids)   # [PersonId(1001), PersonId(1002)]\nprint(assoc.company_ids)  # [CompanyId(2001)]\n</code></pre> <p>The return type is a <code>NamedTuple</code> with IDE autocomplete support.</p>"},{"location":"guides/opportunity-associations/#batch-operations","title":"Batch Operations","text":"<p>When working with lists of opportunities, use the batch helper:</p> <pre><code>from affinity.types import ListId, OpportunityId\n\n# Step 1: Get all opportunity IDs from a list\nopp_ids = [\n    OpportunityId(entry.entity.id)\n    for entry in client.lists.entries(ListId(123)).all()\n]\n\n# Step 2: Fetch associations for all (1 API call per opportunity)\nassociations = client.opportunities.get_associated_person_ids_batch(opp_ids)\n\n# Step 3: Collect all unique person IDs\nall_person_ids = set()\nfor person_ids in associations.values():\n    all_person_ids.update(person_ids)\n</code></pre>"},{"location":"guides/opportunity-associations/#error-handling-in-batch-operations","title":"Error Handling in Batch Operations","text":"<p>By default, the batch helper raises on the first error. Use <code>on_error=\"skip\"</code> to continue:</p> <pre><code># Skip failed IDs instead of raising\nassociations = client.opportunities.get_associated_person_ids_batch(\n    opp_ids,\n    on_error=\"skip\",  # Default is \"raise\"\n)\n# Only successfully fetched opportunities are in the result\n</code></pre>"},{"location":"guides/opportunity-associations/#limiting-results","title":"Limiting Results","text":"<p>All association methods support <code>max_results</code> to limit the number of items returned:</p> <pre><code># Get at most 5 associated people\npeople = client.opportunities.get_associated_people(\n    OpportunityId(123),\n    max_results=5,\n)\n</code></pre>"},{"location":"guides/opportunity-associations/#api-cost","title":"API Cost","text":"Method API Calls <code>get_associated_person_ids()</code> 1 <code>get_associated_company_ids()</code> 1 <code>get_associations()</code> 1 <code>get_associated_people()</code> 1 + N (N = people count) <code>get_associated_companies()</code> 1 + N (N = company count) <code>get_associated_person_ids_batch()</code> N (N = opportunity count) <p>Rate Limits</p> <p>For large associations (N &gt; 50), be aware of rate limit implications. Consider using <code>max_results</code> to limit the number of full object fetches.</p>"},{"location":"guides/opportunity-associations/#async-support","title":"Async Support","text":"<p>All methods have async equivalents in <code>AsyncOpportunityService</code>:</p> <pre><code># Async version\nperson_ids = await client.opportunities.get_associated_person_ids(OpportunityId(123))\n</code></pre>"},{"location":"guides/opportunity-associations/#alternative-get_details","title":"Alternative: <code>get_details()</code>","text":"<p>If you need the full opportunity object including associations, use <code>get_details()</code>:</p> <pre><code>opp = client.opportunities.get_details(OpportunityId(123))\nprint(opp.person_ids)  # Now populated!\n</code></pre> <p>This is useful when you need other opportunity fields alongside associations.</p>"},{"location":"guides/opportunity-associations/#next-steps","title":"Next Steps","text":"<ul> <li>Pagination - for iterating large result sets</li> <li>Rate Limits - understanding API quotas</li> <li>API Versions - V1 vs V2 behavior</li> </ul>"},{"location":"guides/pagination/","title":"Pagination","text":"<p>Most list endpoints support both:</p> <ul> <li><code>list(...)</code>: fetch a single page</li> <li><code>iter(...)</code> or <code>all(...)</code>: iterate across pages automatically</li> </ul>"},{"location":"guides/pagination/#services-with-pagination","title":"Services with pagination","text":"Service Auto-pagination Page-by-page API <code>persons</code> <code>all()</code>, <code>iter()</code> <code>pages()</code> V2 <code>companies</code> <code>all()</code>, <code>iter()</code> <code>pages()</code> V2 <code>opportunities</code> <code>all()</code>, <code>iter()</code> <code>pages()</code> V2 <code>lists</code> <code>all()</code>, <code>iter()</code> <code>pages()</code> V2 <code>notes</code> <code>iter()</code> use <code>list()</code> V1 <code>reminders</code> <code>iter()</code> use <code>list()</code> V1 <code>interactions</code> <code>iter()</code> use <code>list()</code> V1 <code>files</code> <code>all()</code>, <code>iter()</code> use <code>list()</code> V1 <p>V1 vs V2 method availability</p> <p>V2 services (persons, companies, opportunities, lists) have <code>all()</code> and <code>iter()</code> as aliases, plus a dedicated <code>pages()</code> method for page-by-page iteration with progress callbacks.</p> <p>V1 services (notes, reminders, interactions, files) have <code>iter()</code> for auto-pagination. For manual page-by-page control, use <code>list()</code> with <code>page_token</code> parameter directly.</p> <p>Example:</p> <pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    # Stream through all companies (memory-efficient)\n    for company in client.companies.all():\n        print(company.name)\n\n    # For V1 services, use iter()\n    for note in client.notes.iter(person_id=person_id):\n        print(note.content)\n</code></pre>"},{"location":"guides/pagination/#progress-callbacks","title":"Progress callbacks","text":"<p>Use <code>on_progress</code> to track pagination progress for logging, progress bars, or debugging.</p> <p>The <code>on_progress</code> callback is available on <code>PageIterator.pages()</code>:</p> <pre><code>from affinity import Affinity, PaginationProgress\n\ndef log_progress(p: PaginationProgress) -&gt; None:\n    print(f\"Page {p.page_number}: {p.items_so_far} items so far\")\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    # Get a PageIterator, then iterate page-by-page with progress\n    iterator = client.companies.all()\n    for page in iterator.pages(on_progress=log_progress):\n        for company in page.data:\n            process(company)\n</code></pre> <p>Service <code>pages()</code> vs <code>PageIterator.pages()</code></p> <p>V2 services (persons, companies, etc.) have a direct <code>pages()</code> method for convenience. The <code>PageIterator.pages()</code> method shown above works with any auto-pagination method.</p> <p><code>PaginationProgress</code> provides:</p> Field Description <code>page_number</code> 1-indexed page number <code>items_in_page</code> Items in current page <code>items_so_far</code> Cumulative items including current page <code>has_next</code> Whether more pages exist"},{"location":"guides/pagination/#collecting-results-into-a-list","title":"Collecting results into a list","text":"<p>Service methods like <code>client.companies.all()</code> return a <code>PageIterator</code> for streaming iteration. While the return type annotation is <code>Iterator[T]</code> for interface compatibility, the actual object returned is a <code>PageIterator</code> which provides additional methods like <code>.all()</code> and <code>.pages()</code>.</p> <p>If you need all items in a list (instead of streaming), call the <code>PageIterator.all()</code> method:</p> <pre><code>from affinity import Affinity, TooManyResultsError\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    try:\n        # service.all() returns PageIterator\n        # PageIterator.all() collects all items into a list\n        iterator = client.companies.all()\n        companies = iterator.all()  # Returns list[Company]\n        # Or as a one-liner: client.companies.all().all()\n    except TooManyResultsError as e:\n        print(f\"Too many results: {e}\")\n</code></pre> <p>The <code>.all().all()</code> pattern</p> <p>The double <code>.all()</code> can look confusing. Here's what's happening:</p> <ol> <li><code>client.companies.all()</code> \u2192 returns a <code>PageIterator</code> (streams items lazily)</li> <li><code>PageIterator.all()</code> \u2192 collects all items into a <code>list</code> (loads into memory)</li> </ol> <p>By default, <code>PageIterator.all()</code> raises <code>TooManyResultsError</code> if results exceed 100,000 items.</p> <p>Adjust or disable the limit with the <code>limit</code> parameter:</p> <pre><code># Lower limit for safety\ncompanies = client.companies.all().all(limit=1000)\n\n# Disable limit (use with caution)\ncompanies = client.companies.all().all(limit=None)\n</code></pre> <p>For very large datasets, prefer streaming directly (no collection into list):</p> <pre><code># Memory-efficient: processes one item at a time\nfor company in client.companies.all():\n    process(company)\n</code></pre>"},{"location":"guides/pagination/#manual-pagination","title":"Manual pagination","text":"<p>When iterating pages manually, use the <code>next_cursor</code> property to get the cursor for the next page:</p> <pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    page = client.companies.list(limit=100)\n\n    while page.has_next:\n        process(page.data)\n        # Always use next_cursor for the next page cursor\n        page = client.companies.list(limit=100, cursor=page.next_cursor)\n</code></pre> <p>Use <code>next_cursor</code>, not <code>pagination.next_cursor</code></p> <p>Always use the <code>next_cursor</code> property on <code>PaginatedResponse</code>. This works consistently across all services regardless of the underlying API version.</p>"},{"location":"guides/pagination/#next-steps","title":"Next steps","text":"<ul> <li>Filtering</li> <li>Field types &amp; values</li> <li>Examples</li> <li>API reference</li> </ul>"},{"location":"guides/performance/","title":"Performance tuning","text":"<p>This guide covers practical knobs and patterns for high-volume usage.</p>"},{"location":"guides/performance/#pagination-sizing","title":"Pagination sizing","text":"<ul> <li>Prefer larger <code>limit</code> values for throughput (fewer requests), but keep response sizes reasonable for your workload.</li> <li>If you hit 429s, lower concurrency first (see below), then consider reducing <code>limit</code>.</li> </ul>"},{"location":"guides/performance/#concurrency-async","title":"Concurrency (async)","text":"<ul> <li>Run independent reads concurrently, but cap concurrency (e.g., 5\u201320 in flight depending on rate limits and payload size).</li> <li>When you see 429s, reduce concurrency and let the SDK respect <code>Retry-After</code>.</li> </ul>"},{"location":"guides/performance/#connection-pooling","title":"Connection pooling","text":"<p>The SDK uses httpx connection pooling. For high-throughput clients:</p> <ul> <li>Reuse a single client instance for many calls (don\u2019t create a new <code>Affinity</code> per request).</li> <li>Close clients when done (use a context manager).</li> </ul>"},{"location":"guides/performance/#timeouts-and-deadlines","title":"Timeouts and deadlines","text":"<ul> <li>Use the global <code>timeout</code> to set a sensible default for API requests.</li> <li>For large file downloads, use per-call <code>timeout</code> and <code>deadline_seconds</code> to bound total time spent (including retries/backoff).</li> </ul> <pre><code>from affinity import Affinity\nfrom affinity.types import FileId\n\nwith Affinity(api_key=\"your-api-key\", timeout=30.0) as client:\n    for chunk in client.files.download_stream(FileId(123), timeout=60.0, deadline_seconds=300):\n        ...\n</code></pre>"},{"location":"guides/performance/#caching","title":"Caching","text":"<p>The SDK provides optional in-memory caching for metadata-style responses (field definitions, list configurations). This reduces API calls for frequently-accessed, slowly-changing data.</p>"},{"location":"guides/performance/#enabling-cache","title":"Enabling cache","text":"<pre><code>from affinity import Affinity\n\n# Enable with default 5-minute TTL\nclient = Affinity(api_key=\"your-api-key\", enable_cache=True)\n\n# Custom TTL (in seconds)\nclient = Affinity(api_key=\"your-api-key\", enable_cache=True, cache_ttl=600.0)\n</code></pre>"},{"location":"guides/performance/#long-running-applications","title":"Long-running applications","text":"<p>For long-running processes (web servers, background workers), be aware that cached data may become stale:</p> <ul> <li>Field definitions may change if admins add/modify fields</li> <li>List configurations may change if lists are reconfigured</li> <li>Default TTL is 5 minutes (300 seconds)</li> </ul> <p>Recommendations:</p> <ol> <li>Choose appropriate TTL: Match your TTL to how often metadata changes in your organization</li> <li>Invalidate on known changes: Clear cache after operations that modify metadata</li> <li>Periodic refresh: For very long processes, consider periodic cache clears</li> </ol>"},{"location":"guides/performance/#manual-cache-invalidation","title":"Manual cache invalidation","text":"<pre><code># Clear all cached entries\nclient.clear_cache()\n</code></pre>"},{"location":"guides/performance/#when-to-use-caching","title":"When to use caching","text":"Scenario Recommendation Short-lived scripts Caching optional (few repeated calls) CLI tools Enable caching (reduces latency for field lookups) Web servers Enable with appropriate TTL Background workers Enable, consider periodic cache refresh"},{"location":"guides/performance/#cache-isolation","title":"Cache isolation","text":"<p>Cache is isolated per API key and base URL combination, so multiple clients with different credentials won't share cached data.</p>"},{"location":"guides/performance/#cli-session-caching","title":"CLI session caching","text":"<p>For CLI pipelines, use session caching to share metadata across invocations:</p> <pre><code>export AFFINITY_SESSION_CACHE=$(xaffinity session start)\nxaffinity list export \"My List\" | xaffinity person get\nxaffinity session end\n</code></pre> <p>See CLI Pipeline Optimization for details.</p>"},{"location":"guides/performance/#counting-entities","title":"Counting entities","text":""},{"location":"guides/performance/#list-entries-efficient","title":"List entries (efficient)","text":"<p>Use <code>client.lists.get_size(list_id)</code> to get accurate entry counts:</p> <pre><code># Count entries on a single list\ncount = client.lists.get_size(list_id)\nprint(f\"Entries: {count}\")\n\n# Get counts for multiple lists (cached for 5 min)\nfor lst in client.lists.all():\n    count = client.lists.get_size(lst.id)\n    print(f\"{lst.name}: {count}\")\n\n# Force fresh fetch (bypass cache) when accuracy is critical\ncount = client.lists.get_size(list_id, force=True)\n</code></pre> <p>This uses the V1 API which returns accurate counts. Results are cached for 5 minutes per list. Use <code>force=True</code> to bypass the cache when you need the most up-to-date value.</p>"},{"location":"guides/performance/#global-personscompanies-no-direct-method","title":"Global persons/companies (no direct method)","text":"<p>The Affinity API does not provide a count endpoint for global persons or companies. A <code>count()</code> method was intentionally omitted from the SDK because it would require paginating through all records\u2014potentially hundreds of API calls for large databases.</p> <p>Why this matters:</p> Database size API calls (V2) Approximate time 1,000 entities 10 calls ~1 second 10,000 entities 100 calls ~10 seconds 100,000 entities 1,000 calls ~2 minutes <p>If you need a global count, iterate once and cache the result:</p> <pre><code># One-time count (expensive for large databases)\nperson_count = sum(1 for _ in client.persons.iter())\n</code></pre> <p>Recommended alternatives:</p> <ol> <li>Use lists: Create a list containing your target entities and use <code>client.lists.get_size(list_id)</code></li> <li>Cache externally: Count once and store the result in your application</li> <li>Estimate: If exact counts aren't critical, sample or track changes incrementally</li> </ol>"},{"location":"guides/performance/#next-steps","title":"Next steps","text":"<ul> <li>Pagination</li> <li>Rate limits</li> <li>Errors &amp; retries</li> <li>Configuration</li> </ul>"},{"location":"guides/query-command/","title":"Query Command","text":"<p>The <code>xaffinity query</code> command provides a structured JSON query language for complex data retrieval, filtering, includes, and aggregations.</p>"},{"location":"guides/query-command/#when-to-use-query-vs-individual-commands","title":"When to Use Query vs Individual Commands","text":"<p>Use <code>query</code> when you need: - Complex filtering with multiple AND/OR/NOT conditions - Related entity data (include companies with persons) - Aggregations (count, sum, avg, groupBy) - Multi-field sorting - Analysis across large datasets</p> <p>Use individual commands for: - Simple lookups (<code>person get 123</code>) - Basic searches (<code>company ls --query \"Acme\"</code>) - Quick exports (<code>list export Pipeline</code>)</p>"},{"location":"guides/query-command/#basic-usage","title":"Basic Usage","text":"<pre><code># From file\nxaffinity query --file query.json\n\n# Inline JSON\nxaffinity query --query '{\"from\": \"persons\", \"limit\": 10}'\n\n# From stdin (piped)\necho '{\"from\": \"persons\"}' | xaffinity query\n\n# Dry-run to preview execution plan\nxaffinity query --file query.json --dry-run\n</code></pre>"},{"location":"guides/query-command/#query-structure","title":"Query Structure","text":"<p>A minimal query requires only the <code>from</code> field:</p> <pre><code>{\n  \"from\": \"persons\"\n}\n</code></pre> <p>A complete query can include:</p> <pre><code>{\n  \"$version\": \"1.0\",\n  \"from\": \"persons\",\n  \"where\": { \"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.com\" },\n  \"include\": [\"companies\"],\n  \"select\": [\"id\", \"firstName\", \"lastName\", \"email\"],\n  \"orderBy\": [{ \"field\": \"lastName\", \"direction\": \"asc\" }],\n  \"limit\": 100\n}\n</code></pre>"},{"location":"guides/query-command/#supported-entity-types","title":"Supported Entity Types","text":"Entity Description Query Type <code>persons</code> People in your CRM Direct query <code>companies</code> Companies/organizations Direct query <code>opportunities</code> Deals/opportunities Direct query <code>lists</code> Affinity list definitions Direct query <code>listEntries</code> Entries in Affinity lists Requires <code>listId</code> or <code>listName</code> filter <code>interactions</code> Emails, calls, meetings Include only (cannot query directly) <code>notes</code> Notes on entities Include only (cannot query directly)"},{"location":"guides/query-command/#entity-query-limitations","title":"Entity Query Limitations","text":"<p><code>listEntries</code> requires a <code>listId</code> or <code>listName</code> filter to specify which list to query:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": { \"path\": \"listId\", \"op\": \"eq\", \"value\": 12345 },\n  \"limit\": 100\n}\n</code></pre> <p>Or using list name (resolved automatically):</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": { \"path\": \"listName\", \"op\": \"eq\", \"value\": \"My Pipeline\" },\n  \"limit\": 100\n}\n</code></pre> <p>Field name resolution: When filtering on <code>fields.*</code>, you can use human-readable field names instead of field IDs:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\n    \"and\": [\n      { \"path\": \"listName\", \"op\": \"eq\", \"value\": \"My Pipeline\" },\n      { \"path\": \"fields.Status\", \"op\": \"eq\", \"value\": \"Active\" }\n    ]\n  }\n}\n</code></pre> <p>Field names are resolved case-insensitively. If a field name is not found, it passes through unchanged (allowing numeric field IDs like <code>fields.12345</code> to work).</p> <p><code>interactions</code> and <code>notes</code> cannot be queried directly. Instead, include them on a parent entity:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"include\": [\"interactions\", \"notes\"],\n  \"limit\": 50\n}\n</code></pre> <p>Attempting to query <code>interactions</code> or <code>notes</code> directly will return an error: <pre><code>QueryParseError: 'interactions' cannot be queried directly.\nUse it as an 'include' on a parent entity instead.\nExample: {\"from\": \"persons\", \"include\": [\"interactions\"]}\n</code></pre></p>"},{"location":"guides/query-command/#filtering-with-where","title":"Filtering with WHERE","text":""},{"location":"guides/query-command/#simple-conditions","title":"Simple Conditions","text":"<pre><code>{\n  \"from\": \"persons\",\n  \"where\": { \"path\": \"email\", \"op\": \"contains\", \"value\": \"@gmail.com\" }\n}\n</code></pre>"},{"location":"guides/query-command/#supported-operators","title":"Supported Operators","text":"Operator Description Example Value <code>eq</code> Equals <code>\"Active\"</code> <code>neq</code> Not equals <code>\"Closed\"</code> <code>gt</code> Greater than <code>10000</code> <code>gte</code> Greater than or equal <code>10000</code> <code>lt</code> Less than <code>5000</code> <code>lte</code> Less than or equal <code>5000</code> <code>contains</code> Contains substring <code>\"@gmail\"</code> <code>starts_with</code> Starts with <code>\"Acme\"</code> <code>in</code> Value in list <code>[\"New\", \"Active\"]</code> <code>between</code> Value in range <code>[1000, 5000]</code> <code>is_null</code> Field is null (no value needed) <code>is_not_null</code> Field is not null (no value needed) <code>contains_any</code> String contains any substring (case-insensitive) <code>[\"vip\", \"hot\"]</code> <code>contains_all</code> String contains all substrings (case-insensitive) <code>[\"verified\", \"active\"]</code> <code>has_any</code> Array contains any of the values <code>[\"LB\", \"MA\"]</code> <code>has_all</code> Array contains all of the values <code>[\"LB\", \"MA\"]</code>"},{"location":"guides/query-command/#multi-select-field-filtering","title":"Multi-Select Field Filtering","text":"<p>Multi-select dropdown fields (like \"Team Member\") return arrays from the API. The query engine handles these automatically:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\n    \"and\": [\n      { \"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\" },\n      { \"path\": \"fields.Team Member\", \"op\": \"eq\", \"value\": \"LB\" }\n    ]\n  }\n}\n</code></pre> <p>Operator behavior with array fields:</p> Operator Single-value field Multi-select field <code>eq</code> Exact match Scalar: membership check / List: set equality <code>neq</code> Not equal Scalar: not in array / List: set inequality <code>in</code> Value in list Any intersection between arrays <code>has_any</code> Returns false Any specified value present <code>has_all</code> Returns false All specified values present <p>Examples:</p> <pre><code>// Find entries where Team Member includes \"LB\"\n{ \"path\": \"fields.Team Member\", \"op\": \"eq\", \"value\": \"LB\" }\n\n// Find entries where Team Member is exactly [\"LB\", \"MA\"] (order-insensitive)\n{ \"path\": \"fields.Team Member\", \"op\": \"eq\", \"value\": [\"LB\", \"MA\"] }\n\n// Find entries where Team Member includes any of [\"LB\", \"DW\"]\n{ \"path\": \"fields.Team Member\", \"op\": \"has_any\", \"value\": [\"LB\", \"DW\"] }\n\n// Find entries where Team Member includes both \"LB\" and \"MA\"\n{ \"path\": \"fields.Team Member\", \"op\": \"has_all\", \"value\": [\"LB\", \"MA\"] }\n</code></pre> <p>Note: Array operators are case-sensitive because dropdown values from the Affinity API are exact matches.</p>"},{"location":"guides/query-command/#compound-conditions","title":"Compound Conditions","text":"<p>AND:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": {\n    \"and\": [\n      { \"path\": \"email\", \"op\": \"is_not_null\" },\n      { \"path\": \"firstName\", \"op\": \"starts_with\", \"value\": \"J\" }\n    ]\n  }\n}\n</code></pre> <p>OR:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": {\n    \"or\": [\n      { \"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.com\" },\n      { \"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.io\" }\n    ]\n  }\n}\n</code></pre> <p>NOT:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": {\n    \"not\": { \"path\": \"status\", \"op\": \"eq\", \"value\": \"Inactive\" }\n  }\n}\n</code></pre>"},{"location":"guides/query-command/#field-paths","title":"Field Paths","text":"<p>Access nested fields with dot notation:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": { \"path\": \"fields.Status\", \"op\": \"eq\", \"value\": \"Active\" }\n}\n</code></pre> <p>Array access:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": { \"path\": \"emails[0]\", \"op\": \"contains\", \"value\": \"@\" }\n}\n</code></pre>"},{"location":"guides/query-command/#date-filtering","title":"Date Filtering","text":"<p>Relative dates:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\n    \"and\": [\n      { \"path\": \"listName\", \"op\": \"eq\", \"value\": \"Pipeline\" },\n      { \"path\": \"createdAt\", \"op\": \"gte\", \"value\": \"-30d\" }\n    ]\n  }\n}\n</code></pre> Format Meaning <code>-30d</code> 30 days ago <code>+7d</code> 7 days from now <code>today</code> Start of today <code>now</code> Current time <code>yesterday</code> Start of yesterday <code>tomorrow</code> Start of tomorrow"},{"location":"guides/query-command/#including-related-entities","title":"Including Related Entities","text":"<p>Fetch related entities in a single query:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"include\": [\"companies\", \"opportunities\"],\n  \"limit\": 50\n}\n</code></pre>"},{"location":"guides/query-command/#available-relationships","title":"Available Relationships","text":"From Can Include <code>persons</code> <code>companies</code>, <code>opportunities</code>, <code>interactions</code>, <code>notes</code> <code>companies</code> <code>persons</code>, <code>opportunities</code>, <code>interactions</code>, <code>notes</code> <code>opportunities</code> <code>persons</code>, <code>companies</code>, <code>interactions</code>, <code>notes</code> <code>listEntries</code> <code>persons</code>, <code>companies</code>, <code>opportunities</code>, <code>interactions</code> <p>Note: For <code>listEntries</code>, the include dynamically resolves based on the entry's entity type (person, company, or opportunity). For example, company entries can include <code>persons</code> (associated persons) and <code>interactions</code> (company interactions).</p> <p>Note: Includes fetch relationship IDs in parallel (N calls), then batch-fetch full records via V2 API. Use <code>--dry-run</code> to preview the cost.</p>"},{"location":"guides/query-command/#parameterized-includes","title":"Parameterized Includes","text":"<p>For <code>listEntries</code>, you can customize includes with parameters:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": { \"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\" },\n  \"include\": [\n    { \"interactions\": { \"limit\": 50, \"days\": 180 } },\n    { \"opportunities\": { \"list\": \"Pipeline\" } },\n    { \"persons\": { \"where\": { \"path\": \"firstName\", \"op\": \"contains\", \"value\": \"John\" } } }\n  ]\n}\n</code></pre> Parameter Description Applicable To <code>limit</code> Maximum records to fetch <code>interactions</code> <code>days</code> Lookback period in days <code>interactions</code> <code>list</code> Scope to specific opportunity list <code>opportunities</code> <code>where</code> Filter included entities <code>persons</code>, <code>companies</code>, <code>opportunities</code> <p>In table output, included data appears as separate tables (e.g., \"Included: companies\"). In JSON output, included data appears in a separate <code>included</code> section with deduplicated records.</p>"},{"location":"guides/query-command/#expanding-computed-data","title":"Expanding Computed Data","text":"<p>Use <code>expand</code> to add computed data directly to each record (unlike <code>include</code> which fetches separate entities).</p>"},{"location":"guides/query-command/#interaction-dates","title":"Interaction Dates","text":"<p>Add interaction date summaries to records:</p> <pre><code>{\n  \"from\": \"companies\",\n  \"expand\": [\"interactionDates\"],\n  \"limit\": 50\n}\n</code></pre> <p>Output includes interaction summaries on each record:</p> <pre><code>{\n  \"id\": 123,\n  \"name\": \"Acme Corp\",\n  \"interactionDates\": {\n    \"lastMeeting\": { \"date\": \"2026-01-08T10:00:00Z\", \"daysSince\": 5 },\n    \"nextMeeting\": { \"date\": \"2026-01-20T14:00:00Z\", \"daysUntil\": 7 },\n    \"lastEmail\": { \"date\": \"2026-01-10T09:30:00Z\", \"daysSince\": 3 }\n  }\n}\n</code></pre>"},{"location":"guides/query-command/#available-expansions","title":"Available Expansions","text":"Expansion Description Supported Entities <code>interactionDates</code> Last/next meeting, email dates <code>persons</code>, <code>companies</code>, <code>opportunities</code>, <code>listEntries</code> <code>unreplied</code> Detect unreplied incoming messages (email/chat) <code>persons</code>, <code>companies</code>, <code>opportunities</code>, <code>listEntries</code>"},{"location":"guides/query-command/#unreplied-messages-expansion","title":"Unreplied Messages Expansion","text":"<p>Add unreplied message detection to each record:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": { \"path\": \"listName\", \"op\": \"eq\", \"value\": \"Pipeline\" },\n  \"expand\": [\"unreplied\"],\n  \"limit\": 50\n}\n</code></pre> <p>Output includes unreplied message info on each record:</p> <pre><code>{\n  \"id\": 123,\n  \"entity\": { \"id\": 456, \"type\": \"company\", \"name\": \"Acme Corp\" },\n  \"unreplied\": {\n    \"date\": \"2026-01-15T09:30:00Z\",\n    \"daysSince\": 4,\n    \"type\": \"email\",\n    \"subject\": \"Re: Partnership opportunity\"\n  }\n}\n</code></pre> <p>Records without unreplied messages have <code>\"unreplied\": null</code>. For chat messages, <code>subject</code> is <code>null</code>.</p>"},{"location":"guides/query-command/#expand-vs-include","title":"Expand vs Include","text":"Feature <code>include</code> <code>expand</code> Purpose Fetch related entities Add computed data Output Separate records Merged into each record Example Related company records Dates, counts, summaries <p>Warning: Expand also causes N+1 API calls. For large datasets, consider using <code>list export --expand interactions</code> for streaming output.</p>"},{"location":"guides/query-command/#aggregations","title":"Aggregations","text":""},{"location":"guides/query-command/#basic-aggregates","title":"Basic Aggregates","text":"<pre><code>{\n  \"from\": \"opportunities\",\n  \"aggregate\": {\n    \"total\": { \"count\": true },\n    \"totalValue\": { \"sum\": \"amount\" },\n    \"avgValue\": { \"avg\": \"amount\" }\n  }\n}\n</code></pre>"},{"location":"guides/query-command/#group-by","title":"Group By","text":"<pre><code>{\n  \"from\": \"opportunities\",\n  \"groupBy\": \"status\",\n  \"aggregate\": {\n    \"count\": { \"count\": true },\n    \"totalValue\": { \"sum\": \"amount\" }\n  }\n}\n</code></pre>"},{"location":"guides/query-command/#having-filter-aggregated-results","title":"Having (Filter Aggregated Results)","text":"<pre><code>{\n  \"from\": \"opportunities\",\n  \"groupBy\": \"status\",\n  \"aggregate\": {\n    \"count\": { \"count\": true }\n  },\n  \"having\": { \"path\": \"count\", \"op\": \"gte\", \"value\": 5 }\n}\n</code></pre>"},{"location":"guides/query-command/#sorting","title":"Sorting","text":"<pre><code>{\n  \"from\": \"persons\",\n  \"orderBy\": [\n    { \"field\": \"lastName\", \"direction\": \"asc\" },\n    { \"field\": \"firstName\", \"direction\": \"asc\" }\n  ]\n}\n</code></pre>"},{"location":"guides/query-command/#limiting-results","title":"Limiting Results","text":"<pre><code>{\n  \"from\": \"persons\",\n  \"limit\": 100\n}\n</code></pre>"},{"location":"guides/query-command/#dry-run-mode","title":"Dry-Run Mode","text":"<p>Always preview expensive queries first:</p> <pre><code>xaffinity query --file query.json --dry-run\n</code></pre> <p>Output shows:</p> <pre><code>Query Execution Plan\n\nQuery:\n  $version: 1.0\n  from: persons\n  include: [companies]\n  limit: 100\n\nSteps:\n  [1] FETCH persons (1 API call)\n  [2] FILTER (client-side)\n  [3] INCLUDE companies (up to 100 API calls)\n  [4] LIMIT 100\n\nEstimated:\n  API Calls: 101\n  Records: 100\n\n[warning] Include 'companies' will make N API calls (1 per person).\n</code></pre>"},{"location":"guides/query-command/#output-formats","title":"Output Formats","text":"<pre><code># Table (default for interactive)\nxaffinity query --file query.json\n\n# JSON output\nxaffinity query --file query.json --json\n\n# CSV output\nxaffinity query --file query.json --csv\n\n# JSON with metadata\nxaffinity query --file query.json --json --include-meta\n</code></pre>"},{"location":"guides/query-command/#command-options","title":"Command Options","text":"Option Description <code>--file</code>, <code>-f</code> Read query from JSON file <code>--query</code> Inline JSON query string <code>--query-version</code> Override <code>$version</code> in query <code>--dry-run</code> Show execution plan without running <code>--dry-run-verbose</code> Show detailed plan with API call breakdown <code>--confirm</code> Require confirmation before expensive operations <code>--max-records</code> Safety limit on total records (default: 10000) <code>--timeout</code> Overall timeout in seconds (default: 300) <code>--json</code> Output as JSON (alias for <code>--output json</code>) <code>--csv</code> Output as CSV (alias for <code>--output csv</code>) <code>--output</code> Output format: table, json, csv <code>--include-meta</code> Include execution metadata in output <code>--quiet</code>, <code>-q</code> Suppress progress output <code>--verbose</code>, <code>-v</code> Show detailed progress"},{"location":"guides/query-command/#examples","title":"Examples","text":""},{"location":"guides/query-command/#find-vip-contacts-at-tech-companies","title":"Find VIP Contacts at Tech Companies","text":"<pre><code>{\n  \"from\": \"persons\",\n  \"where\": {\n    \"and\": [\n      { \"path\": \"fields.VIP\", \"op\": \"eq\", \"value\": true },\n      { \"path\": \"email\", \"op\": \"is_not_null\" }\n    ]\n  },\n  \"include\": [\"companies\"],\n  \"orderBy\": [{ \"field\": \"lastName\", \"direction\": \"asc\" }],\n  \"limit\": 100\n}\n</code></pre>"},{"location":"guides/query-command/#pipeline-summary-by-status","title":"Pipeline Summary by Status","text":"<pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": { \"path\": \"listId\", \"op\": \"eq\", \"value\": 12345 },\n  \"groupBy\": \"fields.Status\",\n  \"aggregate\": {\n    \"count\": { \"count\": true },\n    \"totalValue\": { \"sum\": \"fields.Deal Value\" }\n  }\n}\n</code></pre>"},{"location":"guides/query-command/#recent-meetings-with-persons","title":"Recent Meetings with Persons","text":"<p>Since interactions cannot be queried directly, fetch persons with their recent interactions included:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"include\": [\n    { \"interactions\": { \"limit\": 50, \"days\": 7 } }\n  ],\n  \"limit\": 100\n}\n</code></pre> <p>Then filter for meetings client-side, or use the CLI with <code>--expand-filter</code> for post-fetch filtering.</p>"},{"location":"guides/query-command/#best-practices","title":"Best Practices","text":"<ol> <li>Start with dry-run for complex queries to see API call estimates</li> <li>Use limit to avoid fetching too much data</li> <li>Be specific with where to reduce client-side filtering</li> <li>Avoid deep includes which cause N+1 API calls</li> <li>Include <code>$version</code> in saved query files for forward compatibility</li> </ol>"},{"location":"guides/query-command/#limitations","title":"Limitations","text":"<ul> <li>All filtering except listEntries field filters happens client-side</li> <li>Includes cause N+1 API calls (1 per parent record)</li> <li>Maximum 10,000 records per query for safety</li> <li>No cross-entity joins (use includes instead)</li> </ul>"},{"location":"guides/rate-limits/","title":"Rate limits","text":"<p>The SDK exposes a version-agnostic rate limit surface via <code>client.rate_limits</code>: - <code>snapshot()</code> is best-effort and does not make network calls. - <code>refresh()</code> makes one request and returns the best available snapshot.</p>"},{"location":"guides/rate-limits/#snapshot-no-network","title":"Snapshot (no network)","text":"<pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    client.companies.list()\n    print(client.rate_limits.snapshot())\n</code></pre>"},{"location":"guides/rate-limits/#refresh-one-request","title":"Refresh (one request)","text":"<pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    limits = client.rate_limits.refresh()\n    print(limits)\n</code></pre>"},{"location":"guides/rate-limits/#handling-429s","title":"Handling 429s","text":"<p>When the API returns 429, the SDK raises <code>RateLimitError</code> (and may retry safe methods). See Errors &amp; retries.</p>"},{"location":"guides/rate-limits/#next-steps","title":"Next steps","text":"<ul> <li>Errors &amp; retries</li> <li>Configuration</li> <li>Troubleshooting</li> </ul>"},{"location":"guides/sync-vs-async/","title":"Sync vs async","text":""},{"location":"guides/sync-vs-async/#sync","title":"Sync","text":"<p>Use <code>Affinity</code>:</p> <pre><code>from affinity import Affinity\n\nwith Affinity(api_key=\"your-api-key\") as client:\n    for person in client.persons.all():\n        print(person.first_name)\n</code></pre>"},{"location":"guides/sync-vs-async/#async","title":"Async","text":"<p>Use <code>AsyncAffinity</code>:</p> <pre><code>from affinity import AsyncAffinity\n\nasync def main() -&gt; None:\n    async with AsyncAffinity(api_key=\"your-api-key\") as client:\n        async for company in client.companies.all():\n            print(company.name)\n</code></pre>"},{"location":"guides/sync-vs-async/#parity","title":"Parity","text":"<p><code>AsyncAffinity</code> mirrors the <code>Affinity</code> service surface area.</p> Service Sync (<code>Affinity</code>) Async (<code>AsyncAffinity</code>) companies \u2705 \u2705 persons \u2705 \u2705 lists \u2705 \u2705 lists.entries \u2705 \u2705 opportunities \u2705 \u2705 tasks \u2705 \u2705 notes \u2705 \u2705 reminders \u2705 \u2705 webhooks \u2705 \u2705 interactions \u2705 \u2705 fields \u2705 \u2705 field_values \u2705 \u2705 field_value_changes \u2705 \u2705 files \u2705 \u2705 relationships \u2705 \u2705 auth \u2705 \u2705 rate_limits \u2705 \u2705 <p>Nested services (like <code>lists.entries</code>) have the same sync/async parity as their parent services.</p>"},{"location":"guides/sync-vs-async/#next-steps","title":"Next steps","text":"<ul> <li>Getting started</li> <li>Examples</li> <li>API versions &amp; routing</li> </ul>"},{"location":"guides/webhooks/","title":"Webhooks","text":"<p>The SDK supports managing webhook subscriptions via the V1 API (<code>client.webhooks</code>). Receiving webhooks is handled by your web server/app.</p>"},{"location":"guides/webhooks/#supported-webhook-events","title":"Supported Webhook Events","text":"<p>The SDK defines all webhook events in <code>WebhookEvent</code>. You can subscribe to any combination of these events:</p> Event Value Description <code>LIST_CREATED</code> <code>list.created</code> A new list was created <code>LIST_UPDATED</code> <code>list.updated</code> A list's properties were modified <code>LIST_DELETED</code> <code>list.deleted</code> A list was deleted <code>LIST_ENTRY_CREATED</code> <code>list_entry.created</code> An entity was added to a list <code>LIST_ENTRY_DELETED</code> <code>list_entry.deleted</code> An entity was removed from a list <code>NOTE_CREATED</code> <code>note.created</code> A note was created on an entity <code>NOTE_UPDATED</code> <code>note.updated</code> A note's content was modified <code>NOTE_DELETED</code> <code>note.deleted</code> A note was deleted <code>FIELD_CREATED</code> <code>field.created</code> A new field was created <code>FIELD_UPDATED</code> <code>field.updated</code> A field's properties were modified <code>FIELD_DELETED</code> <code>field.deleted</code> A field was deleted <code>FIELD_VALUE_CREATED</code> <code>field_value.created</code> A field value was set on an entity <code>FIELD_VALUE_UPDATED</code> <code>field_value.updated</code> A field value was modified <code>FIELD_VALUE_DELETED</code> <code>field_value.deleted</code> A field value was removed <code>PERSON_CREATED</code> <code>person.created</code> A new person was created <code>PERSON_UPDATED</code> <code>person.updated</code> A person's properties were modified <code>PERSON_DELETED</code> <code>person.deleted</code> A person was deleted <code>ORGANIZATION_CREATED</code> <code>organization.created</code> A new company/organization was created <code>ORGANIZATION_UPDATED</code> <code>organization.updated</code> A company's properties were modified <code>ORGANIZATION_DELETED</code> <code>organization.deleted</code> A company was deleted <code>ORGANIZATION_MERGED</code> <code>organization.merged</code> Two companies were merged <code>OPPORTUNITY_CREATED</code> <code>opportunity.created</code> A new opportunity was created <code>OPPORTUNITY_UPDATED</code> <code>opportunity.updated</code> An opportunity's properties were modified <code>OPPORTUNITY_DELETED</code> <code>opportunity.deleted</code> An opportunity was deleted <code>FILE_CREATED</code> <code>file.created</code> A file was uploaded to an entity <code>FILE_DELETED</code> <code>file.deleted</code> A file was deleted <code>REMINDER_CREATED</code> <code>reminder.created</code> A reminder was created <code>REMINDER_UPDATED</code> <code>reminder.updated</code> A reminder's properties were modified <code>REMINDER_DELETED</code> <code>reminder.deleted</code> A reminder was deleted <p>Forward Compatibility</p> <p><code>WebhookEvent</code> extends <code>OpenStrEnum</code>, meaning unknown event types from Affinity are preserved as strings rather than causing errors. This ensures the SDK gracefully handles any new events Affinity may add in the future.</p>"},{"location":"guides/webhooks/#create-a-subscription","title":"Create a subscription","text":"<pre><code>from affinity import Affinity\nfrom affinity.models import WebhookCreate\nfrom affinity.types import WebhookEvent\n\nwith Affinity.from_env() as client:\n    webhook = client.webhooks.create(\n        WebhookCreate(\n            webhook_url=\"https://example.com/webhooks/affinity/&lt;random-secret&gt;\",\n            subscriptions=[\n                WebhookEvent.FIELD_VALUE_UPDATED,\n                WebhookEvent.LIST_ENTRY_CREATED,\n            ],\n        )\n    )\n    print(webhook.id, webhook.webhook_url)\n</code></pre> <p>Notes</p> <ul> <li>Affinity limits webhook subscriptions (see <code>WebhookService</code> docs).</li> <li>Affinity may attempt to contact your <code>webhook_url</code> during creation/updates; ensure your endpoint is reachable and responds quickly.</li> </ul>"},{"location":"guides/webhooks/#securing-your-webhook-endpoint","title":"Securing your webhook endpoint","text":"<p>No signature verification available</p> <p>Affinity's V1 API does not provide cryptographic signature verification for webhook requests. There is no HMAC header, signing secret, or other mechanism to verify that requests originate from Affinity. You must rely on defense-in-depth practices to secure your endpoint.</p> <p>Since webhook authenticity cannot be cryptographically verified, treat your webhook endpoint as a semi-public entry point and apply multiple layers of protection:</p>"},{"location":"guides/webhooks/#required-secret-url-path","title":"Required: Secret URL path","text":"<p>Include a long, random, unguessable secret in your webhook URL path:</p> <pre><code>https://example.com/webhooks/affinity/a1b2c3d4e5f6g7h8i9j0...\n</code></pre> <ul> <li>Generate at least 32 characters of cryptographically random data</li> <li>Reject any request where the path secret doesn't match</li> <li>Rotate the secret periodically and after any suspected exposure</li> <li>Never log the full URL or share it in plain text</li> </ul>"},{"location":"guides/webhooks/#required-https-only","title":"Required: HTTPS only","text":"<ul> <li>Always use HTTPS for your webhook URL</li> <li>Terminate TLS at your load balancer or reverse proxy</li> <li>Reject HTTP requests at the application level as a fallback</li> </ul>"},{"location":"guides/webhooks/#required-request-validation","title":"Required: Request validation","text":"<ul> <li>Method: Only accept <code>POST</code> requests</li> <li>Content-Type: Require <code>application/json</code></li> <li>Body size: Enforce a reasonable limit (e.g., 1MB)</li> <li>JSON parsing: Use strict parsing; reject malformed payloads</li> </ul>"},{"location":"guides/webhooks/#recommended-replay-protection","title":"Recommended: Replay protection","text":"<p>Use the <code>sent_at</code> field in the webhook payload to reject stale events:</p> <pre><code>from affinity import parse_webhook\nfrom affinity.exceptions import WebhookInvalidSentAtError\n\ntry:\n    # Reject events older than 5 minutes (300 seconds)\n    envelope = parse_webhook(raw_body, max_age_seconds=300)\nexcept WebhookInvalidSentAtError:\n    # Event is too old or too far in the future\n    return Response(status=400)\n</code></pre> <p>For stronger replay protection, store a short-lived dedupe key:</p> <pre><code>import hashlib\n\n# Generate a dedupe key from event properties\ndedupe_key = f\"{envelope.type}:{envelope.sent_at_epoch}:{hashlib.sha256(raw_body).hexdigest()[:16]}\"\n\n# Check against a cache (Redis, memcached, etc.) with 5-10 minute TTL\nif cache.exists(dedupe_key):\n    return Response(status=200)  # Already processed, acknowledge silently\ncache.set(dedupe_key, \"1\", ttl=600)\n</code></pre>"},{"location":"guides/webhooks/#recommended-ip-allowlisting","title":"Recommended: IP allowlisting","text":"<p>If Affinity provides stable egress IP ranges for your account:</p> <ul> <li>Configure your load balancer or WAF to only accept webhook traffic from those IPs</li> <li>Contact Affinity support to request their webhook delivery IP ranges</li> </ul> <p>If IP ranges are not available:</p> <ul> <li>Restrict by geography or ASN where appropriate</li> <li>Alert on unexpected source IPs for investigation</li> <li>Apply rate limiting and bot protection at the edge</li> </ul>"},{"location":"guides/webhooks/#recommended-fast-response-with-async-processing","title":"Recommended: Fast response with async processing","text":"<ul> <li>Respond with <code>2xx</code> immediately after basic validation</li> <li>Enqueue the actual processing for async handling</li> <li>Assume retries can happen (Affinity retries with exponential backoff for up to 10 hours)</li> <li>Make your processing idempotent using the dedupe key pattern above</li> </ul>"},{"location":"guides/webhooks/#recommended-logging-considerations","title":"Recommended: Logging considerations","text":"<ul> <li>Avoid logging raw webhook payloads (may contain PII)</li> <li>If logging is required, redact sensitive fields or use a PII-safe pipeline</li> <li>Log the event type, timestamp, and dedupe key for debugging</li> </ul>"},{"location":"guides/webhooks/#parse-inbound-payloads-optional","title":"Parse inbound payloads (optional)","text":"<p>The SDK includes small, framework-agnostic helpers to parse the webhook envelope and (optionally) dispatch to a typed body for a few common events.</p> <pre><code>from affinity import dispatch_webhook, parse_webhook\nfrom affinity.types import WebhookEvent\n\nenvelope = parse_webhook(raw_body_bytes)  # or raw str / dict\nevent = dispatch_webhook(envelope)  # typed for some events, dict otherwise\n\nif event.type == WebhookEvent.LIST_ENTRY_CREATED:\n    # event.body may be typed (or a dict, depending on the event)\n    print(event.sent_at, event.body)\n</code></pre>"},{"location":"guides/webhooks/#minimal-receiver-example-fastapi","title":"Minimal receiver example (FastAPI)","text":"<pre><code>import hashlib\nimport secrets\n\nfrom fastapi import FastAPI, HTTPException, Header, Request\n\nfrom affinity import dispatch_webhook, parse_webhook\nfrom affinity.exceptions import WebhookInvalidSentAtError, WebhookParseError\n\napp = FastAPI()\n\n# Generate with: secrets.token_urlsafe(32)\nWEBHOOK_SECRET = \"replace-with-a-long-random-string-at-least-32-chars\"\n\n\n@app.post(\"/webhooks/affinity/{secret}\")\nasync def affinity_webhook(\n    secret: str,\n    request: Request,\n    content_type: str = Header(default=\"\"),\n) -&gt; dict[str, str]:\n    # 1. Validate secret path\n    if not secrets.compare_digest(secret, WEBHOOK_SECRET):\n        raise HTTPException(status_code=404)  # 404 to avoid confirming endpoint exists\n\n    # 2. Validate content type\n    if not content_type.startswith(\"application/json\"):\n        raise HTTPException(status_code=415, detail=\"unsupported media type\")\n\n    # 3. Read and validate body size\n    raw = await request.body()\n    if len(raw) &gt; 1_000_000:  # 1MB limit\n        raise HTTPException(status_code=413, detail=\"payload too large\")\n\n    # 4. Parse with replay protection (rejects events older than 5 minutes)\n    try:\n        envelope = parse_webhook(raw, max_age_seconds=300)\n    except WebhookInvalidSentAtError:\n        raise HTTPException(status_code=400, detail=\"stale event\")\n    except WebhookParseError:\n        raise HTTPException(status_code=400, detail=\"invalid payload\")\n\n    # 5. Optional: Check dedupe key against cache here\n\n    # 6. Dispatch to typed body (if registered) and process\n    event = dispatch_webhook(envelope)\n\n    # TODO: Enqueue for async processing instead of processing inline\n    # process_webhook_event.delay(event)\n\n    return {\"ok\": \"true\"}\n</code></pre>"},{"location":"mcp/","title":"MCP Server","text":"<p>The xaffinity MCP server connects desktop AI tools to Affinity CRM.</p>"},{"location":"mcp/#compatible-clients","title":"Compatible Clients","text":"<p>MCP (Model Context Protocol) is an open standard. This server works with:</p> <ul> <li>Claude Desktop (Anthropic)</li> <li>ChatGPT Desktop (OpenAI)</li> <li>Cursor (AI IDE)</li> <li>Windsurf (AI IDE)</li> <li>Zed (AI-native editor)</li> <li>VS Code + GitHub Copilot</li> <li>Continue (open-source AI assistant)</li> <li>JetBrains IDEs (via MCP support)</li> <li>Any desktop application supporting MCP stdio transport</li> </ul>"},{"location":"mcp/#features","title":"Features","text":"<ul> <li>Entity Search - Find persons, companies, opportunities</li> <li>Query Language - Complex queries with filtering, includes, and aggregations</li> <li>Relationship Intelligence - Strength scores, warm intro paths</li> <li>Workflow Management - Update pipeline status, manage list entries</li> <li>Interaction Logging - Log calls, meetings, emails</li> <li>Meeting Prep - Comprehensive briefings before meetings</li> </ul>"},{"location":"mcp/#installation-options","title":"Installation Options","text":""},{"location":"mcp/#option-1-mcpb-bundle-for-claude-desktop-recommended","title":"Option 1: MCPB Bundle for Claude Desktop (Recommended)","text":"<p>The easiest installation method - download and double-click:</p> <ol> <li> <p>Install the CLI first: <pre><code>pipx install \"affinity-sdk[cli]\"\n</code></pre></p> </li> <li> <p>(Optional) Pre-configure your API key: <pre><code>xaffinity config setup-key\n</code></pre>    If you skip this step, Claude Desktop will prompt for your API key during MCPB installation.</p> </li> <li> <p>Download <code>xaffinity-mcp-X.Y.Z.mcpb</code> from GitHub Releases</p> </li> <li> <p>Double-click the file or drag it to Claude Desktop</p> </li> </ol> <p>The MCPB bundle is self-contained (includes MCP framework and JSON processor) but requires the CLI to be installed separately.</p> <p>MCPB support</p> <p>MCPB bundles currently only work with Claude Desktop. Other clients require manual configuration (see below).</p>"},{"location":"mcp/#option-2-manual-configuration","title":"Option 2: Manual Configuration","text":"<p>For Cursor, Windsurf, VS Code + Copilot, Zed, and other MCP clients:</p> <p>Prerequisites:</p> <ol> <li>Install the CLI (choose one):</li> </ol> <pre><code># Recommended: isolated installation with pipx\npipx install \"affinity-sdk[cli]\"\n\n# Alternative: install in a virtualenv\npip install \"affinity-sdk[cli]\"\n</code></pre> <p>Why pipx?</p> <p><code>pipx</code> installs CLI tools in isolated environments, avoiding dependency conflicts. See pipx.pypa.io for installation.</p> <ol> <li>Configure your API key:</li> </ol> <pre><code>xaffinity config setup-key\n</code></pre> <ol> <li>Verify configuration:</li> </ol> <pre><code>xaffinity config check-key\n</code></pre>"},{"location":"mcp/#client-configuration","title":"Client Configuration","text":"<p>For manual installation, add the MCP server to your client's configuration.</p> <p>Finding the MCP server path</p> <p>If you installed the MCPB bundle, the server is at: <pre><code>~/Library/Application Support/Claude/Claude Extensions/local.mcpb.yaniv-golan.xaffinity-mcp/server/xaffinity-mcp.sh\n</code></pre></p> <p>If you cloned the repo, use the path to your clone: <pre><code>/path/to/your/affinity-sdk/mcp/xaffinity-mcp.sh\n</code></pre></p>"},{"location":"mcp/#claude-desktop","title":"Claude Desktop","text":"<p>Edit <code>~/Library/Application Support/Claude/claude_desktop_config.json</code> (macOS) or <code>%APPDATA%\\Claude\\claude_desktop_config.json</code> (Windows):</p> <pre><code>{\n  \"mcpServers\": {\n    \"xaffinity\": {\n      \"command\": \"/path/to/xaffinity-mcp.sh\"\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/#cursor-windsurf","title":"Cursor / Windsurf","text":"<p>Add to your MCP configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"xaffinity\": {\n      \"command\": \"/path/to/xaffinity-mcp.sh\"\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/#vs-code-github-copilot","title":"VS Code + GitHub Copilot","text":"<p>Add to your MCP settings:</p> <pre><code>{\n  \"mcpServers\": {\n    \"xaffinity\": {\n      \"command\": \"/path/to/xaffinity-mcp.sh\"\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/#generic-mcp-client","title":"Generic MCP Client","text":"<p>Any MCP client supporting stdio transport can connect using:</p> <pre><code>{\n  \"mcpServers\": {\n    \"xaffinity\": {\n      \"command\": \"/path/to/xaffinity-mcp.sh\"\n    }\n  }\n}\n</code></pre> <p>Replace <code>/path/to/xaffinity-mcp.sh</code> with the actual path (see tip above).</p>"},{"location":"mcp/#available-tools-7","title":"Available Tools (7)","text":"<p>The MCP server exposes 7 native tools. Most CRM operations are accessed through the CLI gateway tools, which provide access to the full <code>xaffinity</code> CLI.</p>"},{"location":"mcp/#native-mcp-tools","title":"Native MCP Tools","text":"Tool Description <code>discover-commands</code> Search CLI commands by keyword (e.g., \"create person\", \"delete note\") <code>execute-read-command</code> Execute read-only CLI commands (get, search, list, export) <code>execute-write-command</code> Execute write CLI commands (create, update, delete) <code>query</code> Execute structured JSON queries with filtering, includes, and aggregations <code>get-entity-dossier</code> Comprehensive entity info: details, relationship strength, interactions, notes, list memberships <code>get-file-url</code> Get presigned URL to access a file attachment <code>read-xaffinity-resource</code> Access dynamic resources via <code>xaffinity://</code> URIs"},{"location":"mcp/#cli-gateway-pattern","title":"CLI Gateway Pattern","text":"<p>The <code>discover-commands</code>, <code>execute-read-command</code>, and <code>execute-write-command</code> tools provide access to the full xaffinity CLI:</p> <ol> <li> <p>Discover the right command:    <pre><code>{\"query\": \"add person to list\", \"category\": \"write\"}\n</code></pre></p> </li> <li> <p>Execute the command:    <pre><code>{\"command\": \"list entry add\", \"argv\": [\"Pipeline\", \"--person-id\", \"123\"]}\n</code></pre></p> </li> </ol> <p>Destructive commands (delete operations) require explicit confirmation: <pre><code>{\"command\": \"person delete\", \"argv\": [\"456\"], \"confirm\": true}\n</code></pre></p>"},{"location":"mcp/#common-cli-operations-via-gateway","title":"Common CLI Operations (via gateway)","text":"<p>These operations are available through <code>execute-read-command</code> and <code>execute-write-command</code>:</p> <p>Search &amp; Lookup (read-only)</p> CLI Command Description <code>person ls</code>, <code>company ls</code> Search persons, companies by name/email <code>list ls</code> Find Affinity lists by name <code>list export &lt;name&gt;</code> Export list entries with custom fields <code>interaction ls</code> Interaction history (calls, meetings, emails) for an entity <p>Workflow Management</p> CLI Command Description <code>list get &lt;name&gt;</code> Get workflow config (statuses, fields, saved views) for a list <code>entry field &lt;list&gt; &lt;id&gt;</code> Update fields on a list entry (write) <p>Logging (write operations)</p> CLI Command Description <code>note create</code> Add note to a person, company, or opportunity (write) <code>interaction create</code> Log call, meeting, email, or chat message (write)"},{"location":"mcp/#guided-workflows-8-prompts","title":"Guided Workflows (8 Prompts)","text":"<p>MCP prompts provide guided multi-step workflows.</p>"},{"location":"mcp/#read-only-prompts","title":"Read-Only Prompts","text":"Prompt Use Case <code>prepare-briefing</code> Before a meeting - get full context on a person/company <code>pipeline-review</code> Weekly/monthly pipeline review <code>warm-intro</code> Find introduction paths to someone <code>interaction-brief</code> Get interaction history summary for an entity"},{"location":"mcp/#write-prompts","title":"Write Prompts","text":"Prompt Use Case <code>log-interaction-and-update-workflow</code> After a call/meeting - log and update pipeline <code>change-status</code> Move a deal to a new stage <code>log-call</code> Quick phone call logging <code>log-message</code> Quick chat/text message logging"},{"location":"mcp/#prompt-invocation","title":"Prompt Invocation","text":"<p>Prompts accept arguments:</p> <pre><code>prepare-briefing(entityName: \"John Smith\", meetingType: \"demo\")\nwarm-intro(targetName: \"Jane Doe\", context: \"partnership discussion\")\nlog-interaction-and-update-workflow(personName: \"Alice\", interactionType: \"call\", summary: \"Discussed pricing\")\n</code></pre>"},{"location":"mcp/#resources","title":"Resources","text":"<p>Access dynamic data via <code>xaffinity://</code> URIs using <code>read-xaffinity-resource</code>:</p> URI Returns <code>xaffinity://data-model</code> Conceptual guide to Affinity's data model (read first!) <code>xaffinity://query-guide</code> Complete query language reference <code>xaffinity://workflows-guide</code> Workflow patterns and best practices <code>xaffinity://me</code> Current authenticated user details <code>xaffinity://me/person-id</code> Current user's person ID in Affinity <code>xaffinity://interaction-enums</code> Valid interaction types and directions <code>xaffinity://saved-views/{listId}</code> Saved views available for a list <code>xaffinity://field-catalogs/{listId}</code> Field definitions for a list or entity type <code>xaffinity://workflow-config/{listId}</code> Workflow configuration for a list"},{"location":"mcp/#common-workflow-patterns","title":"Common Workflow Patterns","text":""},{"location":"mcp/#before-a-meeting","title":"Before a Meeting","text":"<ol> <li><code>person ls</code> or <code>company ls</code> to locate the person/company</li> <li><code>get-entity-dossier</code> for full context (relationship strength, recent interactions, notes)</li> <li>Or use: <code>prepare-briefing</code> prompt for a guided flow</li> </ol>"},{"location":"mcp/#after-a-callmeeting","title":"After a Call/Meeting","text":"<ol> <li><code>interaction create</code> to record what happened</li> <li><code>entry field</code> to update pipeline fields if needed</li> <li>Or use: <code>log-interaction-and-update-workflow</code> prompt</li> </ol>"},{"location":"mcp/#finding-warm-introductions","title":"Finding Warm Introductions","text":"<ol> <li><code>person ls</code> to locate target person</li> <li><code>get-entity-dossier</code> includes relationship strength data</li> <li>Or use: <code>warm-intro</code> prompt for guided flow</li> </ol>"},{"location":"mcp/#pipeline-review","title":"Pipeline Review","text":"<ol> <li><code>list ls</code> to locate the pipeline list</li> <li><code>query</code> tool with listEntries to fetch items with filters</li> <li>Or use: <code>pipeline-review</code> prompt</li> </ol>"},{"location":"mcp/#updating-deal-status","title":"Updating Deal Status","text":"<ol> <li><code>person ls</code> or <code>company ls</code> to find the entity</li> <li><code>list get &lt;name&gt;</code> to see available status options</li> <li><code>entry field</code> to update the status field</li> <li>Or use: <code>change-status</code> prompt</li> </ol>"},{"location":"mcp/#configuration","title":"Configuration","text":""},{"location":"mcp/#read-only-mode","title":"Read-Only Mode","text":"<p>Restrict to read-only tools:</p> <pre><code>AFFINITY_MCP_READ_ONLY=1 ./xaffinity-mcp.sh\n</code></pre>"},{"location":"mcp/#disable-destructive-commands","title":"Disable Destructive Commands","text":"<p>Allow write operations but block delete commands via CLI Gateway:</p> <pre><code>AFFINITY_MCP_DISABLE_DESTRUCTIVE=1 ./xaffinity-mcp.sh\n</code></pre>"},{"location":"mcp/#cache-ttl","title":"Cache TTL","text":"<p>Adjust cache duration (default 10 minutes):</p> <pre><code>AFFINITY_SESSION_CACHE_TTL=300 ./xaffinity-mcp.sh\n</code></pre>"},{"location":"mcp/#debug-mode","title":"Debug Mode","text":"<p>Enable comprehensive logging for troubleshooting:</p> <pre><code># Full debug mode - enables all debug features\nMCPBASH_LOG_LEVEL=debug ./xaffinity-mcp.sh\n\n# Test a single tool with debug output\nMCPBASH_LOG_LEVEL=debug mcp-bash run-tool find-entities --args '{\"query\":\"acme\"}' --verbose\n\n# Enable shell tracing for deep debugging\nMCPBASH_TRACE_TOOLS=true mcp-bash run-tool get-entity-dossier --args '{\"entityType\":\"person\",\"entityId\":\"12345\"}'\n</code></pre> Variable Description <code>MCPBASH_LOG_LEVEL=debug</code> Enable mcp-bash framework debug logging <code>XAFFINITY_DEBUG=true</code> Enable xaffinity-specific debug logging <code>MCPBASH_LOG_VERBOSE=true</code> Show paths in logs (exposes file paths) <code>MCPBASH_TRACE_TOOLS=true</code> Enable shell tracing (<code>set -x</code>) for tools"},{"location":"mcp/#diagnostics","title":"Diagnostics","text":"<p>Run health check:</p> <pre><code>./xaffinity-mcp.sh doctor\n</code></pre>"},{"location":"mcp/#tips","title":"Tips","text":"<ul> <li>Entity types: <code>person</code>, <code>company</code>, <code>opportunity</code></li> <li>Interaction types: <code>call</code>, <code>meeting</code>, <code>email</code>, <code>chat_message</code>, <code>in_person</code></li> <li>Dossier is comprehensive: <code>get-entity-dossier</code> returns relationship strength, interactions, notes, and list memberships in one call</li> <li>Check workflow config: Use <code>list get &lt;name&gt;</code> to discover valid status options and saved views before updating</li> <li>Start with data-model: Read <code>xaffinity://data-model</code> to understand when to use <code>company ls</code> vs <code>list export</code></li> </ul>"},{"location":"mcp/#claude-code-installation","title":"Claude Code Installation","text":"<p>Using Claude Code? You can also install via the plugin marketplace:</p> <pre><code>/plugin marketplace add yaniv-golan/affinity-sdk\n/plugin install mcp@xaffinity\n</code></pre> <p>This installs the MCP server automatically. See Claude Code plugins for additional Claude-specific features.</p>"},{"location":"mcp/#discoverability","title":"Discoverability","text":""},{"location":"mcp/#mcpb-distribution","title":"MCPB Distribution","text":"<p>This server is distributed as an MCPB bundle for one-click installation. Download from GitHub Releases.</p>"},{"location":"mcp/#mcp-registry-planned","title":"MCP Registry (Planned)","text":"<p>We plan to register this server with the MCP Registry\u2014the official catalog for MCP servers.</p>"},{"location":"mcp/#future-well-known-discovery","title":"Future: .well-known Discovery","text":"<p>The MCP protocol is adding standardized discovery via <code>/.well-known/mcp.json</code> endpoints (SEP-1649). This will allow clients to auto-discover server capabilities without connecting first.</p>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#affinity","title":"<code>Affinity</code>","text":"<p>Synchronous Affinity API client.</p> <p>Provides access to all Affinity API functionality with a clean, Pythonic interface. Uses V2 API where available, falls back to V1 for operations not yet supported in V2.</p> Example <pre><code>from affinity import Affinity\n\n# Initialize with API key\nclient = Affinity(api_key=\"your-api-key\")\n\n# Use as context manager for automatic cleanup\nwith Affinity(api_key=\"your-api-key\") as client:\n    # Get all companies\n    for company in client.companies.all():\n        print(company.name)\n\n    # Get a specific person with field data\n    person = client.persons.get(\n        PersonId(12345),\n        field_types=[\"enriched\", \"global\"]\n    )\n\n    # Add a company to a list\n    entries = client.lists.entries(ListId(789))\n    entry = entries.add_company(CompanyId(456))\n\n    # Update field values\n    entries.update_field_value(\n        entry.id,\n        FieldId(101),\n        \"New value\"\n    )\n</code></pre> <p>Attributes:</p> Name Type Description <code>companies</code> <code>CompanyService</code> <p>Company (organization) operations</p> <code>persons</code> <code>PersonService</code> <p>Person (contact) operations</p> <code>lists</code> <code>ListService</code> <p>List operations</p> <code>notes</code> <code>NoteService</code> <p>Note operations</p> <code>reminders</code> <code>ReminderService</code> <p>Reminder operations</p> <code>webhooks</code> <code>WebhookService</code> <p>Webhook subscription operations</p> <code>interactions</code> <code>InteractionService</code> <p>Interaction (email, meeting, etc.) operations</p> <code>fields</code> <code>FieldService</code> <p>Custom field operations</p> <code>field_values</code> <code>FieldValueService</code> <p>Field value operations</p> <code>field_value_changes</code> <code>FieldValueChangesService</code> <p>Field value change history operations</p> <code>files</code> <code>EntityFileService</code> <p>Entity file operations</p> <code>relationships</code> <code>RelationshipStrengthService</code> <p>Relationship strength queries</p> <code>auth</code> <code>AuthService</code> <p>Authentication and rate limit info</p> Source code in <code>affinity/client.py</code> <pre><code>class Affinity:\n    \"\"\"\n    Synchronous Affinity API client.\n\n    Provides access to all Affinity API functionality with a clean,\n    Pythonic interface. Uses V2 API where available, falls back to V1\n    for operations not yet supported in V2.\n\n    Example:\n        ```python\n        from affinity import Affinity\n\n        # Initialize with API key\n        client = Affinity(api_key=\"your-api-key\")\n\n        # Use as context manager for automatic cleanup\n        with Affinity(api_key=\"your-api-key\") as client:\n            # Get all companies\n            for company in client.companies.all():\n                print(company.name)\n\n            # Get a specific person with field data\n            person = client.persons.get(\n                PersonId(12345),\n                field_types=[\"enriched\", \"global\"]\n            )\n\n            # Add a company to a list\n            entries = client.lists.entries(ListId(789))\n            entry = entries.add_company(CompanyId(456))\n\n            # Update field values\n            entries.update_field_value(\n                entry.id,\n                FieldId(101),\n                \"New value\"\n            )\n        ```\n\n    Attributes:\n        companies: Company (organization) operations\n        persons: Person (contact) operations\n        lists: List operations\n        notes: Note operations\n        reminders: Reminder operations\n        webhooks: Webhook subscription operations\n        interactions: Interaction (email, meeting, etc.) operations\n        fields: Custom field operations\n        field_values: Field value operations\n        field_value_changes: Field value change history operations\n        files: Entity file operations\n        relationships: Relationship strength queries\n        auth: Authentication and rate limit info\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: str,\n        *,\n        v1_base_url: str = V1_BASE_URL,\n        v2_base_url: str = V2_BASE_URL,\n        v1_auth_mode: Literal[\"bearer\", \"basic\"] = \"bearer\",\n        transport: httpx.BaseTransport | None = None,\n        async_transport: httpx.AsyncBaseTransport | None = None,\n        enable_beta_endpoints: bool = False,\n        allow_insecure_download_redirects: bool = False,\n        expected_v2_version: str | None = None,\n        timeout: float = 30.0,\n        max_retries: int = 3,\n        enable_cache: bool = False,\n        cache_ttl: float = 300.0,\n        log_requests: bool = False,\n        on_request: RequestHook | None = None,\n        on_response: ResponseHook | None = None,\n        on_error: ErrorHook | None = None,\n        on_event: AnyEventHook | None = None,\n        hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n        policies: Policies | None = None,\n    ):\n        \"\"\"\n        Initialize the Affinity client.\n\n        Args:\n            api_key: Your Affinity API key\n            v1_base_url: V1 API base URL (default: https://api.affinity.co)\n            v2_base_url: V2 API base URL (default: https://api.affinity.co/v2)\n            v1_auth_mode: Auth mode for V1 API (\"bearer\" or \"basic\")\n            transport: Optional `httpx` transport (advanced; useful for mocking in tests)\n            async_transport: Optional async `httpx` transport (advanced; useful for mocking in\n                tests)\n            enable_beta_endpoints: Enable beta V2 endpoints\n            allow_insecure_download_redirects: Allow `http://` redirects for file downloads.\n                Not recommended; prefer HTTPS-only downloads.\n            expected_v2_version: Expected V2 API version for diagnostics (e.g.,\n                \"2024-01-01\"). Used to detect version compatibility issues.\n                See TR-015.\n            timeout: Request timeout in seconds\n            max_retries: Maximum retries for rate-limited requests\n            enable_cache: Enable response caching for field metadata\n            cache_ttl: Cache TTL in seconds\n            log_requests: Log all HTTP requests (for debugging)\n            on_request: Hook called before each request (DX-008)\n            on_response: Hook called after each response (DX-008)\n            on_error: Hook called when a request raises (DX-008)\n            on_event: Event hook called for request/response lifecycle events (DX-008)\n            hook_error_policy: What to do if hooks raise (\"swallow\" or \"raise\")\n            policies: Client policies (e.g., disable writes)\n        \"\"\"\n        config = ClientConfig(\n            api_key=api_key,\n            v1_base_url=v1_base_url,\n            v2_base_url=v2_base_url,\n            v1_auth_mode=v1_auth_mode,\n            transport=transport,\n            async_transport=async_transport,\n            enable_beta_endpoints=enable_beta_endpoints,\n            allow_insecure_download_redirects=allow_insecure_download_redirects,\n            expected_v2_version=expected_v2_version,\n            timeout=timeout,\n            max_retries=max_retries,\n            enable_cache=enable_cache,\n            cache_ttl=cache_ttl,\n            log_requests=log_requests,\n            on_request=on_request,\n            on_response=on_response,\n            on_error=on_error,\n            on_event=on_event,\n            hook_error_policy=hook_error_policy,\n            policies=policies or Policies(),\n        )\n        self._http = HTTPClient(config)\n\n        # Resource management tracking\n        self._closed = False\n        self._entered_context = False\n\n        # Initialize services\n        self._companies: CompanyService | None = None\n        self._persons: PersonService | None = None\n        self._lists: ListService | None = None\n        self._opportunities: OpportunityService | None = None\n        self._tasks: TaskService | None = None\n        self._notes: NoteService | None = None\n        self._reminders: ReminderService | None = None\n        self._webhooks: WebhookService | None = None\n        self._interactions: InteractionService | None = None\n        self._fields: FieldService | None = None\n        self._field_values: FieldValueService | None = None\n        self._field_value_changes: FieldValueChangesService | None = None\n        self._files: EntityFileService | None = None\n        self._relationships: RelationshipStrengthService | None = None\n        self._auth: AuthService | None = None\n        self._rate_limits: RateLimitService | None = None\n\n    @classmethod\n    def from_env(\n        cls,\n        *,\n        env_var: str = _DEFAULT_API_KEY_ENV_VAR,\n        load_dotenv: bool = False,\n        dotenv_path: str | os.PathLike[str] | None = None,\n        dotenv_override: bool = False,\n        transport: httpx.BaseTransport | None = None,\n        async_transport: httpx.AsyncBaseTransport | None = None,\n        policies: Policies | None = None,\n        on_event: AnyEventHook | None = None,\n        hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n        **kwargs: Any,\n    ) -&gt; Affinity:\n        \"\"\"\n        Create a client using an API key from the environment.\n\n        By default, reads `AFFINITY_API_KEY`. For local development, you can optionally\n        load a `.env` file (requires `python-dotenv`).\n        \"\"\"\n        api_key = _api_key_from_env(\n            env_var=env_var,\n            load_dotenv=load_dotenv,\n            dotenv_path=dotenv_path,\n            dotenv_override=dotenv_override,\n        )\n        return cls(\n            api_key=api_key,\n            transport=transport,\n            async_transport=async_transport,\n            policies=policies,\n            on_event=on_event,\n            hook_error_policy=hook_error_policy,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; Affinity:\n        self._entered_context = True\n        return self\n\n    def __exit__(self, *args: Any) -&gt; None:\n        self.close()\n\n    def close(self) -&gt; None:\n        \"\"\"Close the HTTP client and release resources.\"\"\"\n        if not self._closed:\n            self._http.close()\n            self._closed = True\n\n    def __del__(self) -&gt; None:\n        \"\"\"Warn if client was not properly closed.\"\"\"\n        # Use getattr to handle case where __init__ failed before setting _closed\n        if not getattr(self, \"_closed\", True) and not getattr(self, \"_entered_context\", True):\n            warnings.warn(\n                \"Affinity client was not closed. \"\n                \"Use 'with Affinity.from_env() as client:' \"\n                \"or call client.close() when done.\",\n                ResourceWarning,\n                stacklevel=2,\n            )\n            # Still close to prevent actual resource leaks\n            with contextlib.suppress(Exception):\n                self.close()\n\n    # =========================================================================\n    # Service Properties (lazy initialization)\n    # =========================================================================\n\n    @property\n    def companies(self) -&gt; CompanyService:\n        \"\"\"Company (organization) operations.\"\"\"\n        if self._companies is None:\n            self._companies = CompanyService(self._http)\n        return self._companies\n\n    @property\n    def persons(self) -&gt; PersonService:\n        \"\"\"Person (contact) operations.\"\"\"\n        if self._persons is None:\n            self._persons = PersonService(self._http)\n        return self._persons\n\n    @property\n    def lists(self) -&gt; ListService:\n        \"\"\"List operations.\"\"\"\n        if self._lists is None:\n            self._lists = ListService(self._http)\n        return self._lists\n\n    @property\n    def opportunities(self) -&gt; OpportunityService:\n        \"\"\"Opportunity operations.\"\"\"\n        if self._opportunities is None:\n            self._opportunities = OpportunityService(self._http)\n        return self._opportunities\n\n    @property\n    def tasks(self) -&gt; TaskService:\n        \"\"\"Long-running task operations (polling, waiting).\"\"\"\n        if self._tasks is None:\n            self._tasks = TaskService(self._http)\n        return self._tasks\n\n    @property\n    def notes(self) -&gt; NoteService:\n        \"\"\"Note operations.\"\"\"\n        if self._notes is None:\n            self._notes = NoteService(self._http)\n        return self._notes\n\n    @property\n    def reminders(self) -&gt; ReminderService:\n        \"\"\"Reminder operations.\"\"\"\n        if self._reminders is None:\n            self._reminders = ReminderService(self._http)\n        return self._reminders\n\n    @property\n    def webhooks(self) -&gt; WebhookService:\n        \"\"\"Webhook subscription operations.\"\"\"\n        if self._webhooks is None:\n            self._webhooks = WebhookService(self._http)\n        return self._webhooks\n\n    @property\n    def interactions(self) -&gt; InteractionService:\n        \"\"\"Interaction operations.\"\"\"\n        if self._interactions is None:\n            self._interactions = InteractionService(self._http)\n        return self._interactions\n\n    @property\n    def fields(self) -&gt; FieldService:\n        \"\"\"Custom field operations.\"\"\"\n        if self._fields is None:\n            self._fields = FieldService(self._http)\n        return self._fields\n\n    @property\n    def field_values(self) -&gt; FieldValueService:\n        \"\"\"Field value operations.\"\"\"\n        if self._field_values is None:\n            self._field_values = FieldValueService(self._http)\n        return self._field_values\n\n    @property\n    def field_value_changes(self) -&gt; FieldValueChangesService:\n        \"\"\"Field value change history queries.\"\"\"\n        if self._field_value_changes is None:\n            self._field_value_changes = FieldValueChangesService(self._http)\n        return self._field_value_changes\n\n    @property\n    def files(self) -&gt; EntityFileService:\n        \"\"\"Entity file operations.\"\"\"\n        if self._files is None:\n            self._files = EntityFileService(self._http)\n        return self._files\n\n    @property\n    def relationships(self) -&gt; RelationshipStrengthService:\n        \"\"\"Relationship strength queries.\"\"\"\n        if self._relationships is None:\n            self._relationships = RelationshipStrengthService(self._http)\n        return self._relationships\n\n    @property\n    def auth(self) -&gt; AuthService:\n        \"\"\"Authentication info.\"\"\"\n        if self._auth is None:\n            self._auth = AuthService(self._http)\n        return self._auth\n\n    @property\n    def rate_limits(self) -&gt; RateLimitService:\n        \"\"\"Unified rate limit information (version-agnostic).\"\"\"\n        if self._rate_limits is None:\n            self._rate_limits = RateLimitService(self._http)\n        return self._rate_limits\n\n    # =========================================================================\n    # Utility Methods\n    # =========================================================================\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear the response cache.\"\"\"\n        if self._http.cache:\n            self._http.cache.clear()\n\n    def whoami(self) -&gt; WhoAmI:\n        \"\"\"Convenience wrapper for `client.auth.whoami()`.\"\"\"\n        return self.auth.whoami()\n</code></pre>"},{"location":"reference/client/#affinity.Affinity.auth","title":"<code>auth: AuthService</code>  <code>property</code>","text":"<p>Authentication info.</p>"},{"location":"reference/client/#affinity.Affinity.companies","title":"<code>companies: CompanyService</code>  <code>property</code>","text":"<p>Company (organization) operations.</p>"},{"location":"reference/client/#affinity.Affinity.field_value_changes","title":"<code>field_value_changes: FieldValueChangesService</code>  <code>property</code>","text":"<p>Field value change history queries.</p>"},{"location":"reference/client/#affinity.Affinity.field_values","title":"<code>field_values: FieldValueService</code>  <code>property</code>","text":"<p>Field value operations.</p>"},{"location":"reference/client/#affinity.Affinity.fields","title":"<code>fields: FieldService</code>  <code>property</code>","text":"<p>Custom field operations.</p>"},{"location":"reference/client/#affinity.Affinity.files","title":"<code>files: EntityFileService</code>  <code>property</code>","text":"<p>Entity file operations.</p>"},{"location":"reference/client/#affinity.Affinity.interactions","title":"<code>interactions: InteractionService</code>  <code>property</code>","text":"<p>Interaction operations.</p>"},{"location":"reference/client/#affinity.Affinity.lists","title":"<code>lists: ListService</code>  <code>property</code>","text":"<p>List operations.</p>"},{"location":"reference/client/#affinity.Affinity.notes","title":"<code>notes: NoteService</code>  <code>property</code>","text":"<p>Note operations.</p>"},{"location":"reference/client/#affinity.Affinity.opportunities","title":"<code>opportunities: OpportunityService</code>  <code>property</code>","text":"<p>Opportunity operations.</p>"},{"location":"reference/client/#affinity.Affinity.persons","title":"<code>persons: PersonService</code>  <code>property</code>","text":"<p>Person (contact) operations.</p>"},{"location":"reference/client/#affinity.Affinity.rate_limits","title":"<code>rate_limits: RateLimitService</code>  <code>property</code>","text":"<p>Unified rate limit information (version-agnostic).</p>"},{"location":"reference/client/#affinity.Affinity.relationships","title":"<code>relationships: RelationshipStrengthService</code>  <code>property</code>","text":"<p>Relationship strength queries.</p>"},{"location":"reference/client/#affinity.Affinity.reminders","title":"<code>reminders: ReminderService</code>  <code>property</code>","text":"<p>Reminder operations.</p>"},{"location":"reference/client/#affinity.Affinity.tasks","title":"<code>tasks: TaskService</code>  <code>property</code>","text":"<p>Long-running task operations (polling, waiting).</p>"},{"location":"reference/client/#affinity.Affinity.webhooks","title":"<code>webhooks: WebhookService</code>  <code>property</code>","text":"<p>Webhook subscription operations.</p>"},{"location":"reference/client/#affinity.Affinity.__del__","title":"<code>__del__() -&gt; None</code>","text":"<p>Warn if client was not properly closed.</p> Source code in <code>affinity/client.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Warn if client was not properly closed.\"\"\"\n    # Use getattr to handle case where __init__ failed before setting _closed\n    if not getattr(self, \"_closed\", True) and not getattr(self, \"_entered_context\", True):\n        warnings.warn(\n            \"Affinity client was not closed. \"\n            \"Use 'with Affinity.from_env() as client:' \"\n            \"or call client.close() when done.\",\n            ResourceWarning,\n            stacklevel=2,\n        )\n        # Still close to prevent actual resource leaks\n        with contextlib.suppress(Exception):\n            self.close()\n</code></pre>"},{"location":"reference/client/#affinity.Affinity.__init__","title":"<code>__init__(api_key: str, *, v1_base_url: str = V1_BASE_URL, v2_base_url: str = V2_BASE_URL, v1_auth_mode: Literal['bearer', 'basic'] = 'bearer', transport: httpx.BaseTransport | None = None, async_transport: httpx.AsyncBaseTransport | None = None, enable_beta_endpoints: bool = False, allow_insecure_download_redirects: bool = False, expected_v2_version: str | None = None, timeout: float = 30.0, max_retries: int = 3, enable_cache: bool = False, cache_ttl: float = 300.0, log_requests: bool = False, on_request: RequestHook | None = None, on_response: ResponseHook | None = None, on_error: ErrorHook | None = None, on_event: AnyEventHook | None = None, hook_error_policy: Literal['swallow', 'raise'] = 'swallow', policies: Policies | None = None)</code>","text":"<p>Initialize the Affinity client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>Your Affinity API key</p> required <code>v1_base_url</code> <code>str</code> <p>V1 API base URL (default: https://api.affinity.co)</p> <code>V1_BASE_URL</code> <code>v2_base_url</code> <code>str</code> <p>V2 API base URL (default: https://api.affinity.co/v2)</p> <code>V2_BASE_URL</code> <code>v1_auth_mode</code> <code>Literal['bearer', 'basic']</code> <p>Auth mode for V1 API (\"bearer\" or \"basic\")</p> <code>'bearer'</code> <code>transport</code> <code>BaseTransport | None</code> <p>Optional <code>httpx</code> transport (advanced; useful for mocking in tests)</p> <code>None</code> <code>async_transport</code> <code>AsyncBaseTransport | None</code> <p>Optional async <code>httpx</code> transport (advanced; useful for mocking in tests)</p> <code>None</code> <code>enable_beta_endpoints</code> <code>bool</code> <p>Enable beta V2 endpoints</p> <code>False</code> <code>allow_insecure_download_redirects</code> <code>bool</code> <p>Allow <code>http://</code> redirects for file downloads. Not recommended; prefer HTTPS-only downloads.</p> <code>False</code> <code>expected_v2_version</code> <code>str | None</code> <p>Expected V2 API version for diagnostics (e.g., \"2024-01-01\"). Used to detect version compatibility issues. See TR-015.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds</p> <code>30.0</code> <code>max_retries</code> <code>int</code> <p>Maximum retries for rate-limited requests</p> <code>3</code> <code>enable_cache</code> <code>bool</code> <p>Enable response caching for field metadata</p> <code>False</code> <code>cache_ttl</code> <code>float</code> <p>Cache TTL in seconds</p> <code>300.0</code> <code>log_requests</code> <code>bool</code> <p>Log all HTTP requests (for debugging)</p> <code>False</code> <code>on_request</code> <code>RequestHook | None</code> <p>Hook called before each request (DX-008)</p> <code>None</code> <code>on_response</code> <code>ResponseHook | None</code> <p>Hook called after each response (DX-008)</p> <code>None</code> <code>on_error</code> <code>ErrorHook | None</code> <p>Hook called when a request raises (DX-008)</p> <code>None</code> <code>on_event</code> <code>AnyEventHook | None</code> <p>Event hook called for request/response lifecycle events (DX-008)</p> <code>None</code> <code>hook_error_policy</code> <code>Literal['swallow', 'raise']</code> <p>What to do if hooks raise (\"swallow\" or \"raise\")</p> <code>'swallow'</code> <code>policies</code> <code>Policies | None</code> <p>Client policies (e.g., disable writes)</p> <code>None</code> Source code in <code>affinity/client.py</code> <pre><code>def __init__(\n    self,\n    api_key: str,\n    *,\n    v1_base_url: str = V1_BASE_URL,\n    v2_base_url: str = V2_BASE_URL,\n    v1_auth_mode: Literal[\"bearer\", \"basic\"] = \"bearer\",\n    transport: httpx.BaseTransport | None = None,\n    async_transport: httpx.AsyncBaseTransport | None = None,\n    enable_beta_endpoints: bool = False,\n    allow_insecure_download_redirects: bool = False,\n    expected_v2_version: str | None = None,\n    timeout: float = 30.0,\n    max_retries: int = 3,\n    enable_cache: bool = False,\n    cache_ttl: float = 300.0,\n    log_requests: bool = False,\n    on_request: RequestHook | None = None,\n    on_response: ResponseHook | None = None,\n    on_error: ErrorHook | None = None,\n    on_event: AnyEventHook | None = None,\n    hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n    policies: Policies | None = None,\n):\n    \"\"\"\n    Initialize the Affinity client.\n\n    Args:\n        api_key: Your Affinity API key\n        v1_base_url: V1 API base URL (default: https://api.affinity.co)\n        v2_base_url: V2 API base URL (default: https://api.affinity.co/v2)\n        v1_auth_mode: Auth mode for V1 API (\"bearer\" or \"basic\")\n        transport: Optional `httpx` transport (advanced; useful for mocking in tests)\n        async_transport: Optional async `httpx` transport (advanced; useful for mocking in\n            tests)\n        enable_beta_endpoints: Enable beta V2 endpoints\n        allow_insecure_download_redirects: Allow `http://` redirects for file downloads.\n            Not recommended; prefer HTTPS-only downloads.\n        expected_v2_version: Expected V2 API version for diagnostics (e.g.,\n            \"2024-01-01\"). Used to detect version compatibility issues.\n            See TR-015.\n        timeout: Request timeout in seconds\n        max_retries: Maximum retries for rate-limited requests\n        enable_cache: Enable response caching for field metadata\n        cache_ttl: Cache TTL in seconds\n        log_requests: Log all HTTP requests (for debugging)\n        on_request: Hook called before each request (DX-008)\n        on_response: Hook called after each response (DX-008)\n        on_error: Hook called when a request raises (DX-008)\n        on_event: Event hook called for request/response lifecycle events (DX-008)\n        hook_error_policy: What to do if hooks raise (\"swallow\" or \"raise\")\n        policies: Client policies (e.g., disable writes)\n    \"\"\"\n    config = ClientConfig(\n        api_key=api_key,\n        v1_base_url=v1_base_url,\n        v2_base_url=v2_base_url,\n        v1_auth_mode=v1_auth_mode,\n        transport=transport,\n        async_transport=async_transport,\n        enable_beta_endpoints=enable_beta_endpoints,\n        allow_insecure_download_redirects=allow_insecure_download_redirects,\n        expected_v2_version=expected_v2_version,\n        timeout=timeout,\n        max_retries=max_retries,\n        enable_cache=enable_cache,\n        cache_ttl=cache_ttl,\n        log_requests=log_requests,\n        on_request=on_request,\n        on_response=on_response,\n        on_error=on_error,\n        on_event=on_event,\n        hook_error_policy=hook_error_policy,\n        policies=policies or Policies(),\n    )\n    self._http = HTTPClient(config)\n\n    # Resource management tracking\n    self._closed = False\n    self._entered_context = False\n\n    # Initialize services\n    self._companies: CompanyService | None = None\n    self._persons: PersonService | None = None\n    self._lists: ListService | None = None\n    self._opportunities: OpportunityService | None = None\n    self._tasks: TaskService | None = None\n    self._notes: NoteService | None = None\n    self._reminders: ReminderService | None = None\n    self._webhooks: WebhookService | None = None\n    self._interactions: InteractionService | None = None\n    self._fields: FieldService | None = None\n    self._field_values: FieldValueService | None = None\n    self._field_value_changes: FieldValueChangesService | None = None\n    self._files: EntityFileService | None = None\n    self._relationships: RelationshipStrengthService | None = None\n    self._auth: AuthService | None = None\n    self._rate_limits: RateLimitService | None = None\n</code></pre>"},{"location":"reference/client/#affinity.Affinity.clear_cache","title":"<code>clear_cache() -&gt; None</code>","text":"<p>Clear the response cache.</p> Source code in <code>affinity/client.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear the response cache.\"\"\"\n    if self._http.cache:\n        self._http.cache.clear()\n</code></pre>"},{"location":"reference/client/#affinity.Affinity.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the HTTP client and release resources.</p> Source code in <code>affinity/client.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the HTTP client and release resources.\"\"\"\n    if not self._closed:\n        self._http.close()\n        self._closed = True\n</code></pre>"},{"location":"reference/client/#affinity.Affinity.from_env","title":"<code>from_env(*, env_var: str = _DEFAULT_API_KEY_ENV_VAR, load_dotenv: bool = False, dotenv_path: str | os.PathLike[str] | None = None, dotenv_override: bool = False, transport: httpx.BaseTransport | None = None, async_transport: httpx.AsyncBaseTransport | None = None, policies: Policies | None = None, on_event: AnyEventHook | None = None, hook_error_policy: Literal['swallow', 'raise'] = 'swallow', **kwargs: Any) -&gt; Affinity</code>  <code>classmethod</code>","text":"<p>Create a client using an API key from the environment.</p> <p>By default, reads <code>AFFINITY_API_KEY</code>. For local development, you can optionally load a <code>.env</code> file (requires <code>python-dotenv</code>).</p> Source code in <code>affinity/client.py</code> <pre><code>@classmethod\ndef from_env(\n    cls,\n    *,\n    env_var: str = _DEFAULT_API_KEY_ENV_VAR,\n    load_dotenv: bool = False,\n    dotenv_path: str | os.PathLike[str] | None = None,\n    dotenv_override: bool = False,\n    transport: httpx.BaseTransport | None = None,\n    async_transport: httpx.AsyncBaseTransport | None = None,\n    policies: Policies | None = None,\n    on_event: AnyEventHook | None = None,\n    hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n    **kwargs: Any,\n) -&gt; Affinity:\n    \"\"\"\n    Create a client using an API key from the environment.\n\n    By default, reads `AFFINITY_API_KEY`. For local development, you can optionally\n    load a `.env` file (requires `python-dotenv`).\n    \"\"\"\n    api_key = _api_key_from_env(\n        env_var=env_var,\n        load_dotenv=load_dotenv,\n        dotenv_path=dotenv_path,\n        dotenv_override=dotenv_override,\n    )\n    return cls(\n        api_key=api_key,\n        transport=transport,\n        async_transport=async_transport,\n        policies=policies,\n        on_event=on_event,\n        hook_error_policy=hook_error_policy,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/client/#affinity.Affinity.whoami","title":"<code>whoami() -&gt; WhoAmI</code>","text":"<p>Convenience wrapper for <code>client.auth.whoami()</code>.</p> Source code in <code>affinity/client.py</code> <pre><code>def whoami(self) -&gt; WhoAmI:\n    \"\"\"Convenience wrapper for `client.auth.whoami()`.\"\"\"\n    return self.auth.whoami()\n</code></pre>"},{"location":"reference/client/#asyncaffinity","title":"<code>AsyncAffinity</code>","text":"<p>Asynchronous Affinity API client.</p> <p>Same interface as Affinity but with async/await support.</p> Example <pre><code>async with AsyncAffinity(api_key=\"your-key\") as client:\n    async for company in client.companies.all():\n        print(company.name)\n</code></pre> Source code in <code>affinity/client.py</code> <pre><code>class AsyncAffinity:\n    \"\"\"\n    Asynchronous Affinity API client.\n\n    Same interface as Affinity but with async/await support.\n\n    Example:\n        ```python\n        async with AsyncAffinity(api_key=\"your-key\") as client:\n            async for company in client.companies.all():\n                print(company.name)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: str,\n        *,\n        v1_base_url: str = V1_BASE_URL,\n        v2_base_url: str = V2_BASE_URL,\n        v1_auth_mode: Literal[\"bearer\", \"basic\"] = \"bearer\",\n        transport: httpx.BaseTransport | None = None,\n        async_transport: httpx.AsyncBaseTransport | None = None,\n        enable_beta_endpoints: bool = False,\n        allow_insecure_download_redirects: bool = False,\n        expected_v2_version: str | None = None,\n        timeout: float = 30.0,\n        max_retries: int = 3,\n        enable_cache: bool = False,\n        cache_ttl: float = 300.0,\n        log_requests: bool = False,\n        on_request: RequestHook | None = None,\n        on_response: ResponseHook | None = None,\n        on_error: ErrorHook | None = None,\n        on_event: AnyEventHook | None = None,\n        hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n        policies: Policies | None = None,\n    ):\n        \"\"\"\n        Initialize the async Affinity client.\n\n        Args:\n            api_key: Your Affinity API key\n            v1_base_url: V1 API base URL (default: https://api.affinity.co)\n            v2_base_url: V2 API base URL (default: https://api.affinity.co/v2)\n            v1_auth_mode: Auth mode for V1 API (\"bearer\" or \"basic\")\n            transport: Optional `httpx` transport (advanced; useful for mocking in tests)\n            async_transport: Optional async `httpx` transport (advanced; useful for mocking in\n                tests)\n            enable_beta_endpoints: Enable beta V2 endpoints\n            allow_insecure_download_redirects: Allow `http://` redirects for file downloads.\n                Not recommended; prefer HTTPS-only downloads.\n            expected_v2_version: Expected V2 API version for diagnostics (e.g.,\n                \"2024-01-01\"). Used to detect version compatibility issues.\n                See TR-015.\n            timeout: Request timeout in seconds\n            max_retries: Maximum retries for rate-limited requests\n            enable_cache: Enable response caching for field metadata\n            cache_ttl: Cache TTL in seconds\n            log_requests: Log all HTTP requests (for debugging)\n            on_request: Hook called before each request (DX-008)\n            on_response: Hook called after each response (DX-008)\n            on_error: Hook called when a request raises (DX-008)\n            on_event: Event hook called for request/response lifecycle events (DX-008)\n            hook_error_policy: What to do if hooks raise (\"swallow\" or \"raise\")\n        \"\"\"\n        config = ClientConfig(\n            api_key=api_key,\n            v1_base_url=v1_base_url,\n            v2_base_url=v2_base_url,\n            v1_auth_mode=v1_auth_mode,\n            transport=transport,\n            async_transport=async_transport,\n            enable_beta_endpoints=enable_beta_endpoints,\n            allow_insecure_download_redirects=allow_insecure_download_redirects,\n            expected_v2_version=expected_v2_version,\n            timeout=timeout,\n            max_retries=max_retries,\n            enable_cache=enable_cache,\n            cache_ttl=cache_ttl,\n            log_requests=log_requests,\n            on_request=on_request,\n            on_response=on_response,\n            on_error=on_error,\n            on_event=on_event,\n            hook_error_policy=hook_error_policy,\n            policies=policies or Policies(),\n        )\n        self._http = AsyncHTTPClient(config)\n\n        # Resource management tracking\n        self._closed = False\n        self._entered_context = False\n\n        self._companies: AsyncCompanyService | None = None\n        self._persons: AsyncPersonService | None = None\n        self._opportunities: AsyncOpportunityService | None = None\n        self._lists: AsyncListService | None = None\n        self._tasks: AsyncTaskService | None = None\n        self._notes: AsyncNoteService | None = None\n        self._reminders: AsyncReminderService | None = None\n        self._webhooks: AsyncWebhookService | None = None\n        self._interactions: AsyncInteractionService | None = None\n        self._fields: AsyncFieldService | None = None\n        self._field_values: AsyncFieldValueService | None = None\n        self._field_value_changes: AsyncFieldValueChangesService | None = None\n        self._files: AsyncEntityFileService | None = None\n        self._relationships: AsyncRelationshipStrengthService | None = None\n        self._auth: AsyncAuthService | None = None\n        self._rate_limits: AsyncRateLimitService | None = None\n\n    @classmethod\n    def from_env(\n        cls,\n        *,\n        env_var: str = _DEFAULT_API_KEY_ENV_VAR,\n        load_dotenv: bool = False,\n        dotenv_path: str | os.PathLike[str] | None = None,\n        dotenv_override: bool = False,\n        transport: httpx.BaseTransport | None = None,\n        async_transport: httpx.AsyncBaseTransport | None = None,\n        policies: Policies | None = None,\n        on_event: AnyEventHook | None = None,\n        hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n        **kwargs: Any,\n    ) -&gt; AsyncAffinity:\n        \"\"\"\n        Create an async client using an API key from the environment.\n\n        By default, reads `AFFINITY_API_KEY`. For local development, you can optionally\n        load a `.env` file (requires `python-dotenv`).\n        \"\"\"\n        api_key = _api_key_from_env(\n            env_var=env_var,\n            load_dotenv=load_dotenv,\n            dotenv_path=dotenv_path,\n            dotenv_override=dotenv_override,\n        )\n        return cls(\n            api_key=api_key,\n            transport=transport,\n            async_transport=async_transport,\n            policies=policies,\n            on_event=on_event,\n            hook_error_policy=hook_error_policy,\n            **kwargs,\n        )\n\n    @property\n    def companies(self) -&gt; AsyncCompanyService:\n        \"\"\"Company (organization) operations.\"\"\"\n        if self._companies is None:\n            self._companies = AsyncCompanyService(self._http)\n        return self._companies\n\n    @property\n    def persons(self) -&gt; AsyncPersonService:\n        \"\"\"Person (contact) operations.\"\"\"\n        if self._persons is None:\n            self._persons = AsyncPersonService(self._http)\n        return self._persons\n\n    @property\n    def opportunities(self) -&gt; AsyncOpportunityService:\n        \"\"\"Opportunity operations.\"\"\"\n        if self._opportunities is None:\n            self._opportunities = AsyncOpportunityService(self._http)\n        return self._opportunities\n\n    @property\n    def lists(self) -&gt; AsyncListService:\n        \"\"\"List and list entry operations.\"\"\"\n        if self._lists is None:\n            self._lists = AsyncListService(self._http)\n        return self._lists\n\n    @property\n    def tasks(self) -&gt; AsyncTaskService:\n        \"\"\"Long-running task operations (polling, waiting).\"\"\"\n        if self._tasks is None:\n            self._tasks = AsyncTaskService(self._http)\n        return self._tasks\n\n    @property\n    def notes(self) -&gt; AsyncNoteService:\n        \"\"\"Note operations.\"\"\"\n        if self._notes is None:\n            self._notes = AsyncNoteService(self._http)\n        return self._notes\n\n    @property\n    def reminders(self) -&gt; AsyncReminderService:\n        \"\"\"Reminder operations.\"\"\"\n        if self._reminders is None:\n            self._reminders = AsyncReminderService(self._http)\n        return self._reminders\n\n    @property\n    def webhooks(self) -&gt; AsyncWebhookService:\n        \"\"\"Webhook subscription operations.\"\"\"\n        if self._webhooks is None:\n            self._webhooks = AsyncWebhookService(self._http)\n        return self._webhooks\n\n    @property\n    def interactions(self) -&gt; AsyncInteractionService:\n        \"\"\"Interaction operations.\"\"\"\n        if self._interactions is None:\n            self._interactions = AsyncInteractionService(self._http)\n        return self._interactions\n\n    @property\n    def fields(self) -&gt; AsyncFieldService:\n        \"\"\"Custom field operations.\"\"\"\n        if self._fields is None:\n            self._fields = AsyncFieldService(self._http)\n        return self._fields\n\n    @property\n    def field_values(self) -&gt; AsyncFieldValueService:\n        \"\"\"Field value operations.\"\"\"\n        if self._field_values is None:\n            self._field_values = AsyncFieldValueService(self._http)\n        return self._field_values\n\n    @property\n    def field_value_changes(self) -&gt; AsyncFieldValueChangesService:\n        \"\"\"Field value change history queries.\"\"\"\n        if self._field_value_changes is None:\n            self._field_value_changes = AsyncFieldValueChangesService(self._http)\n        return self._field_value_changes\n\n    @property\n    def files(self) -&gt; AsyncEntityFileService:\n        \"\"\"Entity file operations.\"\"\"\n        if self._files is None:\n            self._files = AsyncEntityFileService(self._http)\n        return self._files\n\n    @property\n    def relationships(self) -&gt; AsyncRelationshipStrengthService:\n        \"\"\"Relationship strength queries.\"\"\"\n        if self._relationships is None:\n            self._relationships = AsyncRelationshipStrengthService(self._http)\n        return self._relationships\n\n    @property\n    def auth(self) -&gt; AsyncAuthService:\n        \"\"\"Authentication info.\"\"\"\n        if self._auth is None:\n            self._auth = AsyncAuthService(self._http)\n        return self._auth\n\n    @property\n    def rate_limits(self) -&gt; AsyncRateLimitService:\n        \"\"\"Unified rate limit information (version-agnostic).\"\"\"\n        if self._rate_limits is None:\n            self._rate_limits = AsyncRateLimitService(self._http)\n        return self._rate_limits\n\n    async def __aenter__(self) -&gt; AsyncAffinity:\n        \"\"\"Enter an async context and return this client.\"\"\"\n        self._entered_context = True\n        return self\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n        \"\"\"Exit the async context and close the underlying HTTP client.\"\"\"\n        await self.close()\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the HTTP client.\"\"\"\n        if not self._closed:\n            await self._http.close()\n            self._closed = True\n\n    def __del__(self) -&gt; None:\n        \"\"\"Warn if client was not properly closed.\n\n        NOTE: We intentionally do NOT attempt async cleanup here.\n        asyncio.create_task() in __del__ is unsafe - the task may be garbage\n        collected before completion, leading to resource leaks or errors.\n        Users must use context managers or call close() explicitly.\n        \"\"\"\n        # Use getattr to handle case where __init__ failed before setting _closed\n        if not getattr(self, \"_closed\", True) and not getattr(self, \"_entered_context\", True):\n            warnings.warn(\n                \"AsyncAffinity client was not closed. \"\n                \"Use 'async with AsyncAffinity.from_env() as client:' \"\n                \"or call await client.close() when done.\",\n                ResourceWarning,\n                stacklevel=2,\n            )\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear the response cache.\"\"\"\n        if self._http.cache:\n            self._http.cache.clear()\n\n    async def whoami(self) -&gt; WhoAmI:\n        \"\"\"Convenience wrapper for `client.auth.whoami()`.\"\"\"\n        return await self.auth.whoami()\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.auth","title":"<code>auth: AsyncAuthService</code>  <code>property</code>","text":"<p>Authentication info.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.companies","title":"<code>companies: AsyncCompanyService</code>  <code>property</code>","text":"<p>Company (organization) operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.field_value_changes","title":"<code>field_value_changes: AsyncFieldValueChangesService</code>  <code>property</code>","text":"<p>Field value change history queries.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.field_values","title":"<code>field_values: AsyncFieldValueService</code>  <code>property</code>","text":"<p>Field value operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.fields","title":"<code>fields: AsyncFieldService</code>  <code>property</code>","text":"<p>Custom field operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.files","title":"<code>files: AsyncEntityFileService</code>  <code>property</code>","text":"<p>Entity file operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.interactions","title":"<code>interactions: AsyncInteractionService</code>  <code>property</code>","text":"<p>Interaction operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.lists","title":"<code>lists: AsyncListService</code>  <code>property</code>","text":"<p>List and list entry operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.notes","title":"<code>notes: AsyncNoteService</code>  <code>property</code>","text":"<p>Note operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.opportunities","title":"<code>opportunities: AsyncOpportunityService</code>  <code>property</code>","text":"<p>Opportunity operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.persons","title":"<code>persons: AsyncPersonService</code>  <code>property</code>","text":"<p>Person (contact) operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.rate_limits","title":"<code>rate_limits: AsyncRateLimitService</code>  <code>property</code>","text":"<p>Unified rate limit information (version-agnostic).</p>"},{"location":"reference/client/#affinity.AsyncAffinity.relationships","title":"<code>relationships: AsyncRelationshipStrengthService</code>  <code>property</code>","text":"<p>Relationship strength queries.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.reminders","title":"<code>reminders: AsyncReminderService</code>  <code>property</code>","text":"<p>Reminder operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.tasks","title":"<code>tasks: AsyncTaskService</code>  <code>property</code>","text":"<p>Long-running task operations (polling, waiting).</p>"},{"location":"reference/client/#affinity.AsyncAffinity.webhooks","title":"<code>webhooks: AsyncWebhookService</code>  <code>property</code>","text":"<p>Webhook subscription operations.</p>"},{"location":"reference/client/#affinity.AsyncAffinity.__aenter__","title":"<code>__aenter__() -&gt; AsyncAffinity</code>  <code>async</code>","text":"<p>Enter an async context and return this client.</p> Source code in <code>affinity/client.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncAffinity:\n    \"\"\"Enter an async context and return this client.\"\"\"\n    self._entered_context = True\n    return self\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.__aexit__","title":"<code>__aexit__(*args: Any) -&gt; None</code>  <code>async</code>","text":"<p>Exit the async context and close the underlying HTTP client.</p> Source code in <code>affinity/client.py</code> <pre><code>async def __aexit__(self, *args: Any) -&gt; None:\n    \"\"\"Exit the async context and close the underlying HTTP client.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.__del__","title":"<code>__del__() -&gt; None</code>","text":"<p>Warn if client was not properly closed.</p> <p>NOTE: We intentionally do NOT attempt async cleanup here. asyncio.create_task() in del is unsafe - the task may be garbage collected before completion, leading to resource leaks or errors. Users must use context managers or call close() explicitly.</p> Source code in <code>affinity/client.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Warn if client was not properly closed.\n\n    NOTE: We intentionally do NOT attempt async cleanup here.\n    asyncio.create_task() in __del__ is unsafe - the task may be garbage\n    collected before completion, leading to resource leaks or errors.\n    Users must use context managers or call close() explicitly.\n    \"\"\"\n    # Use getattr to handle case where __init__ failed before setting _closed\n    if not getattr(self, \"_closed\", True) and not getattr(self, \"_entered_context\", True):\n        warnings.warn(\n            \"AsyncAffinity client was not closed. \"\n            \"Use 'async with AsyncAffinity.from_env() as client:' \"\n            \"or call await client.close() when done.\",\n            ResourceWarning,\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.__init__","title":"<code>__init__(api_key: str, *, v1_base_url: str = V1_BASE_URL, v2_base_url: str = V2_BASE_URL, v1_auth_mode: Literal['bearer', 'basic'] = 'bearer', transport: httpx.BaseTransport | None = None, async_transport: httpx.AsyncBaseTransport | None = None, enable_beta_endpoints: bool = False, allow_insecure_download_redirects: bool = False, expected_v2_version: str | None = None, timeout: float = 30.0, max_retries: int = 3, enable_cache: bool = False, cache_ttl: float = 300.0, log_requests: bool = False, on_request: RequestHook | None = None, on_response: ResponseHook | None = None, on_error: ErrorHook | None = None, on_event: AnyEventHook | None = None, hook_error_policy: Literal['swallow', 'raise'] = 'swallow', policies: Policies | None = None)</code>","text":"<p>Initialize the async Affinity client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>Your Affinity API key</p> required <code>v1_base_url</code> <code>str</code> <p>V1 API base URL (default: https://api.affinity.co)</p> <code>V1_BASE_URL</code> <code>v2_base_url</code> <code>str</code> <p>V2 API base URL (default: https://api.affinity.co/v2)</p> <code>V2_BASE_URL</code> <code>v1_auth_mode</code> <code>Literal['bearer', 'basic']</code> <p>Auth mode for V1 API (\"bearer\" or \"basic\")</p> <code>'bearer'</code> <code>transport</code> <code>BaseTransport | None</code> <p>Optional <code>httpx</code> transport (advanced; useful for mocking in tests)</p> <code>None</code> <code>async_transport</code> <code>AsyncBaseTransport | None</code> <p>Optional async <code>httpx</code> transport (advanced; useful for mocking in tests)</p> <code>None</code> <code>enable_beta_endpoints</code> <code>bool</code> <p>Enable beta V2 endpoints</p> <code>False</code> <code>allow_insecure_download_redirects</code> <code>bool</code> <p>Allow <code>http://</code> redirects for file downloads. Not recommended; prefer HTTPS-only downloads.</p> <code>False</code> <code>expected_v2_version</code> <code>str | None</code> <p>Expected V2 API version for diagnostics (e.g., \"2024-01-01\"). Used to detect version compatibility issues. See TR-015.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds</p> <code>30.0</code> <code>max_retries</code> <code>int</code> <p>Maximum retries for rate-limited requests</p> <code>3</code> <code>enable_cache</code> <code>bool</code> <p>Enable response caching for field metadata</p> <code>False</code> <code>cache_ttl</code> <code>float</code> <p>Cache TTL in seconds</p> <code>300.0</code> <code>log_requests</code> <code>bool</code> <p>Log all HTTP requests (for debugging)</p> <code>False</code> <code>on_request</code> <code>RequestHook | None</code> <p>Hook called before each request (DX-008)</p> <code>None</code> <code>on_response</code> <code>ResponseHook | None</code> <p>Hook called after each response (DX-008)</p> <code>None</code> <code>on_error</code> <code>ErrorHook | None</code> <p>Hook called when a request raises (DX-008)</p> <code>None</code> <code>on_event</code> <code>AnyEventHook | None</code> <p>Event hook called for request/response lifecycle events (DX-008)</p> <code>None</code> <code>hook_error_policy</code> <code>Literal['swallow', 'raise']</code> <p>What to do if hooks raise (\"swallow\" or \"raise\")</p> <code>'swallow'</code> Source code in <code>affinity/client.py</code> <pre><code>def __init__(\n    self,\n    api_key: str,\n    *,\n    v1_base_url: str = V1_BASE_URL,\n    v2_base_url: str = V2_BASE_URL,\n    v1_auth_mode: Literal[\"bearer\", \"basic\"] = \"bearer\",\n    transport: httpx.BaseTransport | None = None,\n    async_transport: httpx.AsyncBaseTransport | None = None,\n    enable_beta_endpoints: bool = False,\n    allow_insecure_download_redirects: bool = False,\n    expected_v2_version: str | None = None,\n    timeout: float = 30.0,\n    max_retries: int = 3,\n    enable_cache: bool = False,\n    cache_ttl: float = 300.0,\n    log_requests: bool = False,\n    on_request: RequestHook | None = None,\n    on_response: ResponseHook | None = None,\n    on_error: ErrorHook | None = None,\n    on_event: AnyEventHook | None = None,\n    hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n    policies: Policies | None = None,\n):\n    \"\"\"\n    Initialize the async Affinity client.\n\n    Args:\n        api_key: Your Affinity API key\n        v1_base_url: V1 API base URL (default: https://api.affinity.co)\n        v2_base_url: V2 API base URL (default: https://api.affinity.co/v2)\n        v1_auth_mode: Auth mode for V1 API (\"bearer\" or \"basic\")\n        transport: Optional `httpx` transport (advanced; useful for mocking in tests)\n        async_transport: Optional async `httpx` transport (advanced; useful for mocking in\n            tests)\n        enable_beta_endpoints: Enable beta V2 endpoints\n        allow_insecure_download_redirects: Allow `http://` redirects for file downloads.\n            Not recommended; prefer HTTPS-only downloads.\n        expected_v2_version: Expected V2 API version for diagnostics (e.g.,\n            \"2024-01-01\"). Used to detect version compatibility issues.\n            See TR-015.\n        timeout: Request timeout in seconds\n        max_retries: Maximum retries for rate-limited requests\n        enable_cache: Enable response caching for field metadata\n        cache_ttl: Cache TTL in seconds\n        log_requests: Log all HTTP requests (for debugging)\n        on_request: Hook called before each request (DX-008)\n        on_response: Hook called after each response (DX-008)\n        on_error: Hook called when a request raises (DX-008)\n        on_event: Event hook called for request/response lifecycle events (DX-008)\n        hook_error_policy: What to do if hooks raise (\"swallow\" or \"raise\")\n    \"\"\"\n    config = ClientConfig(\n        api_key=api_key,\n        v1_base_url=v1_base_url,\n        v2_base_url=v2_base_url,\n        v1_auth_mode=v1_auth_mode,\n        transport=transport,\n        async_transport=async_transport,\n        enable_beta_endpoints=enable_beta_endpoints,\n        allow_insecure_download_redirects=allow_insecure_download_redirects,\n        expected_v2_version=expected_v2_version,\n        timeout=timeout,\n        max_retries=max_retries,\n        enable_cache=enable_cache,\n        cache_ttl=cache_ttl,\n        log_requests=log_requests,\n        on_request=on_request,\n        on_response=on_response,\n        on_error=on_error,\n        on_event=on_event,\n        hook_error_policy=hook_error_policy,\n        policies=policies or Policies(),\n    )\n    self._http = AsyncHTTPClient(config)\n\n    # Resource management tracking\n    self._closed = False\n    self._entered_context = False\n\n    self._companies: AsyncCompanyService | None = None\n    self._persons: AsyncPersonService | None = None\n    self._opportunities: AsyncOpportunityService | None = None\n    self._lists: AsyncListService | None = None\n    self._tasks: AsyncTaskService | None = None\n    self._notes: AsyncNoteService | None = None\n    self._reminders: AsyncReminderService | None = None\n    self._webhooks: AsyncWebhookService | None = None\n    self._interactions: AsyncInteractionService | None = None\n    self._fields: AsyncFieldService | None = None\n    self._field_values: AsyncFieldValueService | None = None\n    self._field_value_changes: AsyncFieldValueChangesService | None = None\n    self._files: AsyncEntityFileService | None = None\n    self._relationships: AsyncRelationshipStrengthService | None = None\n    self._auth: AsyncAuthService | None = None\n    self._rate_limits: AsyncRateLimitService | None = None\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.clear_cache","title":"<code>clear_cache() -&gt; None</code>","text":"<p>Clear the response cache.</p> Source code in <code>affinity/client.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear the response cache.\"\"\"\n    if self._http.cache:\n        self._http.cache.clear()\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.close","title":"<code>close() -&gt; None</code>  <code>async</code>","text":"<p>Close the HTTP client.</p> Source code in <code>affinity/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the HTTP client.\"\"\"\n    if not self._closed:\n        await self._http.close()\n        self._closed = True\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.from_env","title":"<code>from_env(*, env_var: str = _DEFAULT_API_KEY_ENV_VAR, load_dotenv: bool = False, dotenv_path: str | os.PathLike[str] | None = None, dotenv_override: bool = False, transport: httpx.BaseTransport | None = None, async_transport: httpx.AsyncBaseTransport | None = None, policies: Policies | None = None, on_event: AnyEventHook | None = None, hook_error_policy: Literal['swallow', 'raise'] = 'swallow', **kwargs: Any) -&gt; AsyncAffinity</code>  <code>classmethod</code>","text":"<p>Create an async client using an API key from the environment.</p> <p>By default, reads <code>AFFINITY_API_KEY</code>. For local development, you can optionally load a <code>.env</code> file (requires <code>python-dotenv</code>).</p> Source code in <code>affinity/client.py</code> <pre><code>@classmethod\ndef from_env(\n    cls,\n    *,\n    env_var: str = _DEFAULT_API_KEY_ENV_VAR,\n    load_dotenv: bool = False,\n    dotenv_path: str | os.PathLike[str] | None = None,\n    dotenv_override: bool = False,\n    transport: httpx.BaseTransport | None = None,\n    async_transport: httpx.AsyncBaseTransport | None = None,\n    policies: Policies | None = None,\n    on_event: AnyEventHook | None = None,\n    hook_error_policy: Literal[\"swallow\", \"raise\"] = \"swallow\",\n    **kwargs: Any,\n) -&gt; AsyncAffinity:\n    \"\"\"\n    Create an async client using an API key from the environment.\n\n    By default, reads `AFFINITY_API_KEY`. For local development, you can optionally\n    load a `.env` file (requires `python-dotenv`).\n    \"\"\"\n    api_key = _api_key_from_env(\n        env_var=env_var,\n        load_dotenv=load_dotenv,\n        dotenv_path=dotenv_path,\n        dotenv_override=dotenv_override,\n    )\n    return cls(\n        api_key=api_key,\n        transport=transport,\n        async_transport=async_transport,\n        policies=policies,\n        on_event=on_event,\n        hook_error_policy=hook_error_policy,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/client/#affinity.AsyncAffinity.whoami","title":"<code>whoami() -&gt; WhoAmI</code>  <code>async</code>","text":"<p>Convenience wrapper for <code>client.auth.whoami()</code>.</p> Source code in <code>affinity/client.py</code> <pre><code>async def whoami(self) -&gt; WhoAmI:\n    \"\"\"Convenience wrapper for `client.auth.whoami()`.\"\"\"\n    return await self.auth.whoami()\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>Custom exceptions for the Affinity API client.</p> <p>All exceptions inherit from AffinityError for easy catching of all library errors.</p>"},{"location":"reference/exceptions/#affinity.exceptions.AffinityError","title":"<code>AffinityError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Affinity API errors.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class AffinityError(Exception):\n    \"\"\"Base exception for all Affinity API errors.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        status_code: int | None = None,\n        response_body: Any | None = None,\n        diagnostics: ErrorDiagnostics | None = None,\n    ):\n        super().__init__(message)\n        self.message = message\n        self.status_code = status_code\n        self.response_body = response_body\n        self.diagnostics = diagnostics\n\n    def __str__(self) -&gt; str:\n        base = self.message\n        if self.status_code:\n            base = f\"[{self.status_code}] {base}\"\n        if self.diagnostics:\n            # Include method + url if both present, or just url if only url present\n            if self.diagnostics.method and self.diagnostics.url:\n                base = f\"{base} ({self.diagnostics.method} {self.diagnostics.url})\"\n            elif self.diagnostics.url:\n                base = f\"{base} (url={self.diagnostics.url})\"\n            if self.diagnostics.request_id:\n                base = f\"{base} [request_id={self.diagnostics.request_id}]\"\n        return base\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.AuthenticationError","title":"<code>AuthenticationError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>401 Unauthorized - Invalid or missing API key.</p> <p>Your API key is invalid or was not provided.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class AuthenticationError(AffinityError):\n    \"\"\"\n    401 Unauthorized - Invalid or missing API key.\n\n    Your API key is invalid or was not provided.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.AuthorizationError","title":"<code>AuthorizationError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>403 Forbidden - Insufficient permissions.</p> <p>You don't have permission to access this resource or perform this action. This can happen with: - Private lists you don't have access to - Admin-only actions - Resource-level permission restrictions</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class AuthorizationError(AffinityError):\n    \"\"\"\n    403 Forbidden - Insufficient permissions.\n\n    You don't have permission to access this resource or perform this action.\n    This can happen with:\n    - Private lists you don't have access to\n    - Admin-only actions\n    - Resource-level permission restrictions\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.BetaEndpointDisabledError","title":"<code>BetaEndpointDisabledError</code>","text":"<p>               Bases: <code>UnsupportedOperationError</code></p> <p>Attempted to call a beta endpoint without opt-in.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class BetaEndpointDisabledError(UnsupportedOperationError):\n    \"\"\"Attempted to call a beta endpoint without opt-in.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.CompanyNotFoundError","title":"<code>CompanyNotFoundError</code>","text":"<p>               Bases: <code>EntityNotFoundError</code></p> <p>Company with the specified ID was not found.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class CompanyNotFoundError(EntityNotFoundError):\n    \"\"\"Company with the specified ID was not found.\"\"\"\n\n    def __init__(self, company_id: int, **kwargs: Any):\n        super().__init__(\"Company\", company_id, **kwargs)\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Configuration error - missing or invalid client configuration.</p> <p>Check that you've provided: - A valid API key - Correct base URLs (if customizing)</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class ConfigurationError(AffinityError):\n    \"\"\"\n    Configuration error - missing or invalid client configuration.\n\n    Check that you've provided:\n    - A valid API key\n    - Correct base URLs (if customizing)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.ConflictError","title":"<code>ConflictError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>409 Conflict - Resource conflict.</p> <p>The request conflicts with the current state of the resource. For example: - Trying to create a person with an email that already exists - Concurrent modification conflicts</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class ConflictError(AffinityError):\n    \"\"\"\n    409 Conflict - Resource conflict.\n\n    The request conflicts with the current state of the resource.\n    For example:\n    - Trying to create a person with an email that already exists\n    - Concurrent modification conflicts\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.DeprecationWarning","title":"<code>DeprecationWarning</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Feature is deprecated and may be removed.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class DeprecationWarning(AffinityError):\n    \"\"\"\n    Feature is deprecated and may be removed.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.EntityNotFoundError","title":"<code>EntityNotFoundError</code>","text":"<p>               Bases: <code>NotFoundError</code></p> <p>Specific entity not found.</p> <p>Provides type-safe context about which entity type was not found.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class EntityNotFoundError(NotFoundError):\n    \"\"\"\n    Specific entity not found.\n\n    Provides type-safe context about which entity type was not found.\n    \"\"\"\n\n    def __init__(\n        self,\n        entity_type: str,\n        entity_id: int | str,\n        **kwargs: Any,\n    ):\n        message = f\"{entity_type} with ID {entity_id} not found\"\n        super().__init__(message, **kwargs)\n        self.entity_type = entity_type\n        self.entity_id = entity_id\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.FieldNotFoundError","title":"<code>FieldNotFoundError</code>","text":"<p>               Bases: <code>NotFoundError</code></p> <p>Field with the specified ID was not found.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class FieldNotFoundError(NotFoundError):\n    \"\"\"Field with the specified ID was not found.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.FilterParseError","title":"<code>FilterParseError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a filter expression cannot be parsed.</p> <p>Common causes: - Multi-word values not quoted: Status=Intro Meeting - Invalid operators - Malformed expressions</p> Example fix Source code in <code>affinity/exceptions.py</code> <pre><code>class FilterParseError(ValueError):\n    \"\"\"\n    Raised when a filter expression cannot be parsed.\n\n    Common causes:\n    - Multi-word values not quoted: Status=Intro Meeting\n    - Invalid operators\n    - Malformed expressions\n\n    Example fix:\n        # Wrong: --filter 'Status=Intro Meeting'\n        # Right: --filter 'Status=\"Intro Meeting\"'\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.FilterParseError--wrong-filter-statusintro-meeting","title":"Wrong: --filter 'Status=Intro Meeting'","text":""},{"location":"reference/exceptions/#affinity.exceptions.FilterParseError--right-filter-statusintro-meeting","title":"Right: --filter 'Status=\"Intro Meeting\"'","text":""},{"location":"reference/exceptions/#affinity.exceptions.ListNotFoundError","title":"<code>ListNotFoundError</code>","text":"<p>               Bases: <code>NotFoundError</code></p> <p>List with the specified ID was not found.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class ListNotFoundError(NotFoundError):\n    \"\"\"List with the specified ID was not found.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.NetworkError","title":"<code>NetworkError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Network-level error.</p> <p>Failed to connect to the Affinity API. Check your internet connection and firewall settings.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class NetworkError(AffinityError):\n    \"\"\"\n    Network-level error.\n\n    Failed to connect to the Affinity API.\n    Check your internet connection and firewall settings.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        diagnostics: ErrorDiagnostics | None = None,\n    ):\n        super().__init__(message, diagnostics=diagnostics)\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.NotFoundError","title":"<code>NotFoundError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>404 Not Found - Resource doesn't exist.</p> <p>The requested resource (person, company, list, etc.) was not found. This could mean: - The ID is invalid - The resource was deleted - You don't have access to view it</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class NotFoundError(AffinityError):\n    \"\"\"\n    404 Not Found - Resource doesn't exist.\n\n    The requested resource (person, company, list, etc.) was not found.\n    This could mean:\n    - The ID is invalid\n    - The resource was deleted\n    - You don't have access to view it\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.OpportunityNotFoundError","title":"<code>OpportunityNotFoundError</code>","text":"<p>               Bases: <code>EntityNotFoundError</code></p> <p>Opportunity with the specified ID was not found.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class OpportunityNotFoundError(EntityNotFoundError):\n    \"\"\"Opportunity with the specified ID was not found.\"\"\"\n\n    def __init__(self, opportunity_id: int, **kwargs: Any):\n        super().__init__(\"Opportunity\", opportunity_id, **kwargs)\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.PersonNotFoundError","title":"<code>PersonNotFoundError</code>","text":"<p>               Bases: <code>EntityNotFoundError</code></p> <p>Person with the specified ID was not found.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class PersonNotFoundError(EntityNotFoundError):\n    \"\"\"Person with the specified ID was not found.\"\"\"\n\n    def __init__(self, person_id: int, **kwargs: Any):\n        super().__init__(\"Person\", person_id, **kwargs)\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.PolicyError","title":"<code>PolicyError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Raised when a client policy blocks an attempted operation.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class PolicyError(AffinityError):\n    \"\"\"Raised when a client policy blocks an attempted operation.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.RateLimitError","title":"<code>RateLimitError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>429 Too Many Requests - Rate limit exceeded.</p> <p>You've exceeded the API rate limit. Wait before retrying. Check the response headers for rate limit info: - X-Ratelimit-Limit-User-Reset: Seconds until per-minute limit resets - X-Ratelimit-Limit-Org-Reset: Seconds until monthly limit resets</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class RateLimitError(AffinityError):\n    \"\"\"\n    429 Too Many Requests - Rate limit exceeded.\n\n    You've exceeded the API rate limit. Wait before retrying.\n    Check the response headers for rate limit info:\n    - X-Ratelimit-Limit-User-Reset: Seconds until per-minute limit resets\n    - X-Ratelimit-Limit-Org-Reset: Seconds until monthly limit resets\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        retry_after: int | None = None,\n        status_code: int | None = None,\n        response_body: Any | None = None,\n        diagnostics: ErrorDiagnostics | None = None,\n    ):\n        super().__init__(\n            message,\n            status_code=status_code,\n            response_body=response_body,\n            diagnostics=diagnostics,\n        )\n        self.retry_after = retry_after\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>500/503 Internal Server Error - Server-side problem.</p> <p>Something went wrong on Affinity's servers. Try again later, and contact support if the problem persists.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class ServerError(AffinityError):\n    \"\"\"\n    500/503 Internal Server Error - Server-side problem.\n\n    Something went wrong on Affinity's servers.\n    Try again later, and contact support if the problem persists.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.TimeoutError","title":"<code>TimeoutError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Request timeout.</p> <p>The request took too long to complete. This could be due to: - Network issues - Large data sets - Server overload</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class TimeoutError(AffinityError):\n    \"\"\"\n    Request timeout.\n\n    The request took too long to complete.\n    This could be due to:\n    - Network issues\n    - Large data sets\n    - Server overload\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        diagnostics: ErrorDiagnostics | None = None,\n    ):\n        super().__init__(message, diagnostics=diagnostics)\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.TooManyResultsError","title":"<code>TooManyResultsError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Raised when <code>.all()</code> exceeds the limit.</p> <p>The default limit is 100,000 items (approximately 100MB for typical Person objects). This protects against OOM errors when paginating large datasets.</p> <p>To resolve: - Use <code>.pages()</code> for streaming iteration (memory-efficient) - Add filters to reduce result size - Pass <code>limit=None</code> to <code>.all()</code> if you're certain you need all results - Pass a custom <code>limit=500_000</code> if you need more than the default</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class TooManyResultsError(AffinityError):\n    \"\"\"\n    Raised when ``.all()`` exceeds the limit.\n\n    The default limit is 100,000 items (approximately 100MB for typical Person objects).\n    This protects against OOM errors when paginating large datasets.\n\n    To resolve:\n    - Use ``.pages()`` for streaming iteration (memory-efficient)\n    - Add filters to reduce result size\n    - Pass ``limit=None`` to ``.all()`` if you're certain you need all results\n    - Pass a custom ``limit=500_000`` if you need more than the default\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.UnsafeUrlError","title":"<code>UnsafeUrlError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>SDK blocked following a server-provided URL.</p> <p>Raised when SafeFollowUrl policy rejects a URL (scheme/host/userinfo/redirect).</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class UnsafeUrlError(AffinityError):\n    \"\"\"\n    SDK blocked following a server-provided URL.\n\n    Raised when SafeFollowUrl policy rejects a URL (scheme/host/userinfo/redirect).\n    \"\"\"\n\n    def __init__(self, message: str, *, url: str | None = None):\n        super().__init__(\n            message,\n            diagnostics=ErrorDiagnostics(url=url) if url else None,\n        )\n        self.url = url\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.UnsupportedOperationError","title":"<code>UnsupportedOperationError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Operation not supported by the current API version.</p> <p>Some operations are only available in V1 or V2.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class UnsupportedOperationError(AffinityError):\n    \"\"\"\n    Operation not supported by the current API version.\n\n    Some operations are only available in V1 or V2.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>400/422 Bad Request/Unprocessable Entity - Invalid request data.</p> <p>The request data is malformed or logically invalid. Check the error message for details about what's wrong.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class ValidationError(AffinityError):\n    \"\"\"\n    400/422 Bad Request/Unprocessable Entity - Invalid request data.\n\n    The request data is malformed or logically invalid.\n    Check the error message for details about what's wrong.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        param: str | None = None,\n        status_code: int | None = None,\n        response_body: Any | None = None,\n        diagnostics: ErrorDiagnostics | None = None,\n    ):\n        super().__init__(\n            message,\n            status_code=status_code,\n            response_body=response_body,\n            diagnostics=diagnostics,\n        )\n        self.param = param\n\n    def __str__(self) -&gt; str:\n        base = super().__str__()\n        if self.param:\n            return f\"{base} (param: {self.param})\"\n        return base\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.VersionCompatibilityError","title":"<code>VersionCompatibilityError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Response shape mismatch suggests API version incompatibility.</p> <p>TR-015: Raised when the SDK detects response-shape mismatches that appear version-related. This typically means the API key's configured v2 Default API Version differs from what the SDK expects.</p> <p>Guidance: 1. Check your API key's v2 Default API Version in the Affinity dashboard 2. Ensure it matches the expected_v2_version configured in the SDK 3. See: https://developer.affinity.co/#section/Getting-Started/Versioning</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class VersionCompatibilityError(AffinityError):\n    \"\"\"\n    Response shape mismatch suggests API version incompatibility.\n\n    TR-015: Raised when the SDK detects response-shape mismatches that\n    appear version-related. This typically means the API key's configured\n    v2 Default API Version differs from what the SDK expects.\n\n    Guidance:\n    1. Check your API key's v2 Default API Version in the Affinity dashboard\n    2. Ensure it matches the expected_v2_version configured in the SDK\n    3. See: https://developer.affinity.co/#section/Getting-Started/Versioning\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        expected_version: str | None = None,\n        parsing_error: str | None = None,\n        status_code: int | None = None,\n        response_body: Any | None = None,\n        diagnostics: ErrorDiagnostics | None = None,\n    ):\n        super().__init__(\n            message,\n            status_code=status_code,\n            response_body=response_body,\n            diagnostics=diagnostics,\n        )\n        self.expected_version = expected_version\n        self.parsing_error = parsing_error\n\n    def __str__(self) -&gt; str:\n        base = super().__str__()\n        hints = []\n        if self.expected_version:\n            hints.append(f\"expected_v2_version={self.expected_version}\")\n        if self.parsing_error:\n            hints.append(f\"parsing_error={self.parsing_error}\")\n        if hints:\n            base = f\"{base} ({', '.join(hints)})\"\n        return base\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.WebhookInvalidJsonError","title":"<code>WebhookInvalidJsonError</code>","text":"<p>               Bases: <code>WebhookParseError</code></p> <p>Raised when a webhook payload cannot be decoded as JSON.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class WebhookInvalidJsonError(WebhookParseError):\n    \"\"\"Raised when a webhook payload cannot be decoded as JSON.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.WebhookInvalidPayloadError","title":"<code>WebhookInvalidPayloadError</code>","text":"<p>               Bases: <code>WebhookParseError</code></p> <p>Raised when a decoded webhook payload is not in the expected envelope shape.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class WebhookInvalidPayloadError(WebhookParseError):\n    \"\"\"Raised when a decoded webhook payload is not in the expected envelope shape.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.WebhookInvalidSentAtError","title":"<code>WebhookInvalidSentAtError</code>","text":"<p>               Bases: <code>WebhookParseError</code></p> <p>Raised when a webhook <code>sent_at</code> field is missing or invalid.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class WebhookInvalidSentAtError(WebhookParseError):\n    \"\"\"Raised when a webhook `sent_at` field is missing or invalid.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.WebhookMissingKeyError","title":"<code>WebhookMissingKeyError</code>","text":"<p>               Bases: <code>WebhookParseError</code></p> <p>Raised when a webhook payload is missing a required key.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class WebhookMissingKeyError(WebhookParseError):\n    \"\"\"Raised when a webhook payload is missing a required key.\"\"\"\n\n    def __init__(self, message: str, *, key: str):\n        super().__init__(message)\n        self.key = key\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.WebhookParseError","title":"<code>WebhookParseError</code>","text":"<p>               Bases: <code>AffinityError</code></p> <p>Base error for inbound webhook parsing/validation failures.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class WebhookParseError(AffinityError):\n    \"\"\"Base error for inbound webhook parsing/validation failures.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.WriteNotAllowedError","title":"<code>WriteNotAllowedError</code>","text":"<p>               Bases: <code>PolicyError</code></p> <p>Raised when a write operation is attempted while the write policy denies writes.</p> Source code in <code>affinity/exceptions.py</code> <pre><code>class WriteNotAllowedError(PolicyError):\n    \"\"\"Raised when a write operation is attempted while the write policy denies writes.\"\"\"\n\n    def __init__(self, message: str, *, method: str, url: str):\n        super().__init__(message, diagnostics=ErrorDiagnostics(method=method, url=url))\n        self.method = method\n        self.url = url\n</code></pre>"},{"location":"reference/exceptions/#affinity.exceptions.error_from_response","title":"<code>error_from_response(status_code: int, response_body: Any, *, retry_after: int | None = None, diagnostics: ErrorDiagnostics | None = None) -&gt; AffinityError</code>","text":"<p>Create the appropriate exception from an API error response.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>HTTP status code</p> required <code>response_body</code> <code>Any</code> <p>Parsed response body (usually dict with 'errors')</p> required <code>retry_after</code> <code>int | None</code> <p>Retry-After header value for rate limits</p> <code>None</code> <p>Returns:</p> Type Description <code>AffinityError</code> <p>Appropriate AffinityError subclass</p> Source code in <code>affinity/exceptions.py</code> <pre><code>def error_from_response(\n    status_code: int,\n    response_body: Any,\n    *,\n    retry_after: int | None = None,\n    diagnostics: ErrorDiagnostics | None = None,\n) -&gt; AffinityError:\n    \"\"\"\n    Create the appropriate exception from an API error response.\n\n    Args:\n        status_code: HTTP status code\n        response_body: Parsed response body (usually dict with 'errors')\n        retry_after: Retry-After header value for rate limits\n\n    Returns:\n        Appropriate AffinityError subclass\n    \"\"\"\n    # Try to extract message from response\n    message = \"Unknown error\"\n    param = None\n\n    extracted = False\n    if isinstance(response_body, dict):\n        errors = response_body.get(\"errors\")\n        if isinstance(errors, list) and errors:\n            for item in errors:\n                if isinstance(item, dict):\n                    msg = item.get(\"message\")\n                    if isinstance(msg, str) and msg.strip():\n                        message = msg.strip()\n                        p = item.get(\"param\")\n                        if isinstance(p, str) and p.strip():\n                            param = p\n                        extracted = True\n                        break\n                elif isinstance(item, str) and item.strip():\n                    message = item.strip()\n                    extracted = True\n                    break\n\n        if not extracted:\n            top_message = response_body.get(\"message\")\n            if isinstance(top_message, str) and top_message.strip():\n                message = top_message.strip()\n                extracted = True\n            else:\n                detail = response_body.get(\"detail\")\n                if isinstance(detail, str) and detail.strip():\n                    message = detail.strip()\n                    extracted = True\n                else:\n                    error_obj = response_body.get(\"error\")\n                    if isinstance(error_obj, dict):\n                        nested_message = error_obj.get(\"message\")\n                        if isinstance(nested_message, str) and nested_message.strip():\n                            message = nested_message.strip()\n                            extracted = True\n                    elif isinstance(error_obj, str) and error_obj.strip():\n                        message = error_obj.strip()\n                        extracted = True\n\n    if not extracted and isinstance(response_body, list) and response_body:\n        first = response_body[0]\n        if isinstance(first, dict):\n            msg = first.get(\"message\") or first.get(\"error\") or first.get(\"detail\")\n            if isinstance(msg, str) and msg.strip():\n                message = msg.strip()\n                extracted = True\n        elif isinstance(first, str) and first.strip():\n            message = first.strip()\n            extracted = True\n\n    if (\n        message == \"Unknown error\"\n        and diagnostics is not None\n        and isinstance(diagnostics.response_body_snippet, str)\n    ):\n        snippet = diagnostics.response_body_snippet.strip()\n        if snippet and snippet not in {\"{}\", \"[]\"}:\n            message = snippet\n\n    # Map status codes to exceptions\n    error_mapping: dict[int, type[AffinityError]] = {\n        400: ValidationError,\n        401: AuthenticationError,\n        403: AuthorizationError,\n        404: NotFoundError,\n        409: ConflictError,\n        422: ValidationError,\n        429: RateLimitError,\n        500: ServerError,\n        502: ServerError,\n        503: ServerError,\n        504: ServerError,\n    }\n\n    error_class = error_mapping.get(status_code, AffinityError)\n\n    # Special handling for ValidationError with param\n    if error_class is ValidationError:\n        return ValidationError(\n            message,\n            param=param,\n            status_code=status_code,\n            response_body=response_body,\n            diagnostics=diagnostics,\n        )\n\n    # Special handling for RateLimitError with retry_after\n    if error_class is RateLimitError:\n        return RateLimitError(\n            message,\n            retry_after=retry_after,\n            status_code=status_code,\n            response_body=response_body,\n            diagnostics=diagnostics,\n        )\n\n    return error_class(\n        message,\n        status_code=status_code,\n        response_body=response_body,\n        diagnostics=diagnostics,\n    )\n</code></pre>"},{"location":"reference/filters/","title":"Filters","text":"<p>Filter builder for V2 API filtering support.</p> <p>Provides a type-safe, Pythonic way to build filter expressions for V2 list endpoints. The builder handles proper escaping and quoting of user inputs.</p> Example <p>from affinity.filters import Filter, F</p>"},{"location":"reference/filters/#affinity.filters--using-the-builder-recommended","title":"Using the builder (recommended)","text":"<p>filter = (     F.field(\"name\").contains(\"Acme\") &amp;     F.field(\"status\").equals(\"Active\") ) companies = client.companies.list(filter=filter)</p>"},{"location":"reference/filters/#affinity.filters--or-build-complex-filters","title":"Or build complex filters","text":"<p>filter = (     (F.field(\"name\").contains(\"Corp\") | F.field(\"name\").contains(\"Inc\")) &amp;     ~F.field(\"archived\").equals(True) )</p>"},{"location":"reference/filters/#affinity.filters--raw-filter-string-escape-hatch-power-users","title":"Raw filter string escape hatch (power users)","text":"<p>companies = client.companies.list(filter='name =~ \"Acme\"')</p>"},{"location":"reference/filters/#affinity.filters.AndExpression","title":"<code>AndExpression</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FilterExpression</code></p> <p><code>&amp;</code> combination of two expressions.</p> Source code in <code>affinity/filters.py</code> <pre><code>@dataclass\nclass AndExpression(FilterExpression):\n    \"\"\"`&amp;` combination of two expressions.\"\"\"\n\n    left: FilterExpression\n    right: FilterExpression\n\n    def to_string(self) -&gt; str:\n        left_str = self.left.to_string()\n        right_str = self.right.to_string()\n        # Wrap in parentheses for correct precedence\n        return f\"({left_str}) &amp; ({right_str})\"\n\n    def matches(self, entity: dict[str, Any]) -&gt; bool:\n        \"\"\"Both sides must match.\"\"\"\n        return self.left.matches(entity) and self.right.matches(entity)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.AndExpression.matches","title":"<code>matches(entity: dict[str, Any]) -&gt; bool</code>","text":"<p>Both sides must match.</p> Source code in <code>affinity/filters.py</code> <pre><code>def matches(self, entity: dict[str, Any]) -&gt; bool:\n    \"\"\"Both sides must match.\"\"\"\n    return self.left.matches(entity) and self.right.matches(entity)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder","title":"<code>FieldBuilder</code>","text":"<p>Builder for field-based filter expressions.</p> Source code in <code>affinity/filters.py</code> <pre><code>class FieldBuilder:\n    \"\"\"Builder for field-based filter expressions.\"\"\"\n\n    def __init__(self, field_name: str):\n        self._field_name = field_name\n\n    def equals(self, value: Any) -&gt; FieldComparison:\n        \"\"\"Field equals value (exact match).\"\"\"\n        return FieldComparison(self._field_name, \"=\", value)\n\n    def not_equals(self, value: Any) -&gt; FieldComparison:\n        \"\"\"Field does not equal value.\"\"\"\n        return FieldComparison(self._field_name, \"!=\", value)\n\n    def contains(self, value: str) -&gt; FieldComparison:\n        \"\"\"Field contains substring (case-insensitive).\"\"\"\n        return FieldComparison(self._field_name, \"=~\", value)\n\n    def starts_with(self, value: str) -&gt; FieldComparison:\n        \"\"\"Field starts with prefix.\"\"\"\n        return FieldComparison(self._field_name, \"=^\", value)\n\n    def ends_with(self, value: str) -&gt; FieldComparison:\n        \"\"\"Field ends with suffix.\"\"\"\n        return FieldComparison(self._field_name, \"=$\", value)\n\n    def greater_than(self, value: int | float | datetime | date) -&gt; FieldComparison:\n        \"\"\"Field is greater than value.\"\"\"\n        return FieldComparison(self._field_name, \"&gt;\", value)\n\n    def greater_than_or_equal(self, value: int | float | datetime | date) -&gt; FieldComparison:\n        \"\"\"Field is greater than or equal to value.\"\"\"\n        return FieldComparison(self._field_name, \"&gt;=\", value)\n\n    def less_than(self, value: int | float | datetime | date) -&gt; FieldComparison:\n        \"\"\"Field is less than value.\"\"\"\n        return FieldComparison(self._field_name, \"&lt;\", value)\n\n    def less_than_or_equal(self, value: int | float | datetime | date) -&gt; FieldComparison:\n        \"\"\"Field is less than or equal to value.\"\"\"\n        return FieldComparison(self._field_name, \"&lt;=\", value)\n\n    def is_null(self) -&gt; FieldComparison:\n        \"\"\"Field is null.\"\"\"\n        return FieldComparison(self._field_name, \"!=\", RawToken(\"*\"))\n\n    def is_not_null(self) -&gt; FieldComparison:\n        \"\"\"Field is not null.\"\"\"\n        return FieldComparison(self._field_name, \"=\", RawToken(\"*\"))\n\n    def in_list(self, values: list[Any]) -&gt; FilterExpression:\n        \"\"\"Field value is in the given list (OR of equals).\"\"\"\n        if not values:\n            raise ValueError(\"in_list() requires at least one value\")\n        expressions: list[FilterExpression] = [self.equals(v) for v in values]\n        result: FilterExpression = expressions[0]\n        for expr in expressions[1:]:\n            result = result | expr\n        return result\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.contains","title":"<code>contains(value: str) -&gt; FieldComparison</code>","text":"<p>Field contains substring (case-insensitive).</p> Source code in <code>affinity/filters.py</code> <pre><code>def contains(self, value: str) -&gt; FieldComparison:\n    \"\"\"Field contains substring (case-insensitive).\"\"\"\n    return FieldComparison(self._field_name, \"=~\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.ends_with","title":"<code>ends_with(value: str) -&gt; FieldComparison</code>","text":"<p>Field ends with suffix.</p> Source code in <code>affinity/filters.py</code> <pre><code>def ends_with(self, value: str) -&gt; FieldComparison:\n    \"\"\"Field ends with suffix.\"\"\"\n    return FieldComparison(self._field_name, \"=$\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.equals","title":"<code>equals(value: Any) -&gt; FieldComparison</code>","text":"<p>Field equals value (exact match).</p> Source code in <code>affinity/filters.py</code> <pre><code>def equals(self, value: Any) -&gt; FieldComparison:\n    \"\"\"Field equals value (exact match).\"\"\"\n    return FieldComparison(self._field_name, \"=\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.greater_than","title":"<code>greater_than(value: int | float | datetime | date) -&gt; FieldComparison</code>","text":"<p>Field is greater than value.</p> Source code in <code>affinity/filters.py</code> <pre><code>def greater_than(self, value: int | float | datetime | date) -&gt; FieldComparison:\n    \"\"\"Field is greater than value.\"\"\"\n    return FieldComparison(self._field_name, \"&gt;\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.greater_than_or_equal","title":"<code>greater_than_or_equal(value: int | float | datetime | date) -&gt; FieldComparison</code>","text":"<p>Field is greater than or equal to value.</p> Source code in <code>affinity/filters.py</code> <pre><code>def greater_than_or_equal(self, value: int | float | datetime | date) -&gt; FieldComparison:\n    \"\"\"Field is greater than or equal to value.\"\"\"\n    return FieldComparison(self._field_name, \"&gt;=\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.in_list","title":"<code>in_list(values: list[Any]) -&gt; FilterExpression</code>","text":"<p>Field value is in the given list (OR of equals).</p> Source code in <code>affinity/filters.py</code> <pre><code>def in_list(self, values: list[Any]) -&gt; FilterExpression:\n    \"\"\"Field value is in the given list (OR of equals).\"\"\"\n    if not values:\n        raise ValueError(\"in_list() requires at least one value\")\n    expressions: list[FilterExpression] = [self.equals(v) for v in values]\n    result: FilterExpression = expressions[0]\n    for expr in expressions[1:]:\n        result = result | expr\n    return result\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.is_not_null","title":"<code>is_not_null() -&gt; FieldComparison</code>","text":"<p>Field is not null.</p> Source code in <code>affinity/filters.py</code> <pre><code>def is_not_null(self) -&gt; FieldComparison:\n    \"\"\"Field is not null.\"\"\"\n    return FieldComparison(self._field_name, \"=\", RawToken(\"*\"))\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.is_null","title":"<code>is_null() -&gt; FieldComparison</code>","text":"<p>Field is null.</p> Source code in <code>affinity/filters.py</code> <pre><code>def is_null(self) -&gt; FieldComparison:\n    \"\"\"Field is null.\"\"\"\n    return FieldComparison(self._field_name, \"!=\", RawToken(\"*\"))\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.less_than","title":"<code>less_than(value: int | float | datetime | date) -&gt; FieldComparison</code>","text":"<p>Field is less than value.</p> Source code in <code>affinity/filters.py</code> <pre><code>def less_than(self, value: int | float | datetime | date) -&gt; FieldComparison:\n    \"\"\"Field is less than value.\"\"\"\n    return FieldComparison(self._field_name, \"&lt;\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.less_than_or_equal","title":"<code>less_than_or_equal(value: int | float | datetime | date) -&gt; FieldComparison</code>","text":"<p>Field is less than or equal to value.</p> Source code in <code>affinity/filters.py</code> <pre><code>def less_than_or_equal(self, value: int | float | datetime | date) -&gt; FieldComparison:\n    \"\"\"Field is less than or equal to value.\"\"\"\n    return FieldComparison(self._field_name, \"&lt;=\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.not_equals","title":"<code>not_equals(value: Any) -&gt; FieldComparison</code>","text":"<p>Field does not equal value.</p> Source code in <code>affinity/filters.py</code> <pre><code>def not_equals(self, value: Any) -&gt; FieldComparison:\n    \"\"\"Field does not equal value.\"\"\"\n    return FieldComparison(self._field_name, \"!=\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldBuilder.starts_with","title":"<code>starts_with(value: str) -&gt; FieldComparison</code>","text":"<p>Field starts with prefix.</p> Source code in <code>affinity/filters.py</code> <pre><code>def starts_with(self, value: str) -&gt; FieldComparison:\n    \"\"\"Field starts with prefix.\"\"\"\n    return FieldComparison(self._field_name, \"=^\", value)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldComparison","title":"<code>FieldComparison</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FilterExpression</code></p> <p>A comparison operation on a field.</p> Source code in <code>affinity/filters.py</code> <pre><code>@dataclass\nclass FieldComparison(FilterExpression):\n    \"\"\"A comparison operation on a field.\"\"\"\n\n    field_name: str\n    operator: str\n    value: Any\n\n    def to_string(self) -&gt; str:\n        formatted_value = _format_value(self.value)\n        return f\"{self.field_name} {self.operator} {formatted_value}\"\n\n    def matches(self, entity: dict[str, Any]) -&gt; bool:\n        \"\"\"Evaluate field comparison against an entity dict.\n\n        For multi-select dropdown fields (arrays), the operators have special semantics:\n        - `=` with scalar: checks if value is IN the array (membership)\n        - `=` with list: checks set equality (order-insensitive)\n        - `!=` with scalar: checks if value is NOT in the array\n        - `!=` with list: checks set inequality\n        - `=~` (contains): checks if any array element contains the substring\n        - `=^` (starts_with): checks if any array element starts with the prefix\n        - `=$` (ends_with): checks if any array element ends with the suffix\n        - `&gt;`, `&gt;=`, `&lt;`, `&lt;=`: numeric/date comparisons\n\n        Uses the shared compare module for consistent behavior across SDK and Query tool.\n        \"\"\"\n        field_value = _get_entity_value(entity, self.field_name)\n\n        # Normalize dropdown dicts and multi-select arrays\n        field_value = normalize_value(field_value)\n\n        # Handle NULL checks (Affinity convention: =* means NOT NULL, !=* means IS NULL)\n        if isinstance(self.value, RawToken) and self.value.token == \"*\":\n            if self.operator == \"=\":\n                return compare_values(field_value, None, \"is_not_null\")\n            elif self.operator == \"!=\":\n                return compare_values(field_value, None, \"is_null\")\n\n        # Extract target value\n        target = self.value if not isinstance(self.value, RawToken) else self.value.token\n\n        # Map SDK operator symbol to canonical operator name\n        try:\n            canonical_op = map_operator(self.operator)\n        except ValueError:\n            raise ValueError(\n                f\"Unsupported operator '{self.operator}' for client-side matching. \"\n                f\"Supported operators: =, !=, =~, =^, =$, &gt;, &gt;=, &lt;, &lt;=, \"\n                f\"contains, starts_with, ends_with, gt, gte, lt, lte, \"\n                f\"is null, is not null, is empty, \"\n                f\"in, between, has_any, has_all, contains_any, contains_all\"\n            ) from None\n\n        return compare_values(field_value, target, canonical_op)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FieldComparison.matches","title":"<code>matches(entity: dict[str, Any]) -&gt; bool</code>","text":"<p>Evaluate field comparison against an entity dict.</p> <p>For multi-select dropdown fields (arrays), the operators have special semantics: - <code>=</code> with scalar: checks if value is IN the array (membership) - <code>=</code> with list: checks set equality (order-insensitive) - <code>!=</code> with scalar: checks if value is NOT in the array - <code>!=</code> with list: checks set inequality - <code>=~</code> (contains): checks if any array element contains the substring - <code>=^</code> (starts_with): checks if any array element starts with the prefix - <code>=$</code> (ends_with): checks if any array element ends with the suffix - <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>: numeric/date comparisons</p> <p>Uses the shared compare module for consistent behavior across SDK and Query tool.</p> Source code in <code>affinity/filters.py</code> <pre><code>def matches(self, entity: dict[str, Any]) -&gt; bool:\n    \"\"\"Evaluate field comparison against an entity dict.\n\n    For multi-select dropdown fields (arrays), the operators have special semantics:\n    - `=` with scalar: checks if value is IN the array (membership)\n    - `=` with list: checks set equality (order-insensitive)\n    - `!=` with scalar: checks if value is NOT in the array\n    - `!=` with list: checks set inequality\n    - `=~` (contains): checks if any array element contains the substring\n    - `=^` (starts_with): checks if any array element starts with the prefix\n    - `=$` (ends_with): checks if any array element ends with the suffix\n    - `&gt;`, `&gt;=`, `&lt;`, `&lt;=`: numeric/date comparisons\n\n    Uses the shared compare module for consistent behavior across SDK and Query tool.\n    \"\"\"\n    field_value = _get_entity_value(entity, self.field_name)\n\n    # Normalize dropdown dicts and multi-select arrays\n    field_value = normalize_value(field_value)\n\n    # Handle NULL checks (Affinity convention: =* means NOT NULL, !=* means IS NULL)\n    if isinstance(self.value, RawToken) and self.value.token == \"*\":\n        if self.operator == \"=\":\n            return compare_values(field_value, None, \"is_not_null\")\n        elif self.operator == \"!=\":\n            return compare_values(field_value, None, \"is_null\")\n\n    # Extract target value\n    target = self.value if not isinstance(self.value, RawToken) else self.value.token\n\n    # Map SDK operator symbol to canonical operator name\n    try:\n        canonical_op = map_operator(self.operator)\n    except ValueError:\n        raise ValueError(\n            f\"Unsupported operator '{self.operator}' for client-side matching. \"\n            f\"Supported operators: =, !=, =~, =^, =$, &gt;, &gt;=, &lt;, &lt;=, \"\n            f\"contains, starts_with, ends_with, gt, gte, lt, lte, \"\n            f\"is null, is not null, is empty, \"\n            f\"in, between, has_any, has_all, contains_any, contains_all\"\n        ) from None\n\n    return compare_values(field_value, target, canonical_op)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.Filter","title":"<code>Filter</code>","text":"<p>Factory for building filter expressions.</p> Example Source code in <code>affinity/filters.py</code> <pre><code>class Filter:\n    \"\"\"\n    Factory for building filter expressions.\n\n    Example:\n        # Simple comparison\n        Filter.field(\"name\").contains(\"Acme\")\n\n        # Complex boolean logic\n        (Filter.field(\"status\").equals(\"Active\") &amp;\n         Filter.field(\"type\").in_list([\"customer\", \"prospect\"]))\n\n        # Negation\n        ~Filter.field(\"archived\").equals(True)\n    \"\"\"\n\n    @staticmethod\n    def field(name: str) -&gt; FieldBuilder:\n        \"\"\"Start building a filter on a field.\"\"\"\n        return FieldBuilder(name)\n\n    @staticmethod\n    def raw(expression: str) -&gt; RawFilter:\n        \"\"\"\n        Create a raw filter expression (escape hatch).\n\n        Use this when you need filter syntax not supported by the builder.\n        The expression is passed directly to the API without modification.\n\n        Args:\n            expression: Raw filter string (e.g., 'name =~ \"Acme\"')\n        \"\"\"\n        return RawFilter(expression)\n\n    @staticmethod\n    def and_(*expressions: FilterExpression) -&gt; FilterExpression:\n        \"\"\"Combine multiple expressions with `&amp;`.\"\"\"\n        if not expressions:\n            raise ValueError(\"and_() requires at least one expression\")\n        result = expressions[0]\n        for expr in expressions[1:]:\n            result = result &amp; expr\n        return result\n\n    @staticmethod\n    def or_(*expressions: FilterExpression) -&gt; FilterExpression:\n        \"\"\"Combine multiple expressions with `|`.\"\"\"\n        if not expressions:\n            raise ValueError(\"or_() requires at least one expression\")\n        result = expressions[0]\n        for expr in expressions[1:]:\n            result = result | expr\n        return result\n</code></pre>"},{"location":"reference/filters/#affinity.filters.Filter--simple-comparison","title":"Simple comparison","text":"<p>Filter.field(\"name\").contains(\"Acme\")</p>"},{"location":"reference/filters/#affinity.filters.Filter--complex-boolean-logic","title":"Complex boolean logic","text":"<p>(Filter.field(\"status\").equals(\"Active\") &amp;  Filter.field(\"type\").in_list([\"customer\", \"prospect\"]))</p>"},{"location":"reference/filters/#affinity.filters.Filter--negation","title":"Negation","text":"<p>~Filter.field(\"archived\").equals(True)</p>"},{"location":"reference/filters/#affinity.filters.Filter.and_","title":"<code>and_(*expressions: FilterExpression) -&gt; FilterExpression</code>  <code>staticmethod</code>","text":"<p>Combine multiple expressions with <code>&amp;</code>.</p> Source code in <code>affinity/filters.py</code> <pre><code>@staticmethod\ndef and_(*expressions: FilterExpression) -&gt; FilterExpression:\n    \"\"\"Combine multiple expressions with `&amp;`.\"\"\"\n    if not expressions:\n        raise ValueError(\"and_() requires at least one expression\")\n    result = expressions[0]\n    for expr in expressions[1:]:\n        result = result &amp; expr\n    return result\n</code></pre>"},{"location":"reference/filters/#affinity.filters.Filter.field","title":"<code>field(name: str) -&gt; FieldBuilder</code>  <code>staticmethod</code>","text":"<p>Start building a filter on a field.</p> Source code in <code>affinity/filters.py</code> <pre><code>@staticmethod\ndef field(name: str) -&gt; FieldBuilder:\n    \"\"\"Start building a filter on a field.\"\"\"\n    return FieldBuilder(name)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.Filter.or_","title":"<code>or_(*expressions: FilterExpression) -&gt; FilterExpression</code>  <code>staticmethod</code>","text":"<p>Combine multiple expressions with <code>|</code>.</p> Source code in <code>affinity/filters.py</code> <pre><code>@staticmethod\ndef or_(*expressions: FilterExpression) -&gt; FilterExpression:\n    \"\"\"Combine multiple expressions with `|`.\"\"\"\n    if not expressions:\n        raise ValueError(\"or_() requires at least one expression\")\n    result = expressions[0]\n    for expr in expressions[1:]:\n        result = result | expr\n    return result\n</code></pre>"},{"location":"reference/filters/#affinity.filters.Filter.raw","title":"<code>raw(expression: str) -&gt; RawFilter</code>  <code>staticmethod</code>","text":"<p>Create a raw filter expression (escape hatch).</p> <p>Use this when you need filter syntax not supported by the builder. The expression is passed directly to the API without modification.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>Raw filter string (e.g., 'name =~ \"Acme\"')</p> required Source code in <code>affinity/filters.py</code> <pre><code>@staticmethod\ndef raw(expression: str) -&gt; RawFilter:\n    \"\"\"\n    Create a raw filter expression (escape hatch).\n\n    Use this when you need filter syntax not supported by the builder.\n    The expression is passed directly to the API without modification.\n\n    Args:\n        expression: Raw filter string (e.g., 'name =~ \"Acme\"')\n    \"\"\"\n    return RawFilter(expression)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FilterExpression","title":"<code>FilterExpression</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for filter expressions.</p> Source code in <code>affinity/filters.py</code> <pre><code>class FilterExpression(ABC):\n    \"\"\"Base class for filter expressions.\"\"\"\n\n    @abstractmethod\n    def to_string(self) -&gt; str:\n        \"\"\"Convert the expression to a filter string.\"\"\"\n        ...\n\n    @abstractmethod\n    def matches(self, entity: dict[str, Any]) -&gt; bool:\n        \"\"\"\n        Evaluate filter against an entity dict (client-side).\n\n        Used for --expand-filter in list export where filtering happens\n        after fetching data from the API.\n        \"\"\"\n        ...\n\n    def __and__(self, other: FilterExpression) -&gt; FilterExpression:\n        \"\"\"Combine two expressions with `&amp;`.\"\"\"\n        return AndExpression(self, other)\n\n    def __or__(self, other: FilterExpression) -&gt; FilterExpression:\n        \"\"\"Combine two expressions with `|`.\"\"\"\n        return OrExpression(self, other)\n\n    def __invert__(self) -&gt; FilterExpression:\n        \"\"\"Negate the expression with `!`.\"\"\"\n        return NotExpression(self)\n\n    def __str__(self) -&gt; str:\n        return self.to_string()\n\n    def __repr__(self) -&gt; str:\n        return f\"Filter({self.to_string()!r})\"\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FilterExpression.__and__","title":"<code>__and__(other: FilterExpression) -&gt; FilterExpression</code>","text":"<p>Combine two expressions with <code>&amp;</code>.</p> Source code in <code>affinity/filters.py</code> <pre><code>def __and__(self, other: FilterExpression) -&gt; FilterExpression:\n    \"\"\"Combine two expressions with `&amp;`.\"\"\"\n    return AndExpression(self, other)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FilterExpression.__invert__","title":"<code>__invert__() -&gt; FilterExpression</code>","text":"<p>Negate the expression with <code>!</code>.</p> Source code in <code>affinity/filters.py</code> <pre><code>def __invert__(self) -&gt; FilterExpression:\n    \"\"\"Negate the expression with `!`.\"\"\"\n    return NotExpression(self)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FilterExpression.__or__","title":"<code>__or__(other: FilterExpression) -&gt; FilterExpression</code>","text":"<p>Combine two expressions with <code>|</code>.</p> Source code in <code>affinity/filters.py</code> <pre><code>def __or__(self, other: FilterExpression) -&gt; FilterExpression:\n    \"\"\"Combine two expressions with `|`.\"\"\"\n    return OrExpression(self, other)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FilterExpression.matches","title":"<code>matches(entity: dict[str, Any]) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Evaluate filter against an entity dict (client-side).</p> <p>Used for --expand-filter in list export where filtering happens after fetching data from the API.</p> Source code in <code>affinity/filters.py</code> <pre><code>@abstractmethod\ndef matches(self, entity: dict[str, Any]) -&gt; bool:\n    \"\"\"\n    Evaluate filter against an entity dict (client-side).\n\n    Used for --expand-filter in list export where filtering happens\n    after fetching data from the API.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/filters/#affinity.filters.FilterExpression.to_string","title":"<code>to_string() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Convert the expression to a filter string.</p> Source code in <code>affinity/filters.py</code> <pre><code>@abstractmethod\ndef to_string(self) -&gt; str:\n    \"\"\"Convert the expression to a filter string.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/filters/#affinity.filters.NotExpression","title":"<code>NotExpression</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FilterExpression</code></p> <p><code>!</code> negation of an expression.</p> Source code in <code>affinity/filters.py</code> <pre><code>@dataclass\nclass NotExpression(FilterExpression):\n    \"\"\"`!` negation of an expression.\"\"\"\n\n    expr: FilterExpression\n\n    def to_string(self) -&gt; str:\n        return f\"!({self.expr.to_string()})\"\n\n    def matches(self, entity: dict[str, Any]) -&gt; bool:\n        \"\"\"Invert the inner expression.\"\"\"\n        return not self.expr.matches(entity)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.NotExpression.matches","title":"<code>matches(entity: dict[str, Any]) -&gt; bool</code>","text":"<p>Invert the inner expression.</p> Source code in <code>affinity/filters.py</code> <pre><code>def matches(self, entity: dict[str, Any]) -&gt; bool:\n    \"\"\"Invert the inner expression.\"\"\"\n    return not self.expr.matches(entity)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.OrExpression","title":"<code>OrExpression</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FilterExpression</code></p> <p><code>|</code> combination of two expressions.</p> Source code in <code>affinity/filters.py</code> <pre><code>@dataclass\nclass OrExpression(FilterExpression):\n    \"\"\"`|` combination of two expressions.\"\"\"\n\n    left: FilterExpression\n    right: FilterExpression\n\n    def to_string(self) -&gt; str:\n        left_str = self.left.to_string()\n        right_str = self.right.to_string()\n        return f\"({left_str}) | ({right_str})\"\n\n    def matches(self, entity: dict[str, Any]) -&gt; bool:\n        \"\"\"Either side must match.\"\"\"\n        return self.left.matches(entity) or self.right.matches(entity)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.OrExpression.matches","title":"<code>matches(entity: dict[str, Any]) -&gt; bool</code>","text":"<p>Either side must match.</p> Source code in <code>affinity/filters.py</code> <pre><code>def matches(self, entity: dict[str, Any]) -&gt; bool:\n    \"\"\"Either side must match.\"\"\"\n    return self.left.matches(entity) or self.right.matches(entity)\n</code></pre>"},{"location":"reference/filters/#affinity.filters.RawFilter","title":"<code>RawFilter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FilterExpression</code></p> <p>A raw filter string (escape hatch for power users).</p> Source code in <code>affinity/filters.py</code> <pre><code>@dataclass\nclass RawFilter(FilterExpression):\n    \"\"\"A raw filter string (escape hatch for power users).\"\"\"\n\n    expression: str\n\n    def to_string(self) -&gt; str:\n        return self.expression\n\n    def matches(self, entity: dict[str, Any]) -&gt; bool:\n        \"\"\"RawFilter cannot be evaluated client-side.\"\"\"\n        raise NotImplementedError(\n            \"RawFilter cannot be evaluated client-side. \"\n            \"Use structured filter expressions for --expand-filter.\"\n        )\n</code></pre>"},{"location":"reference/filters/#affinity.filters.RawFilter.matches","title":"<code>matches(entity: dict[str, Any]) -&gt; bool</code>","text":"<p>RawFilter cannot be evaluated client-side.</p> Source code in <code>affinity/filters.py</code> <pre><code>def matches(self, entity: dict[str, Any]) -&gt; bool:\n    \"\"\"RawFilter cannot be evaluated client-side.\"\"\"\n    raise NotImplementedError(\n        \"RawFilter cannot be evaluated client-side. \"\n        \"Use structured filter expressions for --expand-filter.\"\n    )\n</code></pre>"},{"location":"reference/filters/#affinity.filters.RawToken","title":"<code>RawToken</code>  <code>dataclass</code>","text":"<p>A raw token inserted into a filter expression without quoting.</p> <p>Used for special Affinity Filtering Language literals like <code>*</code>.</p> Source code in <code>affinity/filters.py</code> <pre><code>@dataclass(frozen=True)\nclass RawToken:\n    \"\"\"\n    A raw token inserted into a filter expression without quoting.\n\n    Used for special Affinity Filtering Language literals like `*`.\n    \"\"\"\n\n    token: str\n</code></pre>"},{"location":"reference/filters/#affinity.filters.parse","title":"<code>parse(filter_string: str) -&gt; FilterExpression</code>","text":"<p>Parse a filter string into a FilterExpression AST.</p> <p>This function converts a human-readable filter string into a structured FilterExpression that can be used for client-side filtering with matches().</p> <p>Parameters:</p> Name Type Description Default <code>filter_string</code> <code>str</code> <p>The filter expression to parse</p> required <p>Returns:</p> Type Description <code>FilterExpression</code> <p>A FilterExpression AST representing the filter</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the filter string is invalid</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = parse('name = \"Alice\"')\n&gt;&gt;&gt; expr.matches({\"name\": \"Alice\"})\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; expr = parse('status = Active | status = Pending')\n&gt;&gt;&gt; expr.matches({\"status\": \"Active\"})\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; expr = parse('email = *')  # IS NOT NULL\n&gt;&gt;&gt; expr.matches({\"email\": \"test@example.com\"})\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; expr = parse('email != *')  # IS NULL\n&gt;&gt;&gt; expr.matches({\"email\": None})\nTrue\n</code></pre> Source code in <code>affinity/filters.py</code> <pre><code>def parse(filter_string: str) -&gt; FilterExpression:\n    \"\"\"\n    Parse a filter string into a FilterExpression AST.\n\n    This function converts a human-readable filter string into a structured\n    FilterExpression that can be used for client-side filtering with matches().\n\n    Args:\n        filter_string: The filter expression to parse\n\n    Returns:\n        A FilterExpression AST representing the filter\n\n    Raises:\n        ValueError: If the filter string is invalid\n\n    Examples:\n        &gt;&gt;&gt; expr = parse('name = \"Alice\"')\n        &gt;&gt;&gt; expr.matches({\"name\": \"Alice\"})\n        True\n\n        &gt;&gt;&gt; expr = parse('status = Active | status = Pending')\n        &gt;&gt;&gt; expr.matches({\"status\": \"Active\"})\n        True\n\n        &gt;&gt;&gt; expr = parse('email = *')  # IS NOT NULL\n        &gt;&gt;&gt; expr.matches({\"email\": \"test@example.com\"})\n        True\n\n        &gt;&gt;&gt; expr = parse('email != *')  # IS NULL\n        &gt;&gt;&gt; expr.matches({\"email\": None})\n        True\n    \"\"\"\n    if not filter_string or not filter_string.strip():\n        raise ValueError(\"Empty filter expression\")\n\n    tokenizer = _Tokenizer(filter_string)\n    tokens = tokenizer.tokenize()\n    parser = _Parser(tokens)\n    return parser.parse()\n</code></pre>"},{"location":"reference/models/","title":"Models","text":"<p>Affinity data models.</p> <p>All Pydantic models are available from this module.</p> Tip <p>ID types and enums live in <code>affinity.types</code>.</p>"},{"location":"reference/models/#affinity.models.AffinityList","title":"<code>AffinityList</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A list (spreadsheet) in Affinity.</p> <p>Named AffinityList to avoid collision with Python's list type.</p> Note <p>The list_size field was removed in v0.13.0 because the V2 API returns incorrect values (often 0 for non-empty lists). Use <code>client.lists.get_size(list_id)</code> to get accurate list size via V1 API.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class AffinityList(AffinityModel):\n    \"\"\"\n    A list (spreadsheet) in Affinity.\n\n    Named AffinityList to avoid collision with Python's list type.\n\n    Note:\n        The list_size field was removed in v0.13.0 because the V2 API returns\n        incorrect values (often 0 for non-empty lists). Use\n        ``client.lists.get_size(list_id)`` to get accurate list size via V1 API.\n    \"\"\"\n\n    id: ListId\n    name: str\n    type: ListType\n    is_public: bool = Field(alias=\"public\")\n    owner_id: UserId = Field(alias=\"ownerId\")\n    creator_id: UserId | None = Field(None, alias=\"creatorId\")\n\n    # Fields on this list (returned for single list fetch)\n    fields: list[FieldMetadata] | None = None\n\n    # Permissions\n    additional_permissions: list[ListPermission] = Field(\n        default_factory=list, alias=\"additionalPermissions\"\n    )\n\n    # Internal - not guaranteed accurate from V2. Excluded from serialization.\n    # Populated from listSize (V2) or list_size (V1) via model_validator + model_post_init.\n    _list_size_hint: int = PrivateAttr(default=0)\n\n    # Temporary field to pass list_size from validator to model_post_init (excluded from output)\n    list_size_temp: int | None = Field(None, exclude=True, repr=False)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _extract_list_size(cls, data: dict[str, Any]) -&gt; dict[str, Any]:\n        # V2 list endpoints use `isPublic`; v1 uses `public`.\n        if isinstance(data, Mapping):\n            data = dict(data)\n            if \"public\" not in data and \"isPublic\" in data:\n                data[\"public\"] = data.get(\"isPublic\")\n            # Extract listSize and pass via temp field (V2 uses listSize, V1 uses list_size)\n            if \"listSize\" in data:\n                data[\"list_size_temp\"] = data.pop(\"listSize\")\n            elif \"list_size\" in data:\n                data[\"list_size_temp\"] = data.pop(\"list_size\")\n        return data\n\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Transfer list_size_temp to _list_size_hint private attr.\"\"\"\n        if self.list_size_temp is not None:\n            object.__setattr__(self, \"_list_size_hint\", self.list_size_temp)\n            # Clear the temp field\n            object.__setattr__(self, \"list_size_temp\", None)\n</code></pre>"},{"location":"reference/models/#affinity.models.AffinityList.model_post_init","title":"<code>model_post_init(__context: Any) -&gt; None</code>","text":"<p>Transfer list_size_temp to _list_size_hint private attr.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Transfer list_size_temp to _list_size_hint private attr.\"\"\"\n    if self.list_size_temp is not None:\n        object.__setattr__(self, \"_list_size_hint\", self.list_size_temp)\n        # Clear the temp field\n        object.__setattr__(self, \"list_size_temp\", None)\n</code></pre>"},{"location":"reference/models/#affinity.models.AffinityModel","title":"<code>AffinityModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model with common configuration.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class AffinityModel(BaseModel):\n    \"\"\"Base model with common configuration.\"\"\"\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Ignore unknown fields from API\n        populate_by_name=True,  # Allow both alias and field name\n        use_enum_values=True,  # Serialize enums as values\n        validate_assignment=True,  # Validate on attribute assignment\n    )\n</code></pre>"},{"location":"reference/models/#affinity.models.AsyncPageIterator","title":"<code>AsyncPageIterator</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Asynchronous iterator that automatically fetches all pages.</p> Usage <p>async for item in client.companies.all():     print(item.name)</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>class AsyncPageIterator(Generic[T]):\n    \"\"\"\n    Asynchronous iterator that automatically fetches all pages.\n\n    Usage:\n        async for item in client.companies.all():\n            print(item.name)\n    \"\"\"\n\n    def __init__(\n        self,\n        fetch_page: Callable[[str | None], Awaitable[PaginatedResponse[T]]],\n        initial_cursor: str | None = None,\n    ):\n        self._fetch_page = fetch_page\n        self._next_cursor = initial_cursor\n        self._current_page: list[T] = []\n        self._index = 0\n        self._exhausted = False\n\n    def __aiter__(self) -&gt; AsyncIterator[T]:\n        return self\n\n    async def __anext__(self) -&gt; T:\n        while True:\n            # If we have items in current page, return next\n            if self._index &lt; len(self._current_page):\n                item = self._current_page[self._index]\n                self._index += 1\n                return item\n\n            # Need to fetch next page\n            if self._exhausted:\n                raise StopAsyncIteration\n\n            requested_url = self._next_cursor\n            response = await self._fetch_page(requested_url)\n            self._current_page = list(response.data)\n            self._next_cursor = response.next_cursor\n            self._index = 0\n\n            # Guard against pagination loops (no cursor progress).\n            if response.has_next and response.next_cursor == requested_url:\n                self._exhausted = True\n\n            # Empty pages can still legitimately include nextUrl; keep paging\n            # until we get data or the cursor is exhausted.\n            if not self._current_page:\n                if response.has_next and not self._exhausted:\n                    continue\n                self._exhausted = True\n                raise StopAsyncIteration\n\n            if not response.has_next:\n                self._exhausted = True\n\n    async def pages(\n        self,\n        *,\n        on_progress: Callable[[PaginationProgress], None] | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[T]]:\n        \"\"\"\n        Iterate through pages (not individual items).\n\n        Args:\n            on_progress: Optional callback fired after fetching each page.\n                Receives PaginationProgress with page_number, items_in_page,\n                items_so_far, and has_next. Callbacks should be lightweight;\n                heavy processing should happen outside the callback to avoid\n                blocking iteration.\n\n        Yields:\n            PaginatedResponse objects for each page.\n\n        Example:\n            def report(p: PaginationProgress):\n                print(f\"Page {p.page_number}: {p.items_so_far} items so far\")\n\n            async for page in client.persons.all().pages(on_progress=report):\n                process(page.data)\n        \"\"\"\n        page_number = 0\n        items_so_far = 0\n\n        while True:\n            requested_url = self._next_cursor\n            response = await self._fetch_page(requested_url)\n            self._next_cursor = response.next_cursor\n            page_number += 1\n            items_in_page = len(response.data)\n            items_so_far += items_in_page\n\n            # Guard against pagination loops\n            if response.has_next and response.next_cursor == requested_url:\n                if response.data:\n                    if on_progress:\n                        on_progress(\n                            PaginationProgress(\n                                page_number=page_number,\n                                items_in_page=items_in_page,\n                                items_so_far=items_so_far,\n                                has_next=False,  # Loop detected, no more pages\n                            )\n                        )\n                    yield response\n                break\n\n            if response.data:\n                if on_progress:\n                    on_progress(\n                        PaginationProgress(\n                            page_number=page_number,\n                            items_in_page=items_in_page,\n                            items_so_far=items_so_far,\n                            has_next=response.has_next,\n                        )\n                    )\n                yield response\n\n            if not response.has_next:\n                break\n\n    async def all(self, *, limit: int | None = _DEFAULT_LIMIT) -&gt; list[T]:\n        \"\"\"\n        Fetch all items across all pages into a list.\n\n        Args:\n            limit: Maximum items to fetch. Default 100,000. Set to None for unlimited.\n\n        Returns:\n            List of all items.\n\n        Raises:\n            TooManyResultsError: If results exceed limit.\n\n        Note:\n            The check occurs after extending results, so the final list may exceed\n            limit by up to one page before the error is raised.\n\n        Example:\n            # Default - safe for most use cases\n            persons = [p async for p in client.persons.all()]  # Using async iterator\n\n            # Or use .all() method with limit check\n            it = AsyncPageIterator(fetch_page)\n            persons = await it.all()  # Returns list, raises if &gt; 100k\n\n            # Explicit unlimited for large exports\n            all_persons = await it.all(limit=None)\n\n            # Custom limit\n            persons = await it.all(limit=500_000)\n        \"\"\"\n        results: list[T] = []\n\n        async for page in self.pages():\n            results.extend(page.data)\n\n            if limit is not None and len(results) &gt; limit:\n                raise TooManyResultsError(\n                    f\"Exceeded limit={limit:,} items. \"\n                    f\"Use pages() for streaming, add a filter, or pass limit=None.\"\n                )\n\n        return results\n</code></pre>"},{"location":"reference/models/#affinity.models.AsyncPageIterator.all","title":"<code>all(*, limit: int | None = _DEFAULT_LIMIT) -&gt; list[T]</code>  <code>async</code>","text":"<p>Fetch all items across all pages into a list.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum items to fetch. Default 100,000. Set to None for unlimited.</p> <code>_DEFAULT_LIMIT</code> <p>Returns:</p> Type Description <code>list[T]</code> <p>List of all items.</p> <p>Raises:</p> Type Description <code>TooManyResultsError</code> <p>If results exceed limit.</p> Note <p>The check occurs after extending results, so the final list may exceed limit by up to one page before the error is raised.</p> Example Source code in <code>affinity/models/pagination.py</code> <pre><code>async def all(self, *, limit: int | None = _DEFAULT_LIMIT) -&gt; list[T]:\n    \"\"\"\n    Fetch all items across all pages into a list.\n\n    Args:\n        limit: Maximum items to fetch. Default 100,000. Set to None for unlimited.\n\n    Returns:\n        List of all items.\n\n    Raises:\n        TooManyResultsError: If results exceed limit.\n\n    Note:\n        The check occurs after extending results, so the final list may exceed\n        limit by up to one page before the error is raised.\n\n    Example:\n        # Default - safe for most use cases\n        persons = [p async for p in client.persons.all()]  # Using async iterator\n\n        # Or use .all() method with limit check\n        it = AsyncPageIterator(fetch_page)\n        persons = await it.all()  # Returns list, raises if &gt; 100k\n\n        # Explicit unlimited for large exports\n        all_persons = await it.all(limit=None)\n\n        # Custom limit\n        persons = await it.all(limit=500_000)\n    \"\"\"\n    results: list[T] = []\n\n    async for page in self.pages():\n        results.extend(page.data)\n\n        if limit is not None and len(results) &gt; limit:\n            raise TooManyResultsError(\n                f\"Exceeded limit={limit:,} items. \"\n                f\"Use pages() for streaming, add a filter, or pass limit=None.\"\n            )\n\n    return results\n</code></pre>"},{"location":"reference/models/#affinity.models.AsyncPageIterator.all--default-safe-for-most-use-cases","title":"Default - safe for most use cases","text":"<p>persons = [p async for p in client.persons.all()]  # Using async iterator</p>"},{"location":"reference/models/#affinity.models.AsyncPageIterator.all--or-use-all-method-with-limit-check","title":"Or use .all() method with limit check","text":"<p>it = AsyncPageIterator(fetch_page) persons = await it.all()  # Returns list, raises if &gt; 100k</p>"},{"location":"reference/models/#affinity.models.AsyncPageIterator.all--explicit-unlimited-for-large-exports","title":"Explicit unlimited for large exports","text":"<p>all_persons = await it.all(limit=None)</p>"},{"location":"reference/models/#affinity.models.AsyncPageIterator.all--custom-limit","title":"Custom limit","text":"<p>persons = await it.all(limit=500_000)</p>"},{"location":"reference/models/#affinity.models.AsyncPageIterator.pages","title":"<code>pages(*, on_progress: Callable[[PaginationProgress], None] | None = None) -&gt; AsyncIterator[PaginatedResponse[T]]</code>  <code>async</code>","text":"<p>Iterate through pages (not individual items).</p> <p>Parameters:</p> Name Type Description Default <code>on_progress</code> <code>Callable[[PaginationProgress], None] | None</code> <p>Optional callback fired after fetching each page. Receives PaginationProgress with page_number, items_in_page, items_so_far, and has_next. Callbacks should be lightweight; heavy processing should happen outside the callback to avoid blocking iteration.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[PaginatedResponse[T]]</code> <p>PaginatedResponse objects for each page.</p> Example <p>def report(p: PaginationProgress):     print(f\"Page {p.page_number}: {p.items_so_far} items so far\")</p> <p>async for page in client.persons.all().pages(on_progress=report):     process(page.data)</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>async def pages(\n    self,\n    *,\n    on_progress: Callable[[PaginationProgress], None] | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[T]]:\n    \"\"\"\n    Iterate through pages (not individual items).\n\n    Args:\n        on_progress: Optional callback fired after fetching each page.\n            Receives PaginationProgress with page_number, items_in_page,\n            items_so_far, and has_next. Callbacks should be lightweight;\n            heavy processing should happen outside the callback to avoid\n            blocking iteration.\n\n    Yields:\n        PaginatedResponse objects for each page.\n\n    Example:\n        def report(p: PaginationProgress):\n            print(f\"Page {p.page_number}: {p.items_so_far} items so far\")\n\n        async for page in client.persons.all().pages(on_progress=report):\n            process(page.data)\n    \"\"\"\n    page_number = 0\n    items_so_far = 0\n\n    while True:\n        requested_url = self._next_cursor\n        response = await self._fetch_page(requested_url)\n        self._next_cursor = response.next_cursor\n        page_number += 1\n        items_in_page = len(response.data)\n        items_so_far += items_in_page\n\n        # Guard against pagination loops\n        if response.has_next and response.next_cursor == requested_url:\n            if response.data:\n                if on_progress:\n                    on_progress(\n                        PaginationProgress(\n                            page_number=page_number,\n                            items_in_page=items_in_page,\n                            items_so_far=items_so_far,\n                            has_next=False,  # Loop detected, no more pages\n                        )\n                    )\n                yield response\n            break\n\n        if response.data:\n            if on_progress:\n                on_progress(\n                    PaginationProgress(\n                        page_number=page_number,\n                        items_in_page=items_in_page,\n                        items_so_far=items_so_far,\n                        has_next=response.has_next,\n                    )\n                )\n            yield response\n\n        if not response.has_next:\n            break\n</code></pre>"},{"location":"reference/models/#affinity.models.BatchOperationResponse","title":"<code>BatchOperationResponse</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Response from batch field operations.</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>class BatchOperationResponse(AffinityModel):\n    \"\"\"Response from batch field operations.\"\"\"\n\n    results: list[BatchOperationResult] = Field(default_factory=list)\n\n    @property\n    def all_successful(self) -&gt; bool:\n        return all(r.success for r in self.results)\n\n    @property\n    def failures(self) -&gt; list[BatchOperationResult]:\n        return [r for r in self.results if not r.success]\n</code></pre>"},{"location":"reference/models/#affinity.models.BatchOperationResult","title":"<code>BatchOperationResult</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Result of a single operation in a batch.</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>class BatchOperationResult(AffinityModel):\n    \"\"\"Result of a single operation in a batch.\"\"\"\n\n    field_id: str = Field(alias=\"fieldId\")\n    success: bool\n    error: str | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.Company","title":"<code>Company</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Full company representation.</p> <p>Note: Called Organization in V1 API.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class Company(AffinityModel):\n    \"\"\"\n    Full company representation.\n\n    Note: Called Organization in V1 API.\n    \"\"\"\n\n    id: CompanyId\n    name: str\n    domain: str | None = None\n    domains: list[str] = Field(default_factory=list)\n    is_global: bool = Field(False, alias=\"global\")\n\n    # Associations\n    person_ids: list[PersonId] = Field(default_factory=list, alias=\"personIds\")\n    opportunity_ids: list[OpportunityId] = Field(default_factory=list, alias=\"opportunityIds\")\n\n    # Field values (requested-vs-not-requested preserved)\n    fields: FieldValues = Field(default_factory=FieldValues, alias=\"fields\")\n    fields_raw: list[dict[str, Any]] | None = Field(default=None, exclude=True)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _normalize_null_lists_before(cls, value: Any) -&gt; Any:\n        value = _normalize_null_lists(\n            value,\n            (\n                \"domains\",\n                \"personIds\",\n                \"person_ids\",\n                \"opportunityIds\",\n                \"opportunity_ids\",\n            ),\n        )\n        return _preserve_fields_raw(value)\n\n    @model_validator(mode=\"after\")\n    def _mark_fields_not_requested_when_omitted(self) -&gt; Company:\n        if \"fields\" not in self.__pydantic_fields_set__:\n            self.fields.requested = False\n        return self\n\n    # List entries (returned for single company fetch)\n    list_entries: list[ListEntry] | None = Field(None, alias=\"listEntries\")\n\n    # Interaction dates\n    interaction_dates: InteractionDates | None = Field(None, alias=\"interactionDates\")\n\n    # Detailed interaction data with person IDs (returned when with_interaction_persons=True)\n    interactions: Interactions | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.CompanyCreate","title":"<code>CompanyCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a new company (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class CompanyCreate(AffinityModel):\n    \"\"\"Data for creating a new company (V1 API).\"\"\"\n\n    name: str\n    domain: str | None = None\n    person_ids: list[PersonId] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/models/#affinity.models.CompanyUpdate","title":"<code>CompanyUpdate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for updating a company (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class CompanyUpdate(AffinityModel):\n    \"\"\"Data for updating a company (V1 API).\"\"\"\n\n    name: str | None = None\n    domain: str | None = None\n    person_ids: list[PersonId] | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.DropdownOption","title":"<code>DropdownOption</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A selectable option in a dropdown field.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class DropdownOption(AffinityModel):\n    \"\"\"A selectable option in a dropdown field.\"\"\"\n\n    id: DropdownOptionId\n    text: str\n    rank: int | None = None\n    color: int | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.EntityFile","title":"<code>EntityFile</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A file attached to an entity.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class EntityFile(AffinityModel):\n    \"\"\"A file attached to an entity.\"\"\"\n\n    id: FileId\n    name: str\n    size: int\n    # Observed missing in some V1 responses; treat as optional for robustness.\n    content_type: str | None = Field(None, alias=\"contentType\")\n\n    # Associated entity\n    person_id: PersonId | None = Field(None, alias=\"personId\")\n    company_id: CompanyId | None = Field(None, alias=\"organizationId\")\n    opportunity_id: OpportunityId | None = Field(None, alias=\"opportunityId\")\n\n    # Uploader\n    uploader_id: UserId = Field(alias=\"uploaderId\")\n\n    # Timestamps\n    created_at: ISODatetime = Field(alias=\"createdAt\")\n</code></pre>"},{"location":"reference/models/#affinity.models.FieldCreate","title":"<code>FieldCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a new field (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class FieldCreate(AffinityModel):\n    \"\"\"Data for creating a new field (V1 API).\"\"\"\n\n    model_config = ConfigDict(use_enum_values=False)\n\n    name: str\n    entity_type: EntityType\n    value_type: FieldValueType\n    list_id: ListId | None = None\n    allows_multiple: bool = False\n    is_list_specific: bool = False\n    is_required: bool = False\n</code></pre>"},{"location":"reference/models/#affinity.models.FieldMetadata","title":"<code>FieldMetadata</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Metadata about a field (column) in Affinity.</p> <p>Includes both V1 numeric IDs and V2 string IDs for enriched fields.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class FieldMetadata(AffinityModel):\n    \"\"\"\n    Metadata about a field (column) in Affinity.\n\n    Includes both V1 numeric IDs and V2 string IDs for enriched fields.\n    \"\"\"\n\n    model_config = ConfigDict(use_enum_values=False)\n\n    id: AnyFieldId  # Can be int (field-123) or string (affinity-data-description)\n    name: str\n    value_type: FieldValueType = Field(alias=\"valueType\")\n    allows_multiple: bool = Field(False, alias=\"allowsMultiple\")\n    value_type_raw: str | int | None = Field(None, exclude=True)\n\n    # V2 field type classification\n    type: str | None = None  # \"enriched\", \"list-specific\", \"global\", etc.\n\n    # V1 specific fields\n    list_id: ListId | None = Field(None, alias=\"listId\")\n    track_changes: bool = Field(False, alias=\"trackChanges\")\n    enrichment_source: str | None = Field(None, alias=\"enrichmentSource\")\n    is_required: bool = Field(False, alias=\"isRequired\")\n\n    # Dropdown options for dropdown fields\n    dropdown_options: list[DropdownOption] = Field(default_factory=list, alias=\"dropdownOptions\")\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _preserve_value_type_raw(cls, value: Any) -&gt; Any:\n        if not isinstance(value, Mapping):\n            return value\n\n        data: dict[str, Any] = dict(value)\n        raw = data.get(\"valueType\")\n        if raw is None and \"value_type\" in data:\n            raw = data.get(\"value_type\")\n        data[\"value_type_raw\"] = raw\n        return data\n\n    @model_validator(mode=\"after\")\n    def _coerce_allows_multiple_from_value_type(self) -&gt; FieldMetadata:\n        # If the server returns a `*-multi` value type, treat it as authoritative for multiplicity.\n        try:\n            text = str(self.value_type)\n        except Exception:\n            text = \"\"\n        if text.endswith(\"-multi\") and not self.allows_multiple:\n            _logger.debug(\n                \"FieldMetadata allowsMultiple mismatch: valueType=%s allowsMultiple=%s \"\n                \"(auto-correcting)\",\n                text,\n                self.allows_multiple,\n            )\n            self.allows_multiple = True\n        return self\n</code></pre>"},{"location":"reference/models/#affinity.models.FieldValue","title":"<code>FieldValue</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A single field value (cell data).</p> <p>The value can be various types depending on the field's value_type.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class FieldValue(AffinityModel):\n    \"\"\"\n    A single field value (cell data).\n\n    The value can be various types depending on the field's value_type.\n    \"\"\"\n\n    id: FieldValueId\n    field_id: AnyFieldId = Field(alias=\"fieldId\")\n    entity_id: int = Field(alias=\"entityId\")\n    list_entry_id: ListEntryId | None = Field(None, alias=\"listEntryId\")\n\n    # The actual value - type depends on field type\n    value: Any\n\n    # Timestamps\n    created_at: ISODatetime | None = Field(None, alias=\"createdAt\")\n    updated_at: ISODatetime | None = Field(None, alias=\"updatedAt\")\n</code></pre>"},{"location":"reference/models/#affinity.models.FieldValueChange","title":"<code>FieldValueChange</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Historical change to a field value.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class FieldValueChange(AffinityModel):\n    \"\"\"Historical change to a field value.\"\"\"\n\n    id: FieldValueChangeId\n    field_id: FieldId = Field(alias=\"fieldId\")\n    entity_id: int = Field(alias=\"entityId\")\n    list_entry_id: ListEntryId | None = Field(None, alias=\"listEntryId\")\n    action_type: FieldValueChangeAction = Field(alias=\"actionType\")\n    value: Any\n    changed_at: ISODatetime = Field(alias=\"changedAt\")\n    changer: PersonSummary | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.FieldValueCreate","title":"<code>FieldValueCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a field value (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class FieldValueCreate(AffinityModel):\n    \"\"\"Data for creating a field value (V1 API).\"\"\"\n\n    field_id: FieldId\n    entity_id: int\n    value: Any\n    list_entry_id: ListEntryId | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.Grant","title":"<code>Grant</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>API key grant information.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class Grant(AffinityModel):\n    \"\"\"API key grant information.\"\"\"\n\n    type: str\n    scopes: list[str] = Field(default_factory=list)\n    created_at: ISODatetime = Field(alias=\"createdAt\")\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _coerce_scope_to_scopes(cls, value: Any) -&gt; Any:\n        if not isinstance(value, dict):\n            return value\n        if \"scopes\" in value:\n            return value\n        scope = value.get(\"scope\")\n        if isinstance(scope, str):\n            updated = dict(value)\n            updated[\"scopes\"] = [scope]\n            return updated\n        return value\n\n    @property\n    def scope(self) -&gt; str | None:\n        \"\"\"\n        Backwards-compatible convenience for older response shapes.\n\n        Returns the first scope string when present, otherwise None.\n        \"\"\"\n        return self.scopes[0] if self.scopes else None\n</code></pre>"},{"location":"reference/models/#affinity.models.Grant.scope","title":"<code>scope: str | None</code>  <code>property</code>","text":"<p>Backwards-compatible convenience for older response shapes.</p> <p>Returns the first scope string when present, otherwise None.</p>"},{"location":"reference/models/#affinity.models.Interaction","title":"<code>Interaction</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>An interaction (email, meeting, call, or chat message).</p> <p>Different interaction types have different fields available.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class Interaction(AffinityModel):\n    \"\"\"\n    An interaction (email, meeting, call, or chat message).\n\n    Different interaction types have different fields available.\n    \"\"\"\n\n    id: InteractionId\n    type: InteractionType\n    date: ISODatetime\n\n    # Associated persons\n    persons: list[PersonSummary] = Field(default_factory=list)\n    attendees: list[str] = Field(default_factory=list)\n\n    # Meeting/Call specific\n    title: str | None = None\n    start_time: ISODatetime | None = Field(None, alias=\"startTime\")\n    end_time: ISODatetime | None = Field(None, alias=\"endTime\")\n\n    # Email specific\n    subject: str | None = None\n\n    # Chat/Email direction\n    direction: InteractionDirection | None = None\n\n    # Notes attached to this interaction\n    notes: list[NoteId] = Field(default_factory=list)\n\n    # Manual logging info\n    manual_creator_id: UserId | None = Field(None, alias=\"manualCreatorId\")\n    updated_at: ISODatetime | None = Field(None, alias=\"updatedAt\")\n</code></pre>"},{"location":"reference/models/#affinity.models.InteractionCreate","title":"<code>InteractionCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating an interaction (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class InteractionCreate(AffinityModel):\n    \"\"\"Data for creating an interaction (V1 API).\"\"\"\n\n    type: InteractionType\n    person_ids: list[PersonId]\n    content: str\n    date: ISODatetime\n    direction: InteractionDirection | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.InteractionUpdate","title":"<code>InteractionUpdate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for updating an interaction (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class InteractionUpdate(AffinityModel):\n    \"\"\"Data for updating an interaction (V1 API).\"\"\"\n\n    person_ids: list[PersonId] | None = None\n    content: str | None = None\n    date: ISODatetime | None = None\n    direction: InteractionDirection | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.ListCreate","title":"<code>ListCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a new list (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class ListCreate(AffinityModel):\n    \"\"\"Data for creating a new list (V1 API).\"\"\"\n\n    name: str\n    type: ListType\n    is_public: bool\n    owner_id: UserId | None = None\n    additional_permissions: list[ListPermission] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/models/#affinity.models.ListEntry","title":"<code>ListEntry</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A row in a list, linking an entity to a list.</p> <p>Contains the entity data and list-specific field values.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class ListEntry(AffinityModel):\n    \"\"\"\n    A row in a list, linking an entity to a list.\n\n    Contains the entity data and list-specific field values.\n    \"\"\"\n\n    id: ListEntryId\n    list_id: ListId = Field(alias=\"listId\")\n    creator_id: UserId | None = Field(None, alias=\"creatorId\")\n    entity_id: int | None = Field(None, alias=\"entityId\")\n    entity_type: EntityType | None = Field(None, alias=\"entityType\")\n    created_at: ISODatetime = Field(alias=\"createdAt\")\n\n    # The entity this entry represents (can be Person, Company, or Opportunity)\n    entity: PersonSummary | CompanySummary | OpportunitySummary | dict[str, Any] | None = None\n\n    # Field values on this list entry (requested-vs-not-requested preserved)\n    fields: FieldValues = Field(default_factory=FieldValues, alias=\"fields\")\n    fields_raw: list[dict[str, Any]] | None = Field(default=None, exclude=True)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _coerce_entity_by_entity_type(cls, value: Any) -&gt; Any:\n        \"\"\"\n        The v1 list-entry payload includes `entity_type` alongside a minimal `entity` dict.\n\n        Some entity summaries overlap in shape (e.g. opportunity and company both have\n        `{id, name}`), so we must use `entity_type` as the discriminator to avoid mis-parsing.\n        \"\"\"\n        if not isinstance(value, Mapping):\n            return value\n\n        data: dict[str, Any] = dict(value)\n        fields = data.get(\"fields\")\n        if isinstance(fields, list):\n            data[\"fields_raw\"] = fields\n\n        entity = data.get(\"entity\")\n        if not isinstance(entity, Mapping):\n            return data\n\n        raw_entity_type = data.get(\"entityType\")\n        if raw_entity_type is None:\n            raw_entity_type = data.get(\"entity_type\")\n        if raw_entity_type is None:\n            return data\n\n        try:\n            entity_type = EntityType(raw_entity_type)\n        except ValueError as e:\n            _logger.debug(\"Unknown entity type %r, returning raw data: %s\", raw_entity_type, e)\n            return data\n\n        if entity_type == EntityType.PERSON:\n            try:\n                data[\"entity\"] = PersonSummary.model_validate(entity)\n            except Exception as e:\n                _logger.debug(\"Failed to validate PersonSummary, returning raw data: %s\", e)\n                return data\n        elif entity_type == EntityType.ORGANIZATION:\n            try:\n                data[\"entity\"] = CompanySummary.model_validate(entity)\n            except Exception as e:\n                _logger.debug(\"Failed to validate CompanySummary, returning raw data: %s\", e)\n                return data\n        elif entity_type == EntityType.OPPORTUNITY:\n            try:\n                data[\"entity\"] = OpportunitySummary.model_validate(entity)\n            except Exception as e:\n                _logger.debug(\"Failed to validate OpportunitySummary, returning raw data: %s\", e)\n                return data\n\n        return data\n\n    @model_validator(mode=\"after\")\n    def _mark_fields_not_requested_when_omitted(self) -&gt; ListEntry:\n        if \"fields\" not in self.__pydantic_fields_set__:\n            self.fields.requested = False\n        return self\n</code></pre>"},{"location":"reference/models/#affinity.models.ListEntryCreate","title":"<code>ListEntryCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for adding an entity to a list (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class ListEntryCreate(AffinityModel):\n    \"\"\"Data for adding an entity to a list (V1 API).\"\"\"\n\n    entity_id: int\n    creator_id: UserId | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.ListEntryWithEntity","title":"<code>ListEntryWithEntity</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>List entry with full entity data included (V2 response format).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class ListEntryWithEntity(AffinityModel):\n    \"\"\"List entry with full entity data included (V2 response format).\"\"\"\n\n    id: ListEntryId\n    list_id: ListId = Field(alias=\"listId\")\n    creator: PersonSummary | None = None\n    created_at: ISODatetime = Field(alias=\"createdAt\")\n\n    # Entity type and data\n    type: str  # \"person\", \"company\", or \"opportunity\"\n    entity: Person | Company | Opportunity | None = None\n\n    # Field values (requested-vs-not-requested preserved)\n    fields: FieldValues = Field(default_factory=FieldValues, alias=\"fields\")\n    fields_raw: list[dict[str, Any]] | None = Field(default=None, exclude=True)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _preserve_fields_raw_before(cls, value: Any) -&gt; Any:\n        return _preserve_fields_raw(value)\n\n    @model_validator(mode=\"after\")\n    def _mark_fields_not_requested_when_omitted(self) -&gt; ListEntryWithEntity:\n        if \"fields\" not in self.__pydantic_fields_set__:\n            self.fields.requested = False\n        return self\n</code></pre>"},{"location":"reference/models/#affinity.models.ListPermission","title":"<code>ListPermission</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Additional permission on a list.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class ListPermission(AffinityModel):\n    \"\"\"Additional permission on a list.\"\"\"\n\n    internal_person_id: UserId = Field(alias=\"internalPersonId\")\n    role_id: ListRole = Field(alias=\"roleId\")\n</code></pre>"},{"location":"reference/models/#affinity.models.ListSummary","title":"<code>ListSummary</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Minimal list reference used by relationship endpoints.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class ListSummary(AffinityModel):\n    \"\"\"Minimal list reference used by relationship endpoints.\"\"\"\n\n    id: ListId\n    name: str | None = None\n    type: ListType | None = None\n    is_public: bool | None = Field(None, alias=\"public\")\n    owner_id: UserId | None = Field(None, alias=\"ownerId\")\n    list_size: int | None = Field(None, alias=\"listSize\")\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _coerce_v2_is_public(cls, value: Any) -&gt; Any:\n        if isinstance(value, Mapping) and \"public\" not in value and \"isPublic\" in value:\n            data = dict(value)\n            data[\"public\"] = data.get(\"isPublic\")\n            return data\n        return value\n</code></pre>"},{"location":"reference/models/#affinity.models.Note","title":"<code>Note</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A note attached to one or more entities.</p> <p>Notes can be plain text, HTML, or AI-generated meeting summaries.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class Note(AffinityModel):\n    \"\"\"\n    A note attached to one or more entities.\n\n    Notes can be plain text, HTML, or AI-generated meeting summaries.\n    \"\"\"\n\n    id: NoteId\n    creator_id: UserId = Field(alias=\"creatorId\")\n    content: str | None = None\n    type: NoteType = NoteType.PLAIN_TEXT\n\n    # Associated entities\n    person_ids: list[PersonId] = Field(default_factory=list, alias=\"personIds\")\n    associated_person_ids: list[PersonId] = Field(default_factory=list, alias=\"associatedPersonIds\")\n    interaction_person_ids: list[PersonId] = Field(\n        default_factory=list, alias=\"interactionPersonIds\"\n    )\n    mentioned_person_ids: list[PersonId] = Field(default_factory=list, alias=\"mentionedPersonIds\")\n    company_ids: list[CompanyId] = Field(default_factory=list, alias=\"organizationIds\")\n    opportunity_ids: list[OpportunityId] = Field(default_factory=list, alias=\"opportunityIds\")\n\n    # Interaction association\n    interaction_id: int | None = Field(None, alias=\"interactionId\")\n    interaction_type: InteractionType | None = Field(None, alias=\"interactionType\")\n    is_meeting: bool = Field(False, alias=\"isMeeting\")\n\n    # Thread support\n    parent_id: NoteId | None = Field(None, alias=\"parentId\")\n\n    # Timestamps\n    created_at: ISODatetime = Field(alias=\"createdAt\")\n    updated_at: ISODatetime | None = Field(None, alias=\"updatedAt\")\n</code></pre>"},{"location":"reference/models/#affinity.models.NoteCreate","title":"<code>NoteCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a new note (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class NoteCreate(AffinityModel):\n    \"\"\"Data for creating a new note (V1 API).\"\"\"\n\n    content: str\n    type: NoteType = NoteType.PLAIN_TEXT\n    person_ids: list[PersonId] = Field(default_factory=list)\n    company_ids: list[CompanyId] = Field(default_factory=list, alias=\"organization_ids\")\n    opportunity_ids: list[OpportunityId] = Field(default_factory=list)\n    parent_id: NoteId | None = None  # For reply notes\n    creator_id: UserId | None = None\n    created_at: ISODatetime | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.NoteUpdate","title":"<code>NoteUpdate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for updating a note (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class NoteUpdate(AffinityModel):\n    \"\"\"Data for updating a note (V1 API).\"\"\"\n\n    content: str\n</code></pre>"},{"location":"reference/models/#affinity.models.Opportunity","title":"<code>Opportunity</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Deal/opportunity in a pipeline.</p> Note <p>The V2 API returns empty <code>person_ids</code> and <code>company_ids</code> arrays even when associations exist. Use <code>client.opportunities.get_associated_person_ids()</code> or <code>client.opportunities.get_details()</code> to retrieve association data.</p> <p>See the opportunity-associations guide for details.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class Opportunity(AffinityModel):\n    \"\"\"\n    Deal/opportunity in a pipeline.\n\n    Note:\n        The V2 API returns empty ``person_ids`` and ``company_ids`` arrays even\n        when associations exist. Use ``client.opportunities.get_associated_person_ids()``\n        or ``client.opportunities.get_details()`` to retrieve association data.\n\n        See the opportunity-associations guide for details.\n    \"\"\"\n\n    id: OpportunityId\n    name: str\n    list_id: ListId | None = Field(None, alias=\"listId\")\n\n    # Associations (Note: V2 API returns empty arrays; use get_details() or\n    # get_associated_person_ids() for populated data)\n    person_ids: list[PersonId] = Field(default_factory=list, alias=\"personIds\")\n    company_ids: list[CompanyId] = Field(default_factory=list, alias=\"organizationIds\")\n\n    # Field values (requested-vs-not-requested preserved)\n    fields: FieldValues = Field(default_factory=FieldValues, alias=\"fields\")\n    fields_raw: list[dict[str, Any]] | None = Field(default=None, exclude=True)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _preserve_fields_raw_before(cls, value: Any) -&gt; Any:\n        return _preserve_fields_raw(value)\n\n    # List entries\n    list_entries: list[ListEntry] | None = Field(None, alias=\"listEntries\")\n\n    @model_validator(mode=\"after\")\n    def _post_validate(self) -&gt; Opportunity:\n        # Mark fields as not requested when omitted\n        if \"fields\" not in self.__pydantic_fields_set__:\n            self.fields.requested = False\n\n        # Extract list_id from list_entries when not set directly\n        # (V1 API returns list_id in list_entries, not at top level)\n        if self.list_id is None and self.list_entries:\n            self.list_id = self.list_entries[0].list_id\n\n        return self\n</code></pre>"},{"location":"reference/models/#affinity.models.OpportunityCreate","title":"<code>OpportunityCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a new opportunity (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class OpportunityCreate(AffinityModel):\n    \"\"\"Data for creating a new opportunity (V1 API).\"\"\"\n\n    name: str\n    list_id: ListId\n    person_ids: list[PersonId] = Field(default_factory=list)\n    company_ids: list[CompanyId] = Field(default_factory=list, alias=\"organization_ids\")\n</code></pre>"},{"location":"reference/models/#affinity.models.OpportunitySummary","title":"<code>OpportunitySummary</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Minimal opportunity data returned in nested contexts.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class OpportunitySummary(AffinityModel):\n    \"\"\"Minimal opportunity data returned in nested contexts.\"\"\"\n\n    id: OpportunityId\n    name: str\n</code></pre>"},{"location":"reference/models/#affinity.models.OpportunityUpdate","title":"<code>OpportunityUpdate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for updating an opportunity (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class OpportunityUpdate(AffinityModel):\n    \"\"\"Data for updating an opportunity (V1 API).\"\"\"\n\n    name: str | None = None\n    person_ids: list[PersonId] | None = None\n    company_ids: list[CompanyId] | None = Field(None, alias=\"organization_ids\")\n</code></pre>"},{"location":"reference/models/#affinity.models.PageIterator","title":"<code>PageIterator</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Synchronous iterator that automatically fetches all pages.</p> Usage <p>for item in client.companies.all():     print(item.name)</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>class PageIterator(Generic[T]):\n    \"\"\"\n    Synchronous iterator that automatically fetches all pages.\n\n    Usage:\n        for item in client.companies.all():\n            print(item.name)\n    \"\"\"\n\n    def __init__(\n        self,\n        fetch_page: Callable[[str | None], PaginatedResponse[T]],\n        initial_cursor: str | None = None,\n    ):\n        self._fetch_page = fetch_page\n        self._next_cursor = initial_cursor\n        self._current_page: list[T] = []\n        self._index = 0\n        self._exhausted = False\n\n    def __iter__(self) -&gt; Iterator[T]:\n        return self\n\n    def __next__(self) -&gt; T:\n        while True:\n            # If we have items in current page, return next\n            if self._index &lt; len(self._current_page):\n                item = self._current_page[self._index]\n                self._index += 1\n                return item\n\n            # Need to fetch next page\n            if self._exhausted:\n                raise StopIteration\n\n            requested_url = self._next_cursor\n            response = self._fetch_page(requested_url)\n            self._current_page = list(response.data)\n            self._next_cursor = response.next_cursor\n            self._index = 0\n\n            # Guard against pagination loops (no cursor progress).\n            if response.has_next and response.next_cursor == requested_url:\n                self._exhausted = True\n\n            # Empty pages can still legitimately include nextUrl; keep paging\n            # until we get data or the cursor is exhausted.\n            if not self._current_page:\n                if response.has_next and not self._exhausted:\n                    continue\n                self._exhausted = True\n                raise StopIteration\n\n            if not response.has_next:\n                self._exhausted = True\n\n    def pages(\n        self,\n        *,\n        on_progress: Callable[[PaginationProgress], None] | None = None,\n    ) -&gt; Iterator[PaginatedResponse[T]]:\n        \"\"\"\n        Iterate through pages (not individual items).\n\n        Args:\n            on_progress: Optional callback fired after fetching each page.\n                Receives PaginationProgress with page_number, items_in_page,\n                items_so_far, and has_next. Callbacks should be lightweight;\n                heavy processing should happen outside the callback to avoid\n                blocking iteration.\n\n        Yields:\n            PaginatedResponse objects for each page.\n\n        Example:\n            def report(p: PaginationProgress):\n                print(f\"Page {p.page_number}: {p.items_so_far} items so far\")\n\n            for page in client.persons.all().pages(on_progress=report):\n                process(page.data)\n        \"\"\"\n        page_number = 0\n        items_so_far = 0\n\n        while True:\n            requested_url = self._next_cursor\n            response = self._fetch_page(requested_url)\n            self._next_cursor = response.next_cursor\n            page_number += 1\n            items_in_page = len(response.data)\n            items_so_far += items_in_page\n\n            # Guard against pagination loops\n            if response.has_next and response.next_cursor == requested_url:\n                if response.data:\n                    if on_progress:\n                        on_progress(\n                            PaginationProgress(\n                                page_number=page_number,\n                                items_in_page=items_in_page,\n                                items_so_far=items_so_far,\n                                has_next=False,  # Loop detected, no more pages\n                            )\n                        )\n                    yield response\n                break\n\n            if response.data:\n                if on_progress:\n                    on_progress(\n                        PaginationProgress(\n                            page_number=page_number,\n                            items_in_page=items_in_page,\n                            items_so_far=items_so_far,\n                            has_next=response.has_next,\n                        )\n                    )\n                yield response\n\n            if not response.has_next:\n                break\n\n    def all(self, *, limit: int | None = _DEFAULT_LIMIT) -&gt; list[T]:\n        \"\"\"\n        Fetch all items across all pages into a list.\n\n        Args:\n            limit: Maximum items to fetch. Default 100,000. Set to None for unlimited.\n\n        Returns:\n            List of all items.\n\n        Raises:\n            TooManyResultsError: If results exceed limit.\n\n        Note:\n            The check occurs after extending results, so the final list may exceed\n            limit by up to one page before the error is raised.\n\n        Example:\n            # Default - safe for most use cases\n            persons = list(client.persons.all())  # Using iterator\n\n            # Or use .all() method with limit check\n            it = PageIterator(fetch_page)\n            persons = it.all()  # Returns list, raises if &gt; 100k\n\n            # Explicit unlimited for large exports\n            all_persons = it.all(limit=None)\n\n            # Custom limit\n            persons = it.all(limit=500_000)\n        \"\"\"\n        results: list[T] = []\n\n        for page in self.pages():\n            results.extend(page.data)\n\n            if limit is not None and len(results) &gt; limit:\n                raise TooManyResultsError(\n                    f\"Exceeded limit={limit:,} items. \"\n                    f\"Use pages() for streaming, add a filter, or pass limit=None.\"\n                )\n\n        return results\n</code></pre>"},{"location":"reference/models/#affinity.models.PageIterator.all","title":"<code>all(*, limit: int | None = _DEFAULT_LIMIT) -&gt; list[T]</code>","text":"<p>Fetch all items across all pages into a list.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum items to fetch. Default 100,000. Set to None for unlimited.</p> <code>_DEFAULT_LIMIT</code> <p>Returns:</p> Type Description <code>list[T]</code> <p>List of all items.</p> <p>Raises:</p> Type Description <code>TooManyResultsError</code> <p>If results exceed limit.</p> Note <p>The check occurs after extending results, so the final list may exceed limit by up to one page before the error is raised.</p> Example Source code in <code>affinity/models/pagination.py</code> <pre><code>def all(self, *, limit: int | None = _DEFAULT_LIMIT) -&gt; list[T]:\n    \"\"\"\n    Fetch all items across all pages into a list.\n\n    Args:\n        limit: Maximum items to fetch. Default 100,000. Set to None for unlimited.\n\n    Returns:\n        List of all items.\n\n    Raises:\n        TooManyResultsError: If results exceed limit.\n\n    Note:\n        The check occurs after extending results, so the final list may exceed\n        limit by up to one page before the error is raised.\n\n    Example:\n        # Default - safe for most use cases\n        persons = list(client.persons.all())  # Using iterator\n\n        # Or use .all() method with limit check\n        it = PageIterator(fetch_page)\n        persons = it.all()  # Returns list, raises if &gt; 100k\n\n        # Explicit unlimited for large exports\n        all_persons = it.all(limit=None)\n\n        # Custom limit\n        persons = it.all(limit=500_000)\n    \"\"\"\n    results: list[T] = []\n\n    for page in self.pages():\n        results.extend(page.data)\n\n        if limit is not None and len(results) &gt; limit:\n            raise TooManyResultsError(\n                f\"Exceeded limit={limit:,} items. \"\n                f\"Use pages() for streaming, add a filter, or pass limit=None.\"\n            )\n\n    return results\n</code></pre>"},{"location":"reference/models/#affinity.models.PageIterator.all--default-safe-for-most-use-cases","title":"Default - safe for most use cases","text":"<p>persons = list(client.persons.all())  # Using iterator</p>"},{"location":"reference/models/#affinity.models.PageIterator.all--or-use-all-method-with-limit-check","title":"Or use .all() method with limit check","text":"<p>it = PageIterator(fetch_page) persons = it.all()  # Returns list, raises if &gt; 100k</p>"},{"location":"reference/models/#affinity.models.PageIterator.all--explicit-unlimited-for-large-exports","title":"Explicit unlimited for large exports","text":"<p>all_persons = it.all(limit=None)</p>"},{"location":"reference/models/#affinity.models.PageIterator.all--custom-limit","title":"Custom limit","text":"<p>persons = it.all(limit=500_000)</p>"},{"location":"reference/models/#affinity.models.PageIterator.pages","title":"<code>pages(*, on_progress: Callable[[PaginationProgress], None] | None = None) -&gt; Iterator[PaginatedResponse[T]]</code>","text":"<p>Iterate through pages (not individual items).</p> <p>Parameters:</p> Name Type Description Default <code>on_progress</code> <code>Callable[[PaginationProgress], None] | None</code> <p>Optional callback fired after fetching each page. Receives PaginationProgress with page_number, items_in_page, items_so_far, and has_next. Callbacks should be lightweight; heavy processing should happen outside the callback to avoid blocking iteration.</p> <code>None</code> <p>Yields:</p> Type Description <code>PaginatedResponse[T]</code> <p>PaginatedResponse objects for each page.</p> Example <p>def report(p: PaginationProgress):     print(f\"Page {p.page_number}: {p.items_so_far} items so far\")</p> <p>for page in client.persons.all().pages(on_progress=report):     process(page.data)</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>def pages(\n    self,\n    *,\n    on_progress: Callable[[PaginationProgress], None] | None = None,\n) -&gt; Iterator[PaginatedResponse[T]]:\n    \"\"\"\n    Iterate through pages (not individual items).\n\n    Args:\n        on_progress: Optional callback fired after fetching each page.\n            Receives PaginationProgress with page_number, items_in_page,\n            items_so_far, and has_next. Callbacks should be lightweight;\n            heavy processing should happen outside the callback to avoid\n            blocking iteration.\n\n    Yields:\n        PaginatedResponse objects for each page.\n\n    Example:\n        def report(p: PaginationProgress):\n            print(f\"Page {p.page_number}: {p.items_so_far} items so far\")\n\n        for page in client.persons.all().pages(on_progress=report):\n            process(page.data)\n    \"\"\"\n    page_number = 0\n    items_so_far = 0\n\n    while True:\n        requested_url = self._next_cursor\n        response = self._fetch_page(requested_url)\n        self._next_cursor = response.next_cursor\n        page_number += 1\n        items_in_page = len(response.data)\n        items_so_far += items_in_page\n\n        # Guard against pagination loops\n        if response.has_next and response.next_cursor == requested_url:\n            if response.data:\n                if on_progress:\n                    on_progress(\n                        PaginationProgress(\n                            page_number=page_number,\n                            items_in_page=items_in_page,\n                            items_so_far=items_so_far,\n                            has_next=False,  # Loop detected, no more pages\n                        )\n                    )\n                yield response\n            break\n\n        if response.data:\n            if on_progress:\n                on_progress(\n                    PaginationProgress(\n                        page_number=page_number,\n                        items_in_page=items_in_page,\n                        items_so_far=items_so_far,\n                        has_next=response.has_next,\n                    )\n                )\n            yield response\n\n        if not response.has_next:\n            break\n</code></pre>"},{"location":"reference/models/#affinity.models.PaginatedResponse","title":"<code>PaginatedResponse</code>","text":"<p>               Bases: <code>AffinityModel</code>, <code>Generic[T]</code></p> <p>A paginated response from the API.</p> <p>Provides access to the current page of results and pagination info. Works with all Affinity API endpoints transparently.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>list[T]</code> <p>List of items in the current page.</p> <code>has_next</code> <code>bool</code> <p>Whether more pages are available.</p> <code>next_cursor</code> <code>str | None</code> <p>Cursor for fetching the next page (use this for pagination).</p> Example <pre><code>page = client.companies.list(limit=100)\nwhile page.has_next:\n    process(page.data)\n    page = client.companies.list(limit=100, cursor=page.next_cursor)\n</code></pre> Tip <p>Always use <code>next_cursor</code> for pagination. Avoid accessing <code>pagination.next_cursor</code> or <code>next_page_token</code> directly.</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>class PaginatedResponse(AffinityModel, Generic[T]):\n    \"\"\"\n    A paginated response from the API.\n\n    Provides access to the current page of results and pagination info.\n    Works with all Affinity API endpoints transparently.\n\n    Attributes:\n        data: List of items in the current page.\n        has_next: Whether more pages are available.\n        next_cursor: Cursor for fetching the next page (use this for pagination).\n\n    Example:\n        ```python\n        page = client.companies.list(limit=100)\n        while page.has_next:\n            process(page.data)\n            page = client.companies.list(limit=100, cursor=page.next_cursor)\n        ```\n\n    Tip:\n        Always use ``next_cursor`` for pagination. Avoid accessing\n        ``pagination.next_cursor`` or ``next_page_token`` directly.\n    \"\"\"\n\n    data: list[T] = Field(default_factory=list)\n    pagination: PaginationInfo = Field(default_factory=PaginationInfo)\n    # Internal: V1 API compatibility field. Users should use next_cursor property.\n    next_page_token: str | None = Field(None, alias=\"nextPageToken\")\n    _has_next_override: bool | None = PrivateAttr(default=None)\n    _filter_stats: FilterStats | None = PrivateAttr(default=None)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Number of items in current page.\"\"\"\n        return len(self.data)\n\n    @property\n    def has_next(self) -&gt; bool:\n        \"\"\"Whether there are more pages.\"\"\"\n        if self._has_next_override is not None:\n            return self._has_next_override\n        return self.next_cursor is not None\n\n    @property\n    def next_cursor(self) -&gt; str | None:\n        \"\"\"\n        Cursor for the next page, if any.\n\n        Returns the V2 pagination URL or V1 page token, whichever is present.\n        Always use this property instead of accessing ``pagination.next_cursor``\n        or ``next_page_token`` directly.\n        \"\"\"\n        # Use explicit None check to preserve empty strings (which are valid cursors)\n        if self.pagination.next_cursor is not None:\n            return self.pagination.next_cursor\n        return self.next_page_token\n\n    @property\n    def filter_stats(self) -&gt; FilterStats | None:\n        \"\"\"Stats for client-side filtered queries (scanned/matched counts).\"\"\"\n        return self._filter_stats\n</code></pre>"},{"location":"reference/models/#affinity.models.PaginatedResponse.filter_stats","title":"<code>filter_stats: FilterStats | None</code>  <code>property</code>","text":"<p>Stats for client-side filtered queries (scanned/matched counts).</p>"},{"location":"reference/models/#affinity.models.PaginatedResponse.has_next","title":"<code>has_next: bool</code>  <code>property</code>","text":"<p>Whether there are more pages.</p>"},{"location":"reference/models/#affinity.models.PaginatedResponse.next_cursor","title":"<code>next_cursor: str | None</code>  <code>property</code>","text":"<p>Cursor for the next page, if any.</p> <p>Returns the V2 pagination URL or V1 page token, whichever is present. Always use this property instead of accessing <code>pagination.next_cursor</code> or <code>next_page_token</code> directly.</p>"},{"location":"reference/models/#affinity.models.PaginatedResponse.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Number of items in current page.</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Number of items in current page.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"reference/models/#affinity.models.PaginationInfo","title":"<code>PaginationInfo</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>V2 pagination info returned in responses.</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>class PaginationInfo(AffinityModel):\n    \"\"\"V2 pagination info returned in responses.\"\"\"\n\n    next_cursor: str | None = Field(None, alias=\"nextUrl\")\n    prev_cursor: str | None = Field(None, alias=\"prevUrl\")\n</code></pre>"},{"location":"reference/models/#affinity.models.PaginationProgress","title":"<code>PaginationProgress</code>  <code>dataclass</code>","text":"<p>Progress information for pagination callbacks.</p> Source code in <code>affinity/models/pagination.py</code> <pre><code>@dataclass\nclass PaginationProgress:\n    \"\"\"Progress information for pagination callbacks.\"\"\"\n\n    page_number: int\n    \"\"\"1-indexed page number.\"\"\"\n\n    items_in_page: int\n    \"\"\"Items in current page.\"\"\"\n\n    items_so_far: int\n    \"\"\"Cumulative items *including* just-yielded page.\"\"\"\n\n    has_next: bool\n    \"\"\"Whether more pages exist (matches Page.has_next).\"\"\"\n</code></pre>"},{"location":"reference/models/#affinity.models.PaginationProgress.has_next","title":"<code>has_next: bool</code>  <code>instance-attribute</code>","text":"<p>Whether more pages exist (matches Page.has_next).</p>"},{"location":"reference/models/#affinity.models.PaginationProgress.items_in_page","title":"<code>items_in_page: int</code>  <code>instance-attribute</code>","text":"<p>Items in current page.</p>"},{"location":"reference/models/#affinity.models.PaginationProgress.items_so_far","title":"<code>items_so_far: int</code>  <code>instance-attribute</code>","text":"<p>Cumulative items including just-yielded page.</p>"},{"location":"reference/models/#affinity.models.PaginationProgress.page_number","title":"<code>page_number: int</code>  <code>instance-attribute</code>","text":"<p>1-indexed page number.</p>"},{"location":"reference/models/#affinity.models.Person","title":"<code>Person</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Full person representation.</p> <p>Note: Companies are called Organizations in V1 API.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class Person(AffinityModel):\n    \"\"\"\n    Full person representation.\n\n    Note: Companies are called Organizations in V1 API.\n    \"\"\"\n\n    id: PersonId\n    first_name: str | None = Field(None, alias=\"firstName\")\n    last_name: str | None = Field(None, alias=\"lastName\")\n    primary_email: str | None = Field(None, alias=\"primaryEmailAddress\")\n    # V2 uses emailAddresses, V1 uses emails - accept both via alias\n    emails: list[str] = Field(default_factory=list, alias=\"emailAddresses\")\n    type: PersonType = PersonType.EXTERNAL\n\n    @field_validator(\"type\", mode=\"before\")\n    @classmethod\n    def _coerce_person_type(cls, value: Any) -&gt; Any:\n        return _normalize_person_type(value)\n\n    # Associations (V1 uses organizationIds)\n    company_ids: list[CompanyId] = Field(default_factory=list, alias=\"organizationIds\")\n    opportunity_ids: list[OpportunityId] = Field(default_factory=list, alias=\"opportunityIds\")\n\n    # V1: only returned when `with_current_organizations=true`\n    current_company_ids: list[CompanyId] = Field(\n        default_factory=list, alias=\"currentOrganizationIds\"\n    )\n\n    # Field values (requested-vs-not-requested preserved)\n    fields: FieldValues = Field(default_factory=FieldValues, alias=\"fields\")\n    fields_raw: list[dict[str, Any]] | None = Field(default=None, exclude=True)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _normalize_null_lists_before(cls, value: Any) -&gt; Any:\n        value = _normalize_null_lists(\n            value,\n            (\n                \"emails\",\n                \"emailAddresses\",\n                \"companyIds\",\n                \"company_ids\",\n                \"organizationIds\",\n                \"organization_ids\",\n                \"currentCompanyIds\",\n                \"current_company_ids\",\n                \"currentOrganizationIds\",\n                \"current_organization_ids\",\n                \"opportunityIds\",\n                \"opportunity_ids\",\n            ),\n        )\n        return _preserve_fields_raw(value)\n\n    @model_validator(mode=\"after\")\n    def _mark_fields_not_requested_when_omitted(self) -&gt; Person:\n        if \"fields\" not in self.__pydantic_fields_set__:\n            self.fields.requested = False\n        return self\n\n    # Interaction dates (V1 format, returned when with_interaction_dates=True)\n    interaction_dates: InteractionDates | None = Field(None, alias=\"interactionDates\")\n\n    # Detailed interaction data with person IDs (returned when with_interaction_persons=True)\n    interactions: Interactions | None = None\n\n    # List entries (returned for single person fetch)\n    list_entries: list[ListEntry] | None = Field(None, alias=\"listEntries\")\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Get the person's full name.\"\"\"\n        parts = [self.first_name, self.last_name]\n        return \" \".join(p for p in parts if p) or \"\"\n</code></pre>"},{"location":"reference/models/#affinity.models.Person.full_name","title":"<code>full_name: str</code>  <code>property</code>","text":"<p>Get the person's full name.</p>"},{"location":"reference/models/#affinity.models.PersonCreate","title":"<code>PersonCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a new person (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class PersonCreate(AffinityModel):\n    \"\"\"Data for creating a new person (V1 API).\"\"\"\n\n    first_name: str\n    last_name: str\n    emails: list[str] = Field(default_factory=list)\n    company_ids: list[CompanyId] = Field(default_factory=list, alias=\"organization_ids\")\n</code></pre>"},{"location":"reference/models/#affinity.models.PersonUpdate","title":"<code>PersonUpdate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for updating a person (V1 API).</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class PersonUpdate(AffinityModel):\n    \"\"\"Data for updating a person (V1 API).\"\"\"\n\n    first_name: str | None = None\n    last_name: str | None = None\n    emails: list[str] | None = None\n    company_ids: list[CompanyId] | None = Field(None, alias=\"organization_ids\")\n</code></pre>"},{"location":"reference/models/#affinity.models.RateLimitBucket","title":"<code>RateLimitBucket</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A single rate limit bucket (quota window).</p> Source code in <code>affinity/models/rate_limit_snapshot.py</code> <pre><code>class RateLimitBucket(AffinityModel):\n    \"\"\"A single rate limit bucket (quota window).\"\"\"\n\n    limit: int | None = None\n    remaining: int | None = None\n    reset_seconds: int | None = Field(None, alias=\"resetSeconds\")\n    used: int | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.RateLimitInfo","title":"<code>RateLimitInfo</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Rate limit information for an API key.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class RateLimitInfo(AffinityModel):\n    \"\"\"Rate limit information for an API key.\"\"\"\n\n    limit: int\n    remaining: int\n    reset: int  # Seconds until reset\n    used: int\n</code></pre>"},{"location":"reference/models/#affinity.models.RateLimitSnapshot","title":"<code>RateLimitSnapshot</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A best-effort snapshot of rate limit state.</p> <p>Notes: - <code>source=\"headers\"</code> means the snapshot is derived from tracked HTTP response headers. - <code>source=\"endpoint\"</code> means the snapshot is derived from a dedicated endpoint response payload. - <code>source=\"unknown\"</code> means no reliable rate limit information has been observed yet.</p> Source code in <code>affinity/models/rate_limit_snapshot.py</code> <pre><code>class RateLimitSnapshot(AffinityModel):\n    \"\"\"\n    A best-effort snapshot of rate limit state.\n\n    Notes:\n    - `source=\"headers\"` means the snapshot is derived from tracked HTTP response headers.\n    - `source=\"endpoint\"` means the snapshot is derived from a dedicated endpoint response payload.\n    - `source=\"unknown\"` means no reliable rate limit information has been observed yet.\n    \"\"\"\n\n    api_key_per_minute: RateLimitBucket = Field(\n        default_factory=RateLimitBucket, alias=\"apiKeyPerMinute\"\n    )\n    org_monthly: RateLimitBucket = Field(default_factory=RateLimitBucket, alias=\"orgMonthly\")\n    concurrent: RateLimitBucket | None = None\n\n    observed_at: datetime | None = Field(None, alias=\"observedAt\")\n    age_seconds: float | None = Field(None, alias=\"ageSeconds\")\n    source: RateLimitSource = \"unknown\"\n    request_id: str | None = Field(None, alias=\"requestId\")\n</code></pre>"},{"location":"reference/models/#affinity.models.RateLimits","title":"<code>RateLimits</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Current rate limit status.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class RateLimits(AffinityModel):\n    \"\"\"Current rate limit status.\"\"\"\n\n    org_monthly: RateLimitInfo = Field(alias=\"orgMonthly\")\n    api_key_per_minute: RateLimitInfo = Field(alias=\"apiKeyPerMinute\")\n</code></pre>"},{"location":"reference/models/#affinity.models.RelationshipStrength","title":"<code>RelationshipStrength</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Relationship strength between internal and external persons.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class RelationshipStrength(AffinityModel):\n    \"\"\"Relationship strength between internal and external persons.\"\"\"\n\n    internal_id: UserId = Field(alias=\"internalId\")\n    external_id: PersonId = Field(alias=\"externalId\")\n    strength: float  # 0.0 to 1.0\n</code></pre>"},{"location":"reference/models/#affinity.models.Reminder","title":"<code>Reminder</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A reminder attached to an entity.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class Reminder(AffinityModel):\n    \"\"\"A reminder attached to an entity.\"\"\"\n\n    id: ReminderIdType\n    type: ReminderType\n    status: ReminderStatus\n    content: str | None = None\n\n    # Due date and recurrence\n    due_date: ISODatetime = Field(alias=\"dueDate\")\n    reset_type: ReminderResetType | None = Field(None, alias=\"resetType\")\n    reminder_days: int | None = Field(None, alias=\"reminderDays\")\n\n    # Persons involved\n    creator: PersonSummary | None = None\n    owner: PersonSummary | None = None\n    completer: PersonSummary | None = None\n\n    # Associated entity (one of these)\n    person: PersonSummary | None = None\n    company: dict[str, Any] | None = Field(None, alias=\"organization\")\n    opportunity: dict[str, Any] | None = None\n\n    # Timestamps\n    created_at: ISODatetime = Field(alias=\"createdAt\")\n    completed_at: ISODatetime | None = Field(None, alias=\"completedAt\")\n</code></pre>"},{"location":"reference/models/#affinity.models.ReminderCreate","title":"<code>ReminderCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a reminder (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class ReminderCreate(AffinityModel):\n    \"\"\"Data for creating a reminder (V1 API).\"\"\"\n\n    owner_id: UserId\n    type: ReminderType\n    content: str | None = None\n    due_date: ISODatetime | None = None  # Required for one-time\n    reset_type: ReminderResetType | None = None  # Required for recurring\n    reminder_days: int | None = None  # Required for recurring\n\n    # Associate with one entity\n    person_id: PersonId | None = None\n    company_id: CompanyId | None = Field(None, alias=\"organization_id\")\n    opportunity_id: OpportunityId | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.ReminderUpdate","title":"<code>ReminderUpdate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for updating a reminder (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class ReminderUpdate(AffinityModel):\n    \"\"\"Data for updating a reminder (V1 API).\"\"\"\n\n    owner_id: UserId | None = None\n    type: ReminderType | None = None\n    content: str | None = None\n    due_date: ISODatetime | None = None\n    reset_type: ReminderResetType | None = None\n    reminder_days: int | None = None\n    is_completed: bool | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.SavedView","title":"<code>SavedView</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A saved view configuration for a list.</p> Source code in <code>affinity/models/entities.py</code> <pre><code>class SavedView(AffinityModel):\n    \"\"\"A saved view configuration for a list.\"\"\"\n\n    id: SavedViewId\n    name: str\n    type: str | None = None  # V2 field: view type\n    list_id: ListId | None = Field(None, alias=\"listId\")\n    # The Affinity API does not consistently include this field.\n    is_default: bool | None = Field(None, alias=\"isDefault\")\n    created_at: ISODatetime | None = Field(None, alias=\"createdAt\")\n\n    # Field IDs included in this view\n    field_ids: list[str] = Field(default_factory=list, alias=\"fieldIds\")\n</code></pre>"},{"location":"reference/models/#affinity.models.Tenant","title":"<code>Tenant</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Affinity tenant (organization/team) information.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class Tenant(AffinityModel):\n    \"\"\"Affinity tenant (organization/team) information.\"\"\"\n\n    id: TenantId\n    name: str\n    subdomain: str\n</code></pre>"},{"location":"reference/models/#affinity.models.WebhookCreate","title":"<code>WebhookCreate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for creating a webhook subscription (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class WebhookCreate(AffinityModel):\n    \"\"\"Data for creating a webhook subscription (V1 API).\"\"\"\n\n    webhook_url: str\n    subscriptions: list[WebhookEvent] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/models/#affinity.models.WebhookSubscription","title":"<code>WebhookSubscription</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>A webhook subscription for real-time events.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class WebhookSubscription(AffinityModel):\n    \"\"\"A webhook subscription for real-time events.\"\"\"\n\n    id: WebhookId\n    webhook_url: str = Field(alias=\"webhookUrl\")\n    subscriptions: list[WebhookEvent] = Field(default_factory=list)\n    disabled: bool = False\n    created_by: UserId = Field(alias=\"createdBy\")\n</code></pre>"},{"location":"reference/models/#affinity.models.WebhookUpdate","title":"<code>WebhookUpdate</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Data for updating a webhook subscription (V1 API).</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class WebhookUpdate(AffinityModel):\n    \"\"\"Data for updating a webhook subscription (V1 API).\"\"\"\n\n    webhook_url: str | None = None\n    subscriptions: list[WebhookEvent] | None = None\n    disabled: bool | None = None\n</code></pre>"},{"location":"reference/models/#affinity.models.WhoAmI","title":"<code>WhoAmI</code>","text":"<p>               Bases: <code>AffinityModel</code></p> <p>Response from whoami endpoint.</p> Source code in <code>affinity/models/secondary.py</code> <pre><code>class WhoAmI(AffinityModel):\n    \"\"\"Response from whoami endpoint.\"\"\"\n\n    tenant: Tenant\n    user: User\n    grant: Grant\n</code></pre>"},{"location":"reference/query-language/","title":"Query Language Reference","text":"<p>This document provides a complete reference for the Affinity CLI query language.</p>"},{"location":"reference/query-language/#quick-start","title":"Quick Start","text":"<pre><code>// Simplest query - get 10 persons\n{\"from\": \"persons\", \"limit\": 10}\n\n// Add a filter\n{\"from\": \"persons\", \"where\": {\"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.com\"}, \"limit\": 10}\n\n// Include related companies\n{\"from\": \"persons\", \"include\": [\"companies\"], \"limit\": 10}\n</code></pre> <p>Run with: <pre><code>xaffinity query --query '{\"from\": \"persons\", \"limit\": 10}'\n</code></pre></p>"},{"location":"reference/query-language/#query-object","title":"Query Object","text":"<pre><code>{\n  \"$version\": \"1.0\",\n  \"from\": \"persons\",\n  \"select\": [\"id\", \"firstName\", \"lastName\"],\n  \"where\": { ... },\n  \"include\": [\"companies\"],\n  \"expand\": [\"interactionDates\"],\n  \"orderBy\": [{ \"field\": \"lastName\", \"direction\": \"asc\" }],\n  \"groupBy\": \"status\",\n  \"aggregate\": { ... },\n  \"having\": { ... },\n  \"limit\": 100\n}\n</code></pre>"},{"location":"reference/query-language/#fields","title":"Fields","text":"Field Type Required Description <code>$version</code> string No Query format version (default: <code>\"1.0\"</code>) <code>from</code> string Yes Entity type to query <code>select</code> string[] No Fields to return (default: all) <code>where</code> WhereClause No Filter conditions <code>include</code> string[] No Related entities to fetch <code>expand</code> string[] No Computed data to add (e.g., <code>interactionDates</code>) <code>orderBy</code> OrderByClause[] No Sort order <code>groupBy</code> string No Field to group by <code>aggregate</code> AggregateMap No Aggregate functions <code>having</code> HavingClause No Filter on aggregates <code>limit</code> integer No Maximum records <code>cursor</code> string No Pagination cursor"},{"location":"reference/query-language/#entity-types","title":"Entity Types","text":"Entity Description Service Query Type <code>persons</code> People in CRM PersonService Direct <code>companies</code> Companies/organizations CompanyService Direct <code>opportunities</code> Deals/opportunities OpportunityService Direct <code>lists</code> Affinity list definitions ListService Direct <code>listEntries</code> Entries in Affinity lists ListEntryService Requires parent filter <code>interactions</code> Emails, calls, meetings InteractionService Include only <code>notes</code> Notes on entities NoteService Include only"},{"location":"reference/query-language/#query-type-details","title":"Query Type Details","text":"<p>Direct - Can be queried without any required filters: <pre><code>{\"from\": \"persons\", \"limit\": 10}\n</code></pre></p> <p>Requires parent filter - Must specify parent context: <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\"path\": \"listId\", \"op\": \"eq\", \"value\": 12345}\n}\n</code></pre></p> <p>The <code>listEntries</code> entity supports: - <code>listId</code> filter with <code>eq</code> or <code>in</code> operator - <code>listName</code> filter (resolved to <code>listId</code> automatically) - Multiple lists via <code>in</code> operator or <code>or</code> conditions - <code>fields.*</code> paths with human-readable field names (resolved to field IDs automatically)</p> <p>Include only - Cannot be queried directly; use as relationship include: <pre><code>{\n  \"from\": \"persons\",\n  \"include\": [\"interactions\", \"notes\"]\n}\n</code></pre></p> <p>Direct queries for include-only entities will fail with helpful guidance: <pre><code>QueryParseError: 'interactions' cannot be queried directly.\nUse it as an 'include' on a parent entity instead.\nExample: {\"from\": \"persons\", \"include\": [\"interactions\"]}\n</code></pre></p>"},{"location":"reference/query-language/#where-clause","title":"WHERE Clause","text":""},{"location":"reference/query-language/#simple-condition","title":"Simple Condition","text":"<pre><code>{\n  \"path\": \"email\",\n  \"op\": \"contains\",\n  \"value\": \"@acme.com\"\n}\n</code></pre> Field Type Required Description <code>path</code> string Yes* Field path (dot notation) <code>op</code> string Yes Comparison operator <code>value</code> any Depends Comparison value <p>*Either <code>path</code> or <code>expr</code> is required.</p>"},{"location":"reference/query-language/#operators","title":"Operators","text":""},{"location":"reference/query-language/#comparison","title":"Comparison","text":"Operator Description Value Type <code>eq</code> Equal any <code>neq</code> Not equal any <code>gt</code> Greater than number, date <code>gte</code> Greater or equal number, date <code>lt</code> Less than number, date <code>lte</code> Less or equal number, date"},{"location":"reference/query-language/#string","title":"String","text":"Operator Description Value Type <code>contains</code> Contains substring string <code>starts_with</code> Starts with prefix string"},{"location":"reference/query-language/#collection","title":"Collection","text":"Operator Description Value Type <code>in</code> Value in list array <code>between</code> Value in range [min, max] <code>contains_any</code> Array has any of array <code>contains_all</code> Array has all of array"},{"location":"reference/query-language/#null","title":"Null","text":"Operator Description Value <code>is_null</code> Field is null (none) <code>is_not_null</code> Field is not null (none)"},{"location":"reference/query-language/#compound-conditions","title":"Compound Conditions","text":""},{"location":"reference/query-language/#and","title":"AND","text":"<pre><code>{\n  \"and\": [\n    { \"path\": \"status\", \"op\": \"eq\", \"value\": \"Active\" },\n    { \"path\": \"amount\", \"op\": \"gt\", \"value\": 10000 }\n  ]\n}\n</code></pre>"},{"location":"reference/query-language/#or","title":"OR","text":"<pre><code>{\n  \"or\": [\n    { \"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.com\" },\n    { \"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.io\" }\n  ]\n}\n</code></pre>"},{"location":"reference/query-language/#not","title":"NOT","text":"<pre><code>{\n  \"not\": { \"path\": \"status\", \"op\": \"eq\", \"value\": \"Closed\" }\n}\n</code></pre>"},{"location":"reference/query-language/#quantifiers","title":"Quantifiers","text":"<p>Quantifiers filter records based on related entities. They require fetching relationship data (N+1 API calls).</p>"},{"location":"reference/query-language/#all","title":"ALL","text":"<p>All related items must match the condition:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": {\n    \"all\": {\n      \"path\": \"companies\",\n      \"where\": { \"path\": \"domain\", \"op\": \"contains\", \"value\": \".com\" }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#none","title":"NONE","text":"<p>No related items may match the condition:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": {\n    \"none\": {\n      \"path\": \"companies\",\n      \"where\": { \"path\": \"name\", \"op\": \"contains\", \"value\": \"Competitor\" }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#count","title":"COUNT","text":"<p>Count related items using the <code>_count</code> pseudo-field:</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": { \"path\": \"companies._count\", \"op\": \"gte\", \"value\": 2 }\n}\n</code></pre>"},{"location":"reference/query-language/#exists-subquery","title":"EXISTS Subquery","text":"<p>Check if related items exist (optionally matching a filter):</p> <pre><code>{\n  \"from\": \"persons\",\n  \"where\": {\n    \"exists\": {\n      \"from\": \"interactions\",\n      \"where\": { \"path\": \"type\", \"op\": \"eq\", \"value\": \"meeting\" }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#field-paths","title":"Field Paths","text":""},{"location":"reference/query-language/#dot-notation","title":"Dot Notation","text":"<pre><code>email                    # Top-level field\nfields.Status            # Nested field\ncompany.name             # Related entity field (with include)\n</code></pre>"},{"location":"reference/query-language/#array-access","title":"Array Access","text":"<pre><code>emails[0]                # First element\nphones[-1]               # Last element\n</code></pre>"},{"location":"reference/query-language/#escaping","title":"Escaping","text":"<pre><code>fields[\"Field.With.Dots\"]\nfields[\"Field With Spaces\"]\n</code></pre>"},{"location":"reference/query-language/#field-name-resolution","title":"Field Name Resolution","text":"<p>For <code>listEntries</code> queries, <code>fields.*</code> paths support human-readable field names:</p> <pre><code>{\"path\": \"fields.Status\", \"op\": \"eq\", \"value\": \"Active\"}\n</code></pre> <p>Field names are resolved case-insensitively against the list's field definitions. If a name is not found, it passes through unchanged (allowing direct use of field IDs like <code>fields.12345</code> or <code>fields.field-260415</code>).</p>"},{"location":"reference/query-language/#field-value-normalization","title":"Field Value Normalization","text":"<p>When selecting custom fields in <code>listEntries</code> queries, reference field values are normalized to display strings for readability:</p> Field Type API Returns Normalized To Dropdown <code>{\"text\": \"Active\", \"id\": 1}</code> <code>\"Active\"</code> Multi-select <code>[{\"text\": \"A\"}, {\"text\": \"B\"}]</code> <code>[\"A\", \"B\"]</code> Person reference <code>{\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"id\": 123}</code> <code>\"Jane Doe\"</code> Company reference <code>{\"name\": \"Acme Corp\", \"id\": 456, \"domain\": \"acme.com\"}</code> <code>\"Acme Corp\"</code> Multi-person <code>[{\"firstName\": \"Jane\", ...}, {\"firstName\": \"John\", ...}]</code> <code>[\"Jane Doe\", \"John Smith\"]</code> <p>Example:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\"},\n  \"select\": [\"entityName\", \"fields.Status\", \"fields.Owner\"]\n}\n</code></pre> <p>Output: <pre><code>{\n  \"data\": [\n    {\n      \"entityName\": \"Acme Corp\",\n      \"fields\": {\n        \"Status\": \"Active\",\n        \"Owner\": \"Jane Doe\"\n      }\n    }\n  ]\n}\n</code></pre></p> <p>Need full entity details? Use <code>include</code> to fetch complete person/company records:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\"},\n  \"include\": [\"persons\", \"companies\"]\n}\n</code></pre>"},{"location":"reference/query-language/#discovering-available-fields","title":"Discovering Available Fields","text":"<p>Use the CLI to see what fields are available on each entity:</p> <pre><code># See person fields\nxaffinity person get &lt;id&gt; --json | jq 'keys'\n\n# See company fields\nxaffinity company get &lt;id&gt; --json | jq 'keys'\n\n# See list entry fields (including custom fields)\nxaffinity list entry ls --list-id &lt;id&gt; --limit 1 --json | jq '.[0] | keys'\n\n# See custom list field definitions\nxaffinity list field ls --list-id &lt;id&gt;\n</code></pre> <p>Use the discovered field names in your queries with <code>fields.&lt;FieldName&gt;</code> paths.</p>"},{"location":"reference/query-language/#date-values","title":"Date Values","text":""},{"location":"reference/query-language/#relative-dates","title":"Relative Dates","text":"Format Meaning <code>-Nd</code> N days ago <code>+Nd</code> N days from now <code>today</code> Start of today (00:00:00) <code>now</code> Current timestamp <code>yesterday</code> Start of yesterday <code>tomorrow</code> Start of tomorrow"},{"location":"reference/query-language/#iso-8601","title":"ISO 8601","text":"<pre><code>2024-01-15\n2024-01-15T10:30:00Z\n2024-01-15T10:30:00-05:00\n</code></pre>"},{"location":"reference/query-language/#order-by-clause","title":"ORDER BY Clause","text":"<pre><code>{\n  \"orderBy\": [\n    { \"field\": \"lastName\", \"direction\": \"asc\" },\n    { \"field\": \"firstName\", \"direction\": \"asc\" }\n  ]\n}\n</code></pre> Field Type Required Description <code>field</code> string Yes Field path <code>direction</code> string No <code>asc</code> (default) or <code>desc</code>"},{"location":"reference/query-language/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"reference/query-language/#basic-aggregates","title":"Basic Aggregates","text":"<pre><code>{\n  \"aggregate\": {\n    \"total\": { \"count\": true },\n    \"countField\": { \"count\": \"email\" },\n    \"totalAmount\": { \"sum\": \"amount\" },\n    \"avgAmount\": { \"avg\": \"amount\" },\n    \"minAmount\": { \"min\": \"amount\" },\n    \"maxAmount\": { \"max\": \"amount\" }\n  }\n}\n</code></pre> Function Description <code>count: true</code> Count all records <code>count: \"field\"</code> Count non-null values <code>sum: \"field\"</code> Sum numeric field <code>avg: \"field\"</code> Average numeric field <code>min: \"field\"</code> Minimum value <code>max: \"field\"</code> Maximum value"},{"location":"reference/query-language/#percentile","title":"Percentile","text":"<pre><code>{\n  \"aggregate\": {\n    \"p50\": { \"percentile\": { \"field\": \"amount\", \"p\": 50 } },\n    \"p90\": { \"percentile\": { \"field\": \"amount\", \"p\": 90 } }\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#firstlast","title":"First/Last","text":"<pre><code>{\n  \"aggregate\": {\n    \"firstDate\": { \"first\": \"created_at\" },\n    \"latestDate\": { \"last\": \"created_at\" }\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#expression-aggregates","title":"Expression Aggregates","text":"<pre><code>{\n  \"aggregate\": {\n    \"total\": { \"sum\": \"amount\" },\n    \"count\": { \"count\": true },\n    \"average\": { \"divide\": [\"total\", \"count\"] },\n    \"adjusted\": { \"multiply\": [\"average\", 1.1] },\n    \"withBonus\": { \"add\": [\"total\", 1000] },\n    \"discounted\": { \"subtract\": [\"total\", 500] }\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#having-clause","title":"HAVING Clause","text":"<p>Filter groups by aggregate values:</p> <pre><code>{\n  \"groupBy\": \"status\",\n  \"aggregate\": {\n    \"count\": { \"count\": true },\n    \"total\": { \"sum\": \"amount\" }\n  },\n  \"having\": {\n    \"and\": [\n      { \"path\": \"count\", \"op\": \"gte\", \"value\": 5 },\n      { \"path\": \"total\", \"op\": \"gt\", \"value\": 100000 }\n    ]\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#include-vs-quantifiers","title":"Include vs Quantifiers","text":"<p>Both <code>include</code> and quantifiers fetch relationship data, but serve different purposes:</p> Feature <code>include</code> Quantifiers (<code>all</code>, <code>none</code>, <code>exists</code>, <code>_count</code>) Purpose Get related data in response Filter based on related data Output Related records in result Only affects which records match Use case \"Show me persons WITH their companies\" \"Show me persons WHO HAVE 2+ companies\""},{"location":"reference/query-language/#examples","title":"Examples","text":"<pre><code>// Include: Get persons and their companies\n{\"from\": \"persons\", \"include\": [\"companies\"], \"limit\": 10}\n// Result: [{\"id\": 1, \"firstName\": \"John\", \"companies\": [{\"id\": 100, \"name\": \"Acme\"}]}]\n\n// Quantifier: Get persons who have 2+ companies (companies not in result)\n{\"from\": \"persons\", \"where\": {\"path\": \"companies._count\", \"op\": \"gte\", \"value\": 2}, \"limit\": 10}\n// Result: [{\"id\": 1, \"firstName\": \"John\"}]\n\n// Both: Get persons with 2+ companies AND include those companies\n{\"from\": \"persons\", \"where\": {\"path\": \"companies._count\", \"op\": \"gte\", \"value\": 2}, \"include\": [\"companies\"], \"limit\": 10}\n</code></pre>"},{"location":"reference/query-language/#include-relationships","title":"Include Relationships","text":""},{"location":"reference/query-language/#available-relationships","title":"Available Relationships","text":"<p>From <code>persons</code>: - <code>companies</code> - Associated companies - <code>opportunities</code> - Associated opportunities - <code>interactions</code> - Interactions involving person - <code>notes</code> - Notes on person</p> <p>From <code>companies</code>: - <code>persons</code> - Associated persons - <code>opportunities</code> - Associated opportunities - <code>interactions</code> - Interactions involving company - <code>notes</code> - Notes on company</p> <p>From <code>opportunities</code>: - <code>persons</code> - Associated persons - <code>companies</code> - Associated companies - <code>interactions</code> - Interactions on opportunity - <code>notes</code> - Notes on opportunity</p> <p>From <code>listEntries</code>: - <code>entity</code> - Dynamically resolves to person/company/opportunity based on entityType - <code>persons</code> - Associated persons (for company/opportunity entries) - <code>companies</code> - Associated companies (for person/opportunity entries) - <code>opportunities</code> - Associated opportunities (for person/company entries) - <code>interactions</code> - Interactions for the list entry's entity</p>"},{"location":"reference/query-language/#include-syntax","title":"Include Syntax","text":"<pre><code>{\n  \"from\": \"persons\",\n  \"include\": [\"companies\", \"opportunities\"]\n}\n</code></pre> <p>Included data appears separately from main records:</p> <pre><code>{\n  \"data\": [\n    {\n      \"id\": 123,\n      \"firstName\": \"John\",\n      \"organizationIds\": [456]\n    }\n  ],\n  \"included\": {\n    \"companies\": [\n      { \"id\": 456, \"name\": \"Acme Inc\", \"domain\": \"acme.com\" }\n    ],\n    \"opportunities\": []\n  }\n}\n</code></pre> <p>In table output, included data renders as separate tables with headers like \"Included: companies\".</p> <p>In JSON output, the <code>included</code> section contains deduplicated records keyed by relationship name. Parent records reference included entities via ID fields (e.g., <code>organizationIds</code> for companies).</p>"},{"location":"reference/query-language/#parameterized-includes","title":"Parameterized Includes","text":"<p>When including relationships for <code>listEntries</code>, you can customize the fetch with parameters:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\"},\n  \"include\": [\n    {\"interactions\": {\"limit\": 50, \"days\": 180}},\n    {\"opportunities\": {\"list\": \"Pipeline\"}},\n    {\"persons\": {\"where\": {\"path\": \"firstName\", \"op\": \"contains\", \"value\": \"John\"}}}\n  ]\n}\n</code></pre> Parameter Description Default <code>limit</code> Max records per entity 100 <code>days</code> Lookback window in days (for interactions) 90 <code>list</code> Scope opportunities to specific list name/ID All <code>where</code> Filter included entities None"},{"location":"reference/query-language/#expand-computed-data","title":"Expand (Computed Data)","text":"<p>Unlike <code>include</code> (which fetches separate related entities), <code>expand</code> enriches records with computed data directly on each record.</p>"},{"location":"reference/query-language/#available-expansions","title":"Available Expansions","text":"Expansion Description Supported Entities <code>interactionDates</code> Last/next meeting, email dates, team members <code>persons</code>, <code>companies</code>, <code>listEntries</code> <code>unreplied</code> Detect unreplied incoming messages - email/chat (date, daysSince, type, subject) <code>persons</code>, <code>companies</code>, <code>opportunities</code>, <code>listEntries</code>"},{"location":"reference/query-language/#expand-syntax","title":"Expand Syntax","text":"<pre><code>{\n  \"from\": \"companies\",\n  \"where\": {\"path\": \"name\", \"op\": \"contains\", \"value\": \"Acme\"},\n  \"expand\": [\"interactionDates\"],\n  \"limit\": 10\n}\n</code></pre>"},{"location":"reference/query-language/#expand-vs-include","title":"Expand vs Include","text":"Feature <code>include</code> <code>expand</code> Purpose Fetch related entities Add computed data to records Output Location <code>result.included</code> or embedded Merged into <code>result.data</code> Example <code>include: [\"companies\"]</code> \u2192 separate company records <code>expand: [\"interactionDates\"]</code> \u2192 dates on each record"},{"location":"reference/query-language/#interaction-dates-output","title":"Interaction Dates Output","text":"<p>When using <code>expand: [\"interactionDates\"]</code>, each record includes:</p> <pre><code>{\n  \"id\": 123,\n  \"name\": \"Acme Corp\",\n  \"interactionDates\": {\n    \"lastMeeting\": {\n      \"date\": \"2026-01-08T10:00:00Z\",\n      \"daysSince\": 5,\n      \"teamMemberIds\": [1, 2],\n      \"teamMemberNames\": [\"Bob Smith\", \"Carol Jones\"]\n    },\n    \"nextMeeting\": {\n      \"date\": \"2026-01-20T14:00:00Z\",\n      \"daysUntil\": 7,\n      \"teamMemberIds\": [3],\n      \"teamMemberNames\": [\"Alice Wong\"]\n    },\n    \"lastEmail\": {\n      \"date\": \"2026-01-10T09:30:00Z\",\n      \"daysSince\": 3\n    },\n    \"lastInteraction\": {\n      \"date\": \"2026-01-10T09:30:00Z\",\n      \"daysSince\": 3\n    }\n  }\n}\n</code></pre>"},{"location":"reference/query-language/#with-listentries","title":"With listEntries","text":"<p>For <code>listEntries</code> queries, interaction dates are fetched for the underlying company or person:</p> <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\"},\n  \"expand\": [\"interactionDates\"],\n  \"select\": [\"entityId\", \"entityName\", \"fields.Status\"]\n}\n</code></pre> <p>Note: Expansion requires N+1 API calls (one per record). For large result sets, use <code>limit</code> or consider <code>list export --expand interactions</code> for streaming output.</p>"},{"location":"reference/query-language/#error-responses","title":"Error Responses","text":""},{"location":"reference/query-language/#parse-error","title":"Parse Error","text":"<pre><code>{\n  \"error\": \"QueryParseError\",\n  \"message\": \"Unknown operator 'like'. Supported: eq, neq, gt, gte, lt, lte, contains, starts_with, in, between, is_null, is_not_null\",\n  \"field\": \"where.op\"\n}\n</code></pre>"},{"location":"reference/query-language/#validation-error","title":"Validation Error","text":"<pre><code>{\n  \"error\": \"QueryValidationError\",\n  \"message\": \"Cannot use 'aggregate' with 'include'. Aggregates collapse records.\",\n  \"field\": \"aggregate\"\n}\n</code></pre>"},{"location":"reference/query-language/#execution-error","title":"Execution Error","text":"<pre><code>{\n  \"error\": \"QueryExecutionError\",\n  \"message\": \"Failed to fetch persons: API rate limit exceeded\"\n}\n</code></pre>"},{"location":"reference/query-language/#version-history","title":"Version History","text":"Version Status Changes <code>1.0</code> Current Initial release with full query language"},{"location":"reference/query-language/#constraints","title":"Constraints","text":"<ul> <li><code>aggregate</code> and <code>include</code> cannot be used together</li> <li><code>groupBy</code> requires <code>aggregate</code></li> <li><code>having</code> requires <code>aggregate</code></li> <li><code>limit</code> must be non-negative</li> <li>Maximum 10,000 records per query</li> </ul>"},{"location":"reference/query-language/#performance-considerations","title":"Performance Considerations","text":""},{"location":"reference/query-language/#decision-tree-for-quantifier-queries","title":"Decision Tree for Quantifier Queries","text":"<pre><code>Do you need all, none, exists, or _count?\n\u251c\u2500\u2500 No \u2192 Use normal filters (fast, no N+1 calls)\n\u2514\u2500\u2500 Yes \u2192 What entity are you querying from?\n    \u251c\u2500\u2500 listEntries \u2192 Safe (bounded by list size)\n    \u2514\u2500\u2500 persons/companies/opportunities \u2192 \u26a0\ufe0f Read below\n        \u251c\u2500\u2500 Add cheap pre-filters first to reduce dataset\n        \u251c\u2500\u2500 Use --max-records 100 for exploration\n        \u2514\u2500\u2500 Use --dry-run to preview API calls\n</code></pre>"},{"location":"reference/query-language/#quantifier-queries-on-large-databases","title":"Quantifier Queries on Large Databases","text":"<p>The <code>all</code>, <code>none</code>, <code>exists</code>, and <code>_count</code> operators require fetching relationship data for each record. This causes N+1 API calls, which can be very slow on large databases.</p> Database Size N+1 API Calls Time @ 30 req/s Verdict 100 records 100 ~3 seconds \u2705 Usable 1,000 records 1,000 ~33 seconds \u26a0\ufe0f Slow 10,000 records 10,000 ~5.5 minutes \u274c Painful <p>Important: Unbounded queries (from <code>persons</code>, <code>companies</code>, or <code>opportunities</code>) with quantifier filters require explicit <code>--max-records</code> to prevent accidentally running very long queries.</p>"},{"location":"reference/query-language/#recommended-patterns","title":"Recommended Patterns","text":"<ol> <li> <p>Start from listEntries (bounded by list size):    <pre><code>{\n  \"from\": \"listEntries\",\n  \"where\": {\n    \"and\": [\n      {\"path\": \"listId\", \"op\": \"eq\", \"value\": 12345},\n      {\"path\": \"entity.companies._count\", \"op\": \"gte\", \"value\": 2}\n    ]\n  }\n}\n</code></pre></p> </li> <li> <p>Add pre-filters to reduce dataset first:    <pre><code>{\n  \"from\": \"companies\",\n  \"where\": {\n    \"and\": [\n      {\"path\": \"domain\", \"op\": \"contains\", \"value\": \"example\"},\n      {\"path\": \"persons._count\", \"op\": \"gte\", \"value\": 2}\n    ]\n  },\n  \"limit\": 10\n}\n</code></pre>    Then run with: <code>xaffinity query --file query.json --max-records 100</code></p> </li> <li> <p>Use --max-records for exploration:    <pre><code>xaffinity query --query '...' --max-records 100\n</code></pre></p> </li> </ol>"},{"location":"reference/query-language/#lazy-loading-optimization","title":"Lazy Loading Optimization","text":"<p>When a query has both cheap filters (local field comparisons) and expensive filters (quantifiers), the engine automatically applies cheap filters first to reduce the dataset before making N+1 API calls. This can dramatically reduce execution time.</p>"},{"location":"reference/query-language/#using-dry-run","title":"Using Dry-Run","text":"<p>Always preview expensive queries with <code>--dry-run</code>:</p> <pre><code>xaffinity query --file query.json --dry-run\n</code></pre> <p>The dry-run output shows: - Estimated API calls (or \"UNBOUNDED\" for unbounded quantifier queries) - Whether <code>--max-records</code> is required - Lazy loading optimization status</p>"},{"location":"reference/query-language/#design-notes","title":"Design Notes","text":""},{"location":"reference/query-language/#why-a-custom-query-syntax","title":"Why a Custom Query Syntax?","text":"<p>You might wonder why we didn't use SQL, Pandas, or JMESPath. Our query engine needs to optimize API calls\u2014partitioning filters into local evaluations vs. those requiring relationship fetches, estimating costs before execution, and supporting entity-specific constraints (like <code>listEntries</code> requiring a list context). These capabilities don't map cleanly to general-purpose query languages.</p> <p>For post-processing, you can pipe JSON output to <code>jq</code> or load results into Pandas/DuckDB for further analysis.</p>"},{"location":"reference/types/","title":"Types","text":"<p>Stable types import path.</p> <p>This module re-exports ID types, enums, and constants from <code>affinity.models.types</code>.</p>"},{"location":"reference/types/#affinity.types.CompanyId","title":"<code>CompanyId</code>","text":"<p>               Bases: <code>IntId</code></p> <p>Called Organization in V1.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class CompanyId(IntId):\n    \"\"\"Called Organization in V1.\"\"\"\n</code></pre>"},{"location":"reference/types/#affinity.types.DropdownOptionColor","title":"<code>DropdownOptionColor</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Colors for dropdown options.</p> <p>Affinity uses integer color codes for dropdown field options.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class DropdownOptionColor(IntEnum):\n    \"\"\"\n    Colors for dropdown options.\n\n    Affinity uses integer color codes for dropdown field options.\n    \"\"\"\n\n    DEFAULT = 0\n    BLUE = 1\n    GREEN = 2\n    YELLOW = 3\n    ORANGE = 4\n    RED = 5\n    PURPLE = 6\n    GRAY = 7\n</code></pre>"},{"location":"reference/types/#affinity.types.EnrichedFieldId","title":"<code>EnrichedFieldId</code>","text":"<p>               Bases: <code>StrId</code></p> <p>Enriched field IDs are strings in V2 (e.g., 'affinity-data-description').</p> Source code in <code>affinity/models/types.py</code> <pre><code>class EnrichedFieldId(StrId):\n    \"\"\"Enriched field IDs are strings in V2 (e.g., 'affinity-data-description').\"\"\"\n</code></pre>"},{"location":"reference/types/#affinity.types.EntityType","title":"<code>EntityType</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>Entity types in Affinity.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class EntityType(OpenIntEnum):\n    \"\"\"Entity types in Affinity.\"\"\"\n\n    PERSON = 0\n    ORGANIZATION = 1\n    OPPORTUNITY = 8\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldId","title":"<code>FieldId</code>","text":"<p>               Bases: <code>StrId</code></p> <p>V2-style field id (e.g. 'field-123').</p> <p>FieldId provides normalized comparison semantics: - <code>FieldId(123) == FieldId(\"123\")</code> \u2192 <code>True</code> - <code>FieldId(\"field-123\") == \"field-123\"</code> \u2192 <code>True</code> - <code>FieldId(\"field-123\") == 123</code> \u2192 <code>True</code></p> <p>This normalization is specific to FieldId because field IDs uniquely come from mixed sources (some APIs return integers, some return strings like \"field-123\"). Other TypedId subclasses (PersonId, CompanyId, etc.) don't have this problem - they consistently use integers.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class FieldId(StrId):\n    \"\"\"\n    V2-style field id (e.g. 'field-123').\n\n    FieldId provides normalized comparison semantics:\n    - ``FieldId(123) == FieldId(\"123\")`` \u2192 ``True``\n    - ``FieldId(\"field-123\") == \"field-123\"`` \u2192 ``True``\n    - ``FieldId(\"field-123\") == 123`` \u2192 ``True``\n\n    This normalization is specific to FieldId because field IDs uniquely come\n    from mixed sources (some APIs return integers, some return strings like\n    \"field-123\"). Other TypedId subclasses (PersonId, CompanyId, etc.) don't\n    have this problem - they consistently use integers.\n    \"\"\"\n\n    def __new__(cls, value: Any) -&gt; FieldId:\n        \"\"\"Normalize value to 'field-xxx' format at construction time.\"\"\"\n        if isinstance(value, cls):\n            return value\n        if isinstance(value, int):\n            return str.__new__(cls, f\"field-{value}\")\n        if isinstance(value, str):\n            candidate = value.strip()\n            if candidate.isdigit():\n                return str.__new__(cls, f\"field-{candidate}\")\n            if _FIELD_ID_RE.match(candidate):\n                return str.__new__(cls, candidate)\n        raise ValueError(\"FieldId must be an int, digits, or 'field-&lt;digits&gt;'\")\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        _ = source_type\n        _ = handler\n\n        def validate(value: Any) -&gt; FieldId:\n            # Use __new__ which handles all normalization\n            return cls(value)\n\n        return core_schema.no_info_plain_validator_function(validate)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Normalize comparison for FieldId.\n\n        Supports comparison with:\n        - Other FieldId instances\n        - Strings (e.g., \"field-123\" or \"123\")\n        - Integers (e.g., 123)\n        \"\"\"\n        if isinstance(other, FieldId):\n            # Both are FieldId - compare string representations\n            return str.__eq__(self, other)\n        if isinstance(other, str):\n            # Compare with string - could be \"field-123\" or \"123\"\n            try:\n                other_normalized = FieldId(other)\n                return str.__eq__(self, other_normalized)\n            except ValueError:\n                return False\n        if isinstance(other, int):\n            # Compare with integer\n            return str.__eq__(self, f\"field-{other}\")\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash the string representation for dict/set usage.\"\"\"\n        return str.__hash__(self)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a representation useful for debugging.\"\"\"\n        return f\"FieldId({str.__repr__(self)})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string value (e.g., 'field-123').\"\"\"\n        return str.__str__(self)\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldId.__eq__","title":"<code>__eq__(other: object) -&gt; bool</code>","text":"<p>Normalize comparison for FieldId.</p> <p>Supports comparison with: - Other FieldId instances - Strings (e.g., \"field-123\" or \"123\") - Integers (e.g., 123)</p> Source code in <code>affinity/models/types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Normalize comparison for FieldId.\n\n    Supports comparison with:\n    - Other FieldId instances\n    - Strings (e.g., \"field-123\" or \"123\")\n    - Integers (e.g., 123)\n    \"\"\"\n    if isinstance(other, FieldId):\n        # Both are FieldId - compare string representations\n        return str.__eq__(self, other)\n    if isinstance(other, str):\n        # Compare with string - could be \"field-123\" or \"123\"\n        try:\n            other_normalized = FieldId(other)\n            return str.__eq__(self, other_normalized)\n        except ValueError:\n            return False\n    if isinstance(other, int):\n        # Compare with integer\n        return str.__eq__(self, f\"field-{other}\")\n    return NotImplemented\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldId.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Hash the string representation for dict/set usage.</p> Source code in <code>affinity/models/types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash the string representation for dict/set usage.\"\"\"\n    return str.__hash__(self)\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldId.__new__","title":"<code>__new__(value: Any) -&gt; FieldId</code>","text":"<p>Normalize value to 'field-xxx' format at construction time.</p> Source code in <code>affinity/models/types.py</code> <pre><code>def __new__(cls, value: Any) -&gt; FieldId:\n    \"\"\"Normalize value to 'field-xxx' format at construction time.\"\"\"\n    if isinstance(value, cls):\n        return value\n    if isinstance(value, int):\n        return str.__new__(cls, f\"field-{value}\")\n    if isinstance(value, str):\n        candidate = value.strip()\n        if candidate.isdigit():\n            return str.__new__(cls, f\"field-{candidate}\")\n        if _FIELD_ID_RE.match(candidate):\n            return str.__new__(cls, candidate)\n    raise ValueError(\"FieldId must be an int, digits, or 'field-&lt;digits&gt;'\")\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldId.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a representation useful for debugging.</p> Source code in <code>affinity/models/types.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation useful for debugging.\"\"\"\n    return f\"FieldId({str.__repr__(self)})\"\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldId.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Return the canonical string value (e.g., 'field-123').</p> Source code in <code>affinity/models/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string value (e.g., 'field-123').\"\"\"\n    return str.__str__(self)\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldType","title":"<code>FieldType</code>","text":"<p>               Bases: <code>OpenStrEnum</code></p> <p>Field types based on their source/scope. V2 API uses these string identifiers.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class FieldType(OpenStrEnum):\n    \"\"\"\n    Field types based on their source/scope.\n    V2 API uses these string identifiers.\n    \"\"\"\n\n    ENRICHED = \"enriched\"\n    LIST = \"list\"\n    LIST_SPECIFIC = \"list-specific\"  # Alias used in some API responses\n    GLOBAL = \"global\"\n    RELATIONSHIP_INTELLIGENCE = \"relationship-intelligence\"\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldValueChangeAction","title":"<code>FieldValueChangeAction</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>Types of changes that can occur to field values.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class FieldValueChangeAction(OpenIntEnum):\n    \"\"\"Types of changes that can occur to field values.\"\"\"\n\n    CREATE = 0\n    DELETE = 1\n    UPDATE = 2\n</code></pre>"},{"location":"reference/types/#affinity.types.FieldValueType","title":"<code>FieldValueType</code>","text":"<p>               Bases: <code>OpenStrEnum</code></p> <p>Field value types (V2-first).</p> <p>V2 represents <code>valueType</code> as strings (e.g. \"dropdown-multi\", \"ranked-dropdown\", \"interaction\"). V1 represents field value types as numeric codes; numeric inputs are normalized into the closest V2 string type where possible.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class FieldValueType(OpenStrEnum):\n    \"\"\"\n    Field value types (V2-first).\n\n    V2 represents `valueType` as strings (e.g. \"dropdown-multi\", \"ranked-dropdown\", \"interaction\").\n    V1 represents field value types as numeric codes; numeric inputs are normalized into the closest\n    V2 string type where possible.\n    \"\"\"\n\n    TEXT = \"text\"\n\n    NUMBER = \"number\"\n    NUMBER_MULTI = \"number-multi\"\n\n    DATETIME = \"datetime\"  # V2 canonical (V1 docs call this \"Date\")\n\n    LOCATION = \"location\"\n    LOCATION_MULTI = \"location-multi\"\n\n    DROPDOWN = \"dropdown\"\n    DROPDOWN_MULTI = \"dropdown-multi\"\n    RANKED_DROPDOWN = \"ranked-dropdown\"\n\n    PERSON = \"person\"\n    PERSON_MULTI = \"person-multi\"\n\n    COMPANY = \"company\"  # V1 calls this \"organization\"\n    COMPANY_MULTI = \"company-multi\"\n\n    FILTERABLE_TEXT = \"filterable-text\"\n    FILTERABLE_TEXT_MULTI = \"filterable-text-multi\"\n\n    INTERACTION = \"interaction\"  # V2-only (relationship-intelligence)\n\n    @classmethod\n    def _missing_(cls, value: object) -&gt; OpenStrEnum:\n        # Normalize known V1 numeric codes to canonical V2 strings.\n        # V1 API field value types :\n        #   0 = Person, 1 = Organization, 2 = Dropdown (simple),\n        #   3 = Number, 4 = Date, 5 = Location,\n        #   6 = Text (long text block), 7 = Ranked Dropdown (with colors),\n        #   10 = Filterable Text\n        if isinstance(value, int):\n            mapping: dict[int, FieldValueType] = {\n                0: cls.PERSON,\n                1: cls.COMPANY,\n                2: cls.DROPDOWN,  # V1 \"Dropdown\" (simple, free text)\n                3: cls.NUMBER,\n                4: cls.DATETIME,\n                5: cls.LOCATION,\n                6: cls.TEXT,  # V1 \"Text\" (long text block)\n                7: cls.RANKED_DROPDOWN,  # V1 \"Ranked Dropdown\" (with colors)\n                10: cls.FILTERABLE_TEXT,\n            }\n            if value in mapping:\n                return mapping[value]\n\n            # Keep \"unknown numeric\" inputs stable by caching under the int key as well.\n            text = str(value)\n            existing = cls._value2member_map_.get(text)\n            if existing is not None:\n                existing_enum = cast(OpenStrEnum, existing)\n                cls._value2member_map_[value] = existing_enum\n                return existing_enum\n            created = super()._missing_(text)\n            cls._value2member_map_[value] = created\n            return created\n\n        if isinstance(value, str):\n            text = value.strip()\n            lowered = text.lower()\n            if lowered == \"date\":\n                return cls.DATETIME\n            if lowered in (\"organization\", \"organisation\"):\n                return cls.COMPANY\n            if lowered in (\"organization-multi\", \"organisation-multi\"):\n                return cls.COMPANY_MULTI\n            if lowered == \"filterable_text\":\n                return cls.FILTERABLE_TEXT\n\n        return super()._missing_(value)\n</code></pre>"},{"location":"reference/types/#affinity.types.InteractionType","title":"<code>InteractionType</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>Types of interactions.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class InteractionType(OpenIntEnum):\n    \"\"\"Types of interactions.\"\"\"\n\n    MEETING = 0  # Also called Event\n    CALL = 1\n    CHAT_MESSAGE = 2\n    EMAIL = 3\n</code></pre>"},{"location":"reference/types/#affinity.types.ListType","title":"<code>ListType</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>Type of entities a list can contain.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class ListType(OpenIntEnum):\n    \"\"\"Type of entities a list can contain.\"\"\"\n\n    PERSON = 0\n    COMPANY = 1\n    OPPORTUNITY = 8\n\n    # V1 compatibility alias - prefer COMPANY in new code\n    ORGANIZATION = COMPANY\n\n    @classmethod\n    def _missing_(cls, value: object) -&gt; OpenIntEnum:\n        # V2 list endpoints commonly return string types (e.g. \"company\").\n        if isinstance(value, str):\n            text = value.strip().lower()\n            if text in (\"person\", \"people\"):\n                return cls.PERSON\n            if text in (\"company\", \"organization\", \"organisation\"):\n                return cls.COMPANY\n            if text in (\"opportunity\", \"opportunities\"):\n                return cls.OPPORTUNITY\n        return super()._missing_(value)\n</code></pre>"},{"location":"reference/types/#affinity.types.NoteType","title":"<code>NoteType</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>Types of notes.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class NoteType(OpenIntEnum):\n    \"\"\"Types of notes.\"\"\"\n\n    PLAIN_TEXT = 0\n    EMAIL_DERIVED = 1  # Deprecated creation method\n    HTML = 2\n    AI_NOTETAKER = 3\n</code></pre>"},{"location":"reference/types/#affinity.types.PersonType","title":"<code>PersonType</code>","text":"<p>               Bases: <code>OpenStrEnum</code></p> <p>Types of persons in Affinity.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class PersonType(OpenStrEnum):\n    \"\"\"Types of persons in Affinity.\"\"\"\n\n    INTERNAL = \"internal\"\n    EXTERNAL = \"external\"\n    COLLABORATOR = \"collaborator\"\n</code></pre>"},{"location":"reference/types/#affinity.types.ReminderResetType","title":"<code>ReminderResetType</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>How recurring reminders get reset.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class ReminderResetType(OpenIntEnum):\n    \"\"\"How recurring reminders get reset.\"\"\"\n\n    INTERACTION = 0  # Email or meeting\n    EMAIL = 1\n    MEETING = 2\n</code></pre>"},{"location":"reference/types/#affinity.types.ReminderStatus","title":"<code>ReminderStatus</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>Current status of a reminder.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class ReminderStatus(OpenIntEnum):\n    \"\"\"Current status of a reminder.\"\"\"\n\n    COMPLETED = 0\n    ACTIVE = 1\n    OVERDUE = 2\n</code></pre>"},{"location":"reference/types/#affinity.types.ReminderType","title":"<code>ReminderType</code>","text":"<p>               Bases: <code>OpenIntEnum</code></p> <p>Types of reminders.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class ReminderType(OpenIntEnum):\n    \"\"\"Types of reminders.\"\"\"\n\n    ONE_TIME = 0\n    RECURRING = 1\n</code></pre>"},{"location":"reference/types/#affinity.types.WebhookEvent","title":"<code>WebhookEvent</code>","text":"<p>               Bases: <code>OpenStrEnum</code></p> <p>Supported webhook events (27 total).</p> <p>Events cover CRUD operations on Affinity entities:</p> <ul> <li>Lists: created, updated, deleted</li> <li>List entries: created, deleted</li> <li>Notes: created, updated, deleted</li> <li>Fields: created, updated, deleted</li> <li>Field values: created, updated, deleted</li> <li>Persons: created, updated, deleted</li> <li>Organizations (companies): created, updated, deleted, merged</li> <li>Opportunities: created, updated, deleted</li> <li>Files: created, deleted</li> <li>Reminders: created, updated, deleted</li> </ul> <p>This enum extends <code>OpenStrEnum</code> for forward compatibility - any unknown events from Affinity are preserved as strings rather than raising errors.</p> <p>See the webhooks guide for complete documentation and usage examples.</p> Source code in <code>affinity/models/types.py</code> <pre><code>class WebhookEvent(OpenStrEnum):\n    \"\"\"\n    Supported webhook events (27 total).\n\n    Events cover CRUD operations on Affinity entities:\n\n    - **Lists**: created, updated, deleted\n    - **List entries**: created, deleted\n    - **Notes**: created, updated, deleted\n    - **Fields**: created, updated, deleted\n    - **Field values**: created, updated, deleted\n    - **Persons**: created, updated, deleted\n    - **Organizations (companies)**: created, updated, deleted, merged\n    - **Opportunities**: created, updated, deleted\n    - **Files**: created, deleted\n    - **Reminders**: created, updated, deleted\n\n    This enum extends ``OpenStrEnum`` for forward compatibility - any unknown\n    events from Affinity are preserved as strings rather than raising errors.\n\n    See the webhooks guide for complete documentation and usage examples.\n    \"\"\"\n\n    LIST_CREATED = \"list.created\"\n    LIST_UPDATED = \"list.updated\"\n    LIST_DELETED = \"list.deleted\"\n    LIST_ENTRY_CREATED = \"list_entry.created\"\n    LIST_ENTRY_DELETED = \"list_entry.deleted\"\n    NOTE_CREATED = \"note.created\"\n    NOTE_UPDATED = \"note.updated\"\n    NOTE_DELETED = \"note.deleted\"\n    FIELD_CREATED = \"field.created\"\n    FIELD_UPDATED = \"field.updated\"\n    FIELD_DELETED = \"field.deleted\"\n    FIELD_VALUE_CREATED = \"field_value.created\"\n    FIELD_VALUE_UPDATED = \"field_value.updated\"\n    FIELD_VALUE_DELETED = \"field_value.deleted\"\n    PERSON_CREATED = \"person.created\"\n    PERSON_UPDATED = \"person.updated\"\n    PERSON_DELETED = \"person.deleted\"\n    ORGANIZATION_CREATED = \"organization.created\"\n    ORGANIZATION_UPDATED = \"organization.updated\"\n    ORGANIZATION_DELETED = \"organization.deleted\"\n    ORGANIZATION_MERGED = \"organization.merged\"\n    OPPORTUNITY_CREATED = \"opportunity.created\"\n    OPPORTUNITY_UPDATED = \"opportunity.updated\"\n    OPPORTUNITY_DELETED = \"opportunity.deleted\"\n    FILE_CREATED = \"file.created\"\n    FILE_DELETED = \"file.deleted\"\n    REMINDER_CREATED = \"reminder.created\"\n    REMINDER_UPDATED = \"reminder.updated\"\n    REMINDER_DELETED = \"reminder.deleted\"\n</code></pre>"},{"location":"reference/types/#affinity.types.field_id_to_v1_numeric","title":"<code>field_id_to_v1_numeric(field_id: AnyFieldId) -&gt; int</code>","text":"<p>Convert v2 FieldId into v1 numeric field_id.</p> <p>Accepts: - FieldId('field-123') -&gt; 123 Rejects: - EnrichedFieldId(...) (cannot be represented as v1 numeric id)</p> Source code in <code>affinity/models/types.py</code> <pre><code>def field_id_to_v1_numeric(field_id: AnyFieldId) -&gt; int:\n    \"\"\"\n    Convert v2 FieldId into v1 numeric field_id.\n\n    Accepts:\n    - FieldId('field-123') -&gt; 123\n    Rejects:\n    - EnrichedFieldId(...) (cannot be represented as v1 numeric id)\n    \"\"\"\n    if isinstance(field_id, EnrichedFieldId):\n        raise ValueError(\n            \"Field IDs must be 'field-&lt;digits&gt;' for v1 conversion; \"\n            \"enriched/relationship-intelligence IDs (e.g., 'affinity-data-*', \"\n            \"'source-of-introduction') are not supported.\"\n        )\n\n    match = _FIELD_ID_RE.match(str(field_id))\n    if match is None:\n        raise ValueError(\n            \"Field IDs must be 'field-&lt;digits&gt;' for v1 conversion; \"\n            \"enriched/relationship-intelligence IDs (e.g., 'affinity-data-*', \"\n            \"'source-of-introduction') are not supported.\"\n        )\n    return int(match.group(1))\n</code></pre>"},{"location":"reference/services/companies/","title":"Companies","text":"<p>Note: <code>CompanyService</code> includes two v1-only exceptions for company -&gt; people associations: <code>get_associated_person_ids(...)</code> and <code>get_associated_people(...)</code>. V2 does not expose a direct company -&gt; people relationship endpoint, so these methods use the v1 organizations API under the hood. They are documented as exceptions and may be superseded when v2 adds parity.</p>"},{"location":"reference/services/companies/#interaction-dates","title":"Interaction Dates","text":"<p>The <code>get()</code> method supports fetching interaction date summaries for a company using the <code>with_interaction_dates</code> parameter. When enabled, the returned <code>Company</code> object will have its <code>interaction_dates</code> and <code>interactions</code> fields populated with:</p> <ul> <li>Last meeting date: When the last calendar event with this company occurred</li> <li>Next meeting date: When the next scheduled calendar event is</li> <li>Last email date: When the last email exchange happened</li> <li>Last interaction date: The most recent interaction of any type</li> </ul> <pre><code>from affinity import Affinity\nfrom affinity.types import CompanyId\n\nwith Affinity(api_key=\"YOUR_API_KEY\") as client:\n    # Fetch company with interaction dates\n    company = client.companies.get(\n        CompanyId(123),\n        with_interaction_dates=True,\n        with_interaction_persons=True,  # Include person IDs for each interaction\n    )\n\n    # Access interaction data\n    if company.interaction_dates:\n        print(f\"Last meeting: {company.interaction_dates.last_event_date}\")\n        print(f\"Next meeting: {company.interaction_dates.next_event_date}\")\n        print(f\"Last email: {company.interaction_dates.last_email_date}\")\n\n    # Access team member IDs from interactions\n    if company.interactions and company.interactions.last_event:\n        person_ids = company.interactions.last_event.person_ids\n        print(f\"Last meeting attendees: {person_ids}\")\n</code></pre> <p>Service for managing companies (organizations).</p> <p>Note: Companies are called Organizations in the V1 API. This service uses V2 terminology throughout but routes to V1 for create/update/delete.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>class CompanyService:\n    \"\"\"\n    Service for managing companies (organizations).\n\n    Note: Companies are called Organizations in the V1 API. This service\n    uses V2 terminology throughout but routes to V1 for create/update/delete.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    # =========================================================================\n    # Read Operations (V2 API)\n    # =========================================================================\n\n    def list(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[Company]:\n        \"\"\"\n        Get a page of companies.\n\n        Args:\n            ids: Specific company IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n                (e.g., `F.field(\"domain\").contains(\"acme\")`)\n            limit: Maximum number of results (API default: 100)\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n        Returns:\n            Paginated response with companies\n        \"\"\"\n        if cursor is not None:\n            if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if ids:\n                params[\"ids\"] = [int(id_) for id_ in ids]\n            if field_ids:\n                params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n            if field_types:\n                params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n            if filter is not None:\n                filter_text = str(filter).strip()\n                if filter_text:\n                    params[\"filter\"] = filter_text\n            if limit:\n                params[\"limit\"] = limit\n            data = self._client.get(\"/companies\", params=params or None)\n\n        return PaginatedResponse[Company](\n            data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    def pages(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[Company]]:\n        \"\"\"\n        Iterate company pages (not items), yielding `PaginatedResponse[Company]`.\n\n        Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n        Args:\n            ids: Specific company IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            filter: V2 filter expression string or FilterExpression\n            limit: Maximum results per page\n            cursor: Cursor to resume pagination\n\n        Yields:\n            PaginatedResponse[Company] for each page\n        \"\"\"\n        other_params = (ids, field_ids, field_types, filter, limit)\n        if cursor is not None and any(p is not None for p in other_params):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = (\n            self.list(cursor=cursor)\n            if cursor is not None\n            else self.list(\n                ids=ids, field_ids=field_ids, field_types=field_types, filter=filter, limit=limit\n            )\n        )\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = self.list(cursor=next_cursor)\n\n    def all(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; Iterator[Company]:\n        \"\"\"\n        Iterate through all companies with automatic pagination.\n\n        Args:\n            ids: Specific company IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include\n            field_types: Field types to include\n            filter: V2 filter expression\n\n        Yields:\n            Company objects\n        \"\"\"\n\n        def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Company]:\n            if next_url:\n                data = self._client.get_url(next_url)\n            else:\n                return self.list(\n                    ids=ids,\n                    field_ids=field_ids,\n                    field_types=field_types,\n                    filter=filter,\n                )\n            return PaginatedResponse[Company](\n                data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n                pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n            )\n\n        return PageIterator(fetch_page)\n\n    def iter(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; Iterator[Company]:\n        \"\"\"\n        Auto-paginate all companies.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n\n    def get(\n        self,\n        company_id: CompanyId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        retries: int = 0,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Company:\n        \"\"\"\n        Get a single company by ID.\n\n        Args:\n            company_id: The company ID\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n                Set to 2-3 if calling immediately after create() to handle eventual\n                consistency lag.\n            with_interaction_dates: Include interaction date summaries (last/next\n                meeting dates, email dates).\n            with_interaction_persons: Include person IDs for each interaction.\n                Only applies when with_interaction_dates=True.\n\n        Returns:\n            Company object with requested field data. When with_interaction_dates=True,\n            the Company will have interaction_dates and interactions populated.\n\n        Raises:\n            NotFoundError: If company does not exist after all retries.\n\n        Note:\n            When combining with_interaction_dates with field_ids/field_types,\n            two API calls are made internally and the results are merged.\n        \"\"\"\n        last_error: NotFoundError | None = None\n        attempts = retries + 1  # retries=0 means 1 attempt\n        has_field_filters = field_ids is not None or field_types is not None\n\n        for attempt in range(attempts):\n            try:\n                if with_interaction_dates:\n                    # Fetch interaction data\n                    v1_params: dict[str, Any] = {\"with_interaction_dates\": True}\n                    if with_interaction_persons:\n                        v1_params[\"with_interaction_persons\"] = True\n                    interaction_data = self._client.get(\n                        f\"/organizations/{company_id}\",\n                        params=v1_params,\n                        v1=True,\n                    )\n\n                    # If field filtering is also requested, fetch filtered fields and merge\n                    if has_field_filters:\n                        v2_params: dict[str, Any] = {}\n                        if field_ids:\n                            v2_params[\"fieldIds\"] = [str(fid) for fid in field_ids]\n                        if field_types:\n                            v2_params[\"fieldTypes\"] = [ft.value for ft in field_types]\n\n                        filtered_data = self._client.get(\n                            f\"/companies/{company_id}\",\n                            params=v2_params,\n                        )\n\n                        # Merge: filtered fields + interaction data\n                        filtered_data[\"interaction_dates\"] = interaction_data.get(\n                            \"interaction_dates\"\n                        )\n                        filtered_data[\"interactions\"] = interaction_data.get(\"interactions\")\n                        return Company.model_validate(filtered_data)\n\n                    # No field filtering, return interaction data directly\n                    return Company.model_validate(interaction_data)\n\n                # Standard path - supports field filtering\n                params: dict[str, Any] = {}\n                if field_ids:\n                    params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n                if field_types:\n                    params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n                data = self._client.get(\n                    f\"/companies/{company_id}\",\n                    params=params or None,\n                )\n                return Company.model_validate(data)\n            except NotFoundError as e:\n                last_error = e\n                if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                    time.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n        # V1 fallback: If V2 returned 404, try V1 API (handles V1\u2192V2 sync delays)\n        # Skip if already using V1 path (with_interaction_dates=True)\n        if last_error is not None and not with_interaction_dates:\n            try:\n                v1_data = self._client.get(f\"/organizations/{company_id}\", v1=True)\n                return Company.model_validate(v1_data)\n            except NotFoundError:\n                pass  # V1 also failed, raise original V2 error\n\n        raise last_error  # type: ignore[misc]\n\n    def get_associated_person_ids(\n        self,\n        company_id: CompanyId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[PersonId]:\n        \"\"\"\n        Get associated person IDs for a company.\n\n        V1-only exception: V2 does not expose company -&gt; people associations.\n        Uses GET `/organizations/{id}` and returns `person_ids` if present.\n        \"\"\"\n        data = self._client.get(f\"/organizations/{company_id}\", v1=True)\n        organization = data.get(\"organization\") if isinstance(data, dict) else None\n        source = organization if isinstance(organization, dict) else data\n        person_ids = None\n        if isinstance(source, dict):\n            person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n        if not isinstance(person_ids, list):\n            return []\n\n        ids = [PersonId(int(value)) for value in person_ids if value is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    def get_associated_person_ids_batch(\n        self,\n        company_ids: Sequence[CompanyId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[CompanyId, builtins.list[PersonId]]:\n        \"\"\"\n        Get person associations for multiple companies.\n\n        Makes one V1 API call per company.\n\n        Args:\n            company_ids: Sequence of company IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping company_id -&gt; list of person_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n        \"\"\"\n        result: dict[CompanyId, builtins.list[PersonId]] = {}\n        for company_id in company_ids:\n            try:\n                result[company_id] = self.get_associated_person_ids(company_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this company\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for company {company_id}: {e}\"\n                    ) from e\n                # skip: continue without this company\n        return result\n\n    def get_associated_people(\n        self,\n        company_id: CompanyId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[Person]:\n        \"\"\"\n        Get Person objects associated with a company.\n\n        Uses V2 batch lookup for efficiency (1 API call per 100 persons\n        instead of 1 per person).\n        \"\"\"\n        person_ids = self.get_associated_person_ids(company_id, max_results=max_results)\n        if not person_ids:\n            return []\n\n        # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n        # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n        params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n        people: builtins.list[Person] = []\n        data = self._client.get(\"/persons\", params=params)  # V2 batch\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n\n        # Handle pagination if needed (&gt;100 persons)\n        # Note: max_results check is defensive - person_ids was already truncated above\n        pagination = data.get(\"pagination\", {})\n        next_url = pagination.get(\"nextUrl\")\n        while next_url and (max_results is None or len(people) &lt; max_results):\n            data = self._client.get_url(next_url)\n            for item in data.get(\"data\", []):\n                people.append(Person.model_validate(item))\n            next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n        if max_results:\n            return people[:max_results]\n        return people\n\n    def get_associated_opportunity_ids(\n        self,\n        company_id: CompanyId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[OpportunityId]:\n        \"\"\"\n        Get associated opportunity IDs for a company.\n\n        V1-only: V2 does not expose company -&gt; opportunity associations directly.\n        Uses GET `/organizations/{id}` (V1) and returns `opportunity_ids`.\n\n        Args:\n            company_id: The company ID\n            max_results: Maximum number of opportunity IDs to return\n\n        Returns:\n            List of OpportunityId values associated with this company\n        \"\"\"\n        data = self._client.get(f\"/organizations/{company_id}\", v1=True)\n        # Defensive: handle potential {\"organization\": {...}} wrapper\n        organization = data.get(\"organization\") if isinstance(data, dict) else None\n        source = organization if isinstance(organization, dict) else data\n        opp_ids = None\n        if isinstance(source, dict):\n            opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n        if not isinstance(opp_ids, list):\n            return []\n\n        ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    def get_associated_opportunity_ids_batch(\n        self,\n        company_ids: Sequence[CompanyId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[CompanyId, builtins.list[OpportunityId]]:\n        \"\"\"\n        Get opportunity associations for multiple companies.\n\n        Makes one V1 API call per company.\n\n        Args:\n            company_ids: Sequence of company IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping company_id -&gt; list of opportunity_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n        \"\"\"\n        result: dict[CompanyId, builtins.list[OpportunityId]] = {}\n        for company_id in company_ids:\n            try:\n                result[company_id] = self.get_associated_opportunity_ids(company_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this company\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for company {company_id}: {e}\"\n                    ) from e\n                # skip: continue without this company\n        return result\n\n    def get_list_entries(\n        self,\n        company_id: CompanyId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[ListEntry]:\n        \"\"\"\n        Get all list entries for a company across all lists.\n\n        Returns comprehensive field data for each list entry.\n        \"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if limit:\n                params[\"limit\"] = limit\n            data = self._client.get(\n                f\"/companies/{company_id}/list-entries\",\n                params=params or None,\n            )\n\n        return PaginatedResponse[ListEntry](\n            data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    def get_lists(\n        self,\n        company_id: CompanyId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[ListSummary]:\n        \"\"\"Get all lists that contain this company.\"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if limit:\n                params[\"limit\"] = limit\n            data = self._client.get(\n                f\"/companies/{company_id}/lists\",\n                params=params or None,\n            )\n\n        return PaginatedResponse[ListSummary](\n            data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    def get_fields(\n        self,\n        *,\n        field_types: Sequence[FieldType] | None = None,\n    ) -&gt; builtins.list[FieldMetadata]:\n        \"\"\"\n        Get metadata about company fields.\n\n        Cached for performance.\n        \"\"\"\n        params: dict[str, Any] = {}\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = self._client.get(\n            \"/companies/fields\",\n            params=params or None,\n            cache_key=(\n                \"company_fields:_all_\"\n                if field_types is None\n                else f\"company_fields:{','.join(field_types)}\"\n            ),\n            cache_ttl=300,\n        )\n\n        return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n\n    # =========================================================================\n    # Search (V1 API)\n    # =========================================================================\n\n    def search(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Company]:\n        \"\"\"\n        Search for companies by name or domain.\n\n        Uses V1 API for search functionality not available in V2.\n\n        Args:\n            term: Search term (name or domain)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Pagination token\n\n        Returns:\n            Dict with 'organizations' and 'next_page_token'\n        \"\"\"\n        params: dict[str, Any] = {\"term\": term}\n        if with_interaction_dates:\n            params[\"with_interaction_dates\"] = True\n        if with_interaction_persons:\n            params[\"with_interaction_persons\"] = True\n        if with_opportunities:\n            params[\"with_opportunities\"] = True\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = self._client.get(\"/organizations\", params=params, v1=True)\n        items = [Company.model_validate(o) for o in data.get(\"organizations\", [])]\n        return PaginatedResponse[Company](\n            data=items,\n            next_page_token=data.get(\"next_page_token\"),\n        )\n\n    def search_pages(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[Company]]:\n        \"\"\"\n        Iterate V1 company-search result pages.\n\n        Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n        Args:\n            term: Search term (name or domain)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            PaginatedResponse[Company] for each page\n        \"\"\"\n        requested_token = page_token\n        page = self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        )\n        while True:\n            yield page\n            next_token = page.next_page_token\n            if not next_token or next_token == requested_token:\n                return\n            requested_token = next_token\n            page = self.search(\n                term,\n                with_interaction_dates=with_interaction_dates,\n                with_interaction_persons=with_interaction_persons,\n                with_opportunities=with_opportunities,\n                page_size=page_size,\n                page_token=next_token,\n            )\n\n    def search_all(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; Iterator[Company]:\n        \"\"\"\n        Iterate all V1 company-search results with automatic pagination.\n\n        Args:\n            term: Search term (name or domain)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            Company objects matching the search term\n        \"\"\"\n        for page in self.search_pages(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        ):\n            yield from page.data\n\n    def resolve(\n        self,\n        *,\n        domain: str | None = None,\n        name: str | None = None,\n    ) -&gt; Company | None:\n        \"\"\"\n        Find a single company by domain or name.\n\n        This is a convenience helper that searches and returns the first exact match,\n        or None if not found. Uses V1 search internally.\n\n        Args:\n            domain: Domain to search for (e.g., \"acme.com\")\n            name: Company name to search for\n\n        Returns:\n            The matching Company, or None if not found\n\n        Raises:\n            ValueError: If neither domain nor name is provided\n\n        Note:\n            If multiple matches are found, returns the first one.\n            For disambiguation, use search() directly.\n        \"\"\"\n        if not domain and not name:\n            raise ValueError(\"Must provide either domain or name\")\n\n        term = domain or name or \"\"\n        result = self.search(term, page_size=10)\n\n        for company in result.data:\n            if domain and company.domain and company.domain.lower() == domain.lower():\n                return company\n            if name and company.name and company.name.lower() == name.lower():\n                return company\n\n        return None\n\n    # =========================================================================\n    # Write Operations (V1 API)\n    # =========================================================================\n\n    def create(self, data: CompanyCreate) -&gt; Company:\n        \"\"\"\n        Create a new company.\n\n        Args:\n            data: Company creation data\n\n        Returns:\n            Created company\n\n        Note:\n            Creates use V1 API, while reads use V2 API. Due to eventual consistency\n            between V1 and V2, a `get()` call immediately after `create()` may return\n            404 NotFoundError. If you need to read immediately after creation, either:\n            - Use the Company object returned by this method (it contains the created data)\n            - Add a short delay (100-500ms) before calling get()\n            - Implement retry logic in your application\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n        if not data.person_ids:\n            payload.pop(\"person_ids\", None)\n\n        result = self._client.post(\"/organizations\", json=payload, v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"company\")\n\n        return Company.model_validate(result)\n\n    def update(\n        self,\n        company_id: CompanyId,\n        data: CompanyUpdate,\n    ) -&gt; Company:\n        \"\"\"\n        Update an existing company.\n\n        Note: Cannot update name/domain of global companies.\n        \"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"json\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n\n        result = self._client.put(\n            f\"/organizations/{company_id}\",\n            json=payload,\n            v1=True,\n        )\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"company\")\n\n        return Company.model_validate(result)\n\n    def delete(self, company_id: CompanyId) -&gt; bool:\n        \"\"\"\n        Delete a company.\n\n        Note: Cannot delete global companies.\n        \"\"\"\n        result = self._client.delete(f\"/organizations/{company_id}\", v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"company\")\n\n        return bool(result.get(\"success\", False))\n\n    # =========================================================================\n    # Merge Operations (V2 BETA)\n    # =========================================================================\n\n    def merge(\n        self,\n        primary_id: CompanyId,\n        duplicate_id: CompanyId,\n    ) -&gt; str:\n        \"\"\"\n        Merge a duplicate company into a primary company.\n\n        Returns a task URL to check merge status.\n        \"\"\"\n        if not self._client.enable_beta_endpoints:\n            raise BetaEndpointDisabledError(\n                \"Company merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n            )\n        result = self._client.post(\n            \"/company-merges\",\n            json={\n                \"primaryCompanyId\": int(primary_id),\n                \"duplicateCompanyId\": int(duplicate_id),\n            },\n        )\n        return str(result.get(\"taskUrl\", \"\"))\n\n    def get_merge_status(self, task_id: str) -&gt; MergeTask:\n        \"\"\"Check the status of a merge operation.\"\"\"\n        data = self._client.get(f\"/tasks/company-merges/{task_id}\")\n        return MergeTask.model_validate(data)\n</code></pre> <p>Async version of CompanyService.</p> <p>Mirrors sync behavior for V2 reads, V1 writes, and V1 search helpers.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>class AsyncCompanyService:\n    \"\"\"\n    Async version of CompanyService.\n\n    Mirrors sync behavior for V2 reads, V1 writes, and V1 search helpers.\n    \"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        self._client = client\n\n    async def list(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[Company]:\n        \"\"\"\n        Get a page of companies.\n\n        Args:\n            ids: Specific company IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n                (e.g., `F.field(\"domain\").contains(\"acme\")`)\n            limit: Maximum number of results (API default: 100)\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n        Returns:\n            Paginated response with companies\n        \"\"\"\n        if cursor is not None:\n            if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = await self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if ids:\n                params[\"ids\"] = [int(id_) for id_ in ids]\n            if field_ids:\n                params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n            if field_types:\n                params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n            if filter is not None:\n                filter_text = str(filter).strip()\n                if filter_text:\n                    params[\"filter\"] = filter_text\n            if limit:\n                params[\"limit\"] = limit\n            data = await self._client.get(\"/companies\", params=params or None)\n\n        return PaginatedResponse[Company](\n            data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    async def pages(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[Company]]:\n        \"\"\"\n        Iterate company pages (not items), yielding `PaginatedResponse[Company]`.\n\n        Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n        Args:\n            ids: Specific company IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            filter: V2 filter expression string or FilterExpression\n            limit: Maximum results per page\n            cursor: Cursor to resume pagination\n\n        Yields:\n            PaginatedResponse[Company] for each page\n        \"\"\"\n        other_params = (ids, field_ids, field_types, filter, limit)\n        if cursor is not None and any(p is not None for p in other_params):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        if cursor is not None:\n            page = await self.list(cursor=cursor)\n        else:\n            page = await self.list(\n                ids=ids,\n                field_ids=field_ids,\n                field_types=field_types,\n                filter=filter,\n                limit=limit,\n            )\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = await self.list(cursor=next_cursor)\n\n    def all(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; AsyncIterator[Company]:\n        \"\"\"\n        Iterate through all companies with automatic pagination.\n\n        Args:\n            ids: Specific company IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include\n            field_types: Field types to include\n            filter: V2 filter expression\n\n        Yields:\n            Company objects\n        \"\"\"\n\n        async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Company]:\n            if next_url:\n                data = await self._client.get_url(next_url)\n                return PaginatedResponse[Company](\n                    data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n                    pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n                )\n            return await self.list(\n                ids=ids, field_ids=field_ids, field_types=field_types, filter=filter\n            )\n\n        return AsyncPageIterator(fetch_page)\n\n    def iter(\n        self,\n        *,\n        ids: Sequence[CompanyId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; AsyncIterator[Company]:\n        \"\"\"\n        Auto-paginate all companies.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n\n    async def get(\n        self,\n        company_id: CompanyId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        retries: int = 0,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Company:\n        \"\"\"\n        Get a single company by ID.\n\n        Args:\n            company_id: The company ID\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n                Set to 2-3 if calling immediately after create() to handle eventual\n                consistency lag.\n            with_interaction_dates: Include interaction date summaries (last/next\n                meeting dates, email dates).\n            with_interaction_persons: Include person IDs for each interaction.\n                Only applies when with_interaction_dates=True.\n\n        Returns:\n            Company object with requested field data. When with_interaction_dates=True,\n            the Company will have interaction_dates and interactions populated.\n\n        Raises:\n            NotFoundError: If company does not exist after all retries.\n\n        Note:\n            When combining with_interaction_dates with field_ids/field_types,\n            two API calls are made internally and the results are merged.\n        \"\"\"\n        last_error: NotFoundError | None = None\n        attempts = retries + 1  # retries=0 means 1 attempt\n        has_field_filters = field_ids is not None or field_types is not None\n\n        for attempt in range(attempts):\n            try:\n                if with_interaction_dates:\n                    # Fetch interaction data\n                    v1_params: dict[str, Any] = {\"with_interaction_dates\": True}\n                    if with_interaction_persons:\n                        v1_params[\"with_interaction_persons\"] = True\n                    interaction_data = await self._client.get(\n                        f\"/organizations/{company_id}\",\n                        params=v1_params,\n                        v1=True,\n                    )\n\n                    # If field filtering is also requested, fetch filtered fields and merge\n                    if has_field_filters:\n                        v2_params: dict[str, Any] = {}\n                        if field_ids:\n                            v2_params[\"fieldIds\"] = [str(fid) for fid in field_ids]\n                        if field_types:\n                            v2_params[\"fieldTypes\"] = [ft.value for ft in field_types]\n\n                        filtered_data = await self._client.get(\n                            f\"/companies/{company_id}\",\n                            params=v2_params,\n                        )\n\n                        # Merge: filtered fields + interaction data\n                        filtered_data[\"interaction_dates\"] = interaction_data.get(\n                            \"interaction_dates\"\n                        )\n                        filtered_data[\"interactions\"] = interaction_data.get(\"interactions\")\n                        return Company.model_validate(filtered_data)\n\n                    # No field filtering, return interaction data directly\n                    return Company.model_validate(interaction_data)\n\n                # Standard path - supports field filtering\n                params: dict[str, Any] = {}\n                if field_ids:\n                    params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n                if field_types:\n                    params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n                data = await self._client.get(f\"/companies/{company_id}\", params=params or None)\n                return Company.model_validate(data)\n            except NotFoundError as e:\n                last_error = e\n                if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                    await asyncio.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n        # V1 fallback: If V2 returned 404, try V1 API (handles V1\u2192V2 sync delays)\n        # Skip if already using V1 path (with_interaction_dates=True)\n        if last_error is not None and not with_interaction_dates:\n            try:\n                v1_data = await self._client.get(f\"/organizations/{company_id}\", v1=True)\n                return Company.model_validate(v1_data)\n            except NotFoundError:\n                pass  # V1 also failed, raise original V2 error\n\n        raise last_error  # type: ignore[misc]\n\n    async def get_list_entries(\n        self,\n        company_id: CompanyId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[ListEntry]:\n        \"\"\"\n        Get all list entries for a company across all lists.\n\n        Returns comprehensive field data for each list entry.\n        \"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = await self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if limit:\n                params[\"limit\"] = limit\n            data = await self._client.get(\n                f\"/companies/{company_id}/list-entries\",\n                params=params or None,\n            )\n\n        return PaginatedResponse[ListEntry](\n            data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    async def get_lists(\n        self,\n        company_id: CompanyId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[ListSummary]:\n        \"\"\"Get all lists that contain this company.\"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = await self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if limit:\n                params[\"limit\"] = limit\n            data = await self._client.get(\n                f\"/companies/{company_id}/lists\",\n                params=params or None,\n            )\n\n        return PaginatedResponse[ListSummary](\n            data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    async def get_fields(\n        self,\n        *,\n        field_types: Sequence[FieldType] | None = None,\n    ) -&gt; builtins.list[FieldMetadata]:\n        \"\"\"\n        Get metadata about company fields.\n\n        Cached for performance.\n        \"\"\"\n        params: dict[str, Any] = {}\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = await self._client.get(\n            \"/companies/fields\",\n            params=params or None,\n            cache_key=(\n                \"company_fields:_all_\"\n                if field_types is None\n                else f\"company_fields:{','.join(field_types)}\"\n            ),\n            cache_ttl=300,\n        )\n\n        return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n\n    # =========================================================================\n    # Search (V1 API)\n    # =========================================================================\n\n    async def search(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Company]:\n        \"\"\"\n        Search for companies by name or domain.\n\n        Uses V1 API for search functionality not available in V2.\n        \"\"\"\n        params: dict[str, Any] = {\"term\": term}\n        if with_interaction_dates:\n            params[\"with_interaction_dates\"] = True\n        if with_interaction_persons:\n            params[\"with_interaction_persons\"] = True\n        if with_opportunities:\n            params[\"with_opportunities\"] = True\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = await self._client.get(\"/organizations\", params=params, v1=True)\n        items = [Company.model_validate(o) for o in data.get(\"organizations\", [])]\n        return PaginatedResponse[Company](\n            data=items,\n            next_page_token=data.get(\"next_page_token\"),\n        )\n\n    async def search_pages(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[Company]]:\n        \"\"\"\n        Iterate V1 company-search result pages.\n\n        Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n        Args:\n            term: Search term (name or domain)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            PaginatedResponse[Company] for each page\n        \"\"\"\n        requested_token = page_token\n        page = await self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        )\n        while True:\n            yield page\n            next_token = page.next_page_token\n            if not next_token or next_token == requested_token:\n                return\n            requested_token = next_token\n            page = await self.search(\n                term,\n                with_interaction_dates=with_interaction_dates,\n                with_interaction_persons=with_interaction_persons,\n                with_opportunities=with_opportunities,\n                page_size=page_size,\n                page_token=next_token,\n            )\n\n    async def search_all(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; AsyncIterator[Company]:\n        \"\"\"\n        Iterate all V1 company-search results with automatic pagination.\n\n        Args:\n            term: Search term (name or domain)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            Company objects matching the search term\n        \"\"\"\n        async for page in self.search_pages(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        ):\n            for company in page.data:\n                yield company\n\n    async def resolve(\n        self,\n        *,\n        domain: str | None = None,\n        name: str | None = None,\n    ) -&gt; Company | None:\n        \"\"\"\n        Find a single company by domain or name.\n\n        This is a convenience helper that searches and returns the first exact match,\n        or None if not found. Uses V1 search internally.\n        \"\"\"\n        if not domain and not name:\n            raise ValueError(\"Must provide either domain or name\")\n\n        term = domain or name or \"\"\n        result = await self.search(term, page_size=10)\n\n        for company in result.data:\n            if domain and company.domain and company.domain.lower() == domain.lower():\n                return company\n            if name and company.name and company.name.lower() == name.lower():\n                return company\n\n        return None\n\n    async def get_associated_person_ids(\n        self,\n        company_id: CompanyId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[PersonId]:\n        \"\"\"\n        Get associated person IDs for a company.\n\n        V1-only exception: V2 does not expose company -&gt; people associations.\n        Uses GET `/organizations/{id}` and returns `person_ids` if present.\n        \"\"\"\n        data = await self._client.get(f\"/organizations/{company_id}\", v1=True)\n        organization = data.get(\"organization\") if isinstance(data, dict) else None\n        source = organization if isinstance(organization, dict) else data\n        person_ids = None\n        if isinstance(source, dict):\n            person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n        if not isinstance(person_ids, list):\n            return []\n\n        ids = [PersonId(int(value)) for value in person_ids if value is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    async def get_associated_person_ids_batch(\n        self,\n        company_ids: Sequence[CompanyId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[CompanyId, builtins.list[PersonId]]:\n        \"\"\"\n        Get person associations for multiple companies.\n\n        Makes one V1 API call per company.\n\n        Args:\n            company_ids: Sequence of company IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping company_id -&gt; list of person_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n        \"\"\"\n        result: dict[CompanyId, builtins.list[PersonId]] = {}\n        for company_id in company_ids:\n            try:\n                result[company_id] = await self.get_associated_person_ids(company_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this company\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for company {company_id}: {e}\"\n                    ) from e\n                # skip: continue without this company\n        return result\n\n    async def get_associated_people(\n        self,\n        company_id: CompanyId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[Person]:\n        \"\"\"\n        Get Person objects associated with a company.\n\n        Uses V2 batch lookup for efficiency (1 API call per 100 persons\n        instead of 1 per person).\n        \"\"\"\n        person_ids = await self.get_associated_person_ids(company_id, max_results=max_results)\n        if not person_ids:\n            return []\n\n        # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n        # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n        params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n        people: builtins.list[Person] = []\n        data = await self._client.get(\"/persons\", params=params)  # V2 batch\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n\n        # Handle pagination if needed (&gt;100 persons)\n        # Note: max_results check is defensive - person_ids was already truncated above\n        pagination = data.get(\"pagination\", {})\n        next_url = pagination.get(\"nextUrl\")\n        while next_url and (max_results is None or len(people) &lt; max_results):\n            data = await self._client.get_url(next_url)\n            for item in data.get(\"data\", []):\n                people.append(Person.model_validate(item))\n            next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n        if max_results:\n            return people[:max_results]\n        return people\n\n    async def get_associated_opportunity_ids(\n        self,\n        company_id: CompanyId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[OpportunityId]:\n        \"\"\"\n        Get associated opportunity IDs for a company.\n\n        V1-only: V2 does not expose company -&gt; opportunity associations directly.\n        Uses GET `/organizations/{id}` (V1) and returns `opportunity_ids`.\n\n        Args:\n            company_id: The company ID\n            max_results: Maximum number of opportunity IDs to return\n\n        Returns:\n            List of OpportunityId values associated with this company\n        \"\"\"\n        data = await self._client.get(f\"/organizations/{company_id}\", v1=True)\n        # Defensive: handle potential {\"organization\": {...}} wrapper\n        organization = data.get(\"organization\") if isinstance(data, dict) else None\n        source = organization if isinstance(organization, dict) else data\n        opp_ids = None\n        if isinstance(source, dict):\n            opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n        if not isinstance(opp_ids, list):\n            return []\n\n        ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    async def get_associated_opportunity_ids_batch(\n        self,\n        company_ids: Sequence[CompanyId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[CompanyId, builtins.list[OpportunityId]]:\n        \"\"\"\n        Get opportunity associations for multiple companies.\n\n        Makes one V1 API call per company.\n\n        Args:\n            company_ids: Sequence of company IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping company_id -&gt; list of opportunity_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n        \"\"\"\n        result: dict[CompanyId, builtins.list[OpportunityId]] = {}\n        for company_id in company_ids:\n            try:\n                result[company_id] = await self.get_associated_opportunity_ids(company_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this company\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for company {company_id}: {e}\"\n                    ) from e\n                # skip: continue without this company\n        return result\n\n    # =========================================================================\n    # Write Operations (V1 API)\n    # =========================================================================\n\n    async def create(self, data: CompanyCreate) -&gt; Company:\n        \"\"\"\n        Create a new company.\n\n        Uses V1 API.\n\n        Note:\n            Creates use V1 API, while reads use V2 API. Due to eventual consistency\n            between V1 and V2, a `get()` call immediately after `create()` may return\n            404 NotFoundError. If you need to read immediately after creation, either:\n            - Use the Company object returned by this method (it contains the created data)\n            - Add a short delay (100-500ms) before calling get()\n            - Implement retry logic in your application\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n        if not data.person_ids:\n            payload.pop(\"person_ids\", None)\n        result = await self._client.post(\"/organizations\", json=payload, v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"company\")\n\n        return Company.model_validate(result)\n\n    async def update(self, company_id: CompanyId, data: CompanyUpdate) -&gt; Company:\n        \"\"\"\n        Update an existing company.\n\n        Uses V1 API.\n        \"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"json\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n        result = await self._client.put(\n            f\"/organizations/{company_id}\",\n            json=payload,\n            v1=True,\n        )\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"company\")\n\n        return Company.model_validate(result)\n\n    async def delete(self, company_id: CompanyId) -&gt; bool:\n        \"\"\"\n        Delete a company.\n\n        Uses V1 API.\n        \"\"\"\n        result = await self._client.delete(f\"/organizations/{company_id}\", v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"company\")\n\n        return bool(result.get(\"success\", False))\n\n    # =========================================================================\n    # Merge Operations (V2 BETA)\n    # =========================================================================\n\n    async def merge(\n        self,\n        primary_id: CompanyId,\n        duplicate_id: CompanyId,\n    ) -&gt; str:\n        \"\"\"\n        Merge a duplicate company into a primary company.\n\n        Returns a task URL to check merge status.\n        \"\"\"\n        if not self._client.enable_beta_endpoints:\n            raise BetaEndpointDisabledError(\n                \"Company merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n            )\n        result = await self._client.post(\n            \"/company-merges\",\n            json={\n                \"primaryCompanyId\": int(primary_id),\n                \"duplicateCompanyId\": int(duplicate_id),\n            },\n        )\n        return str(result.get(\"taskUrl\", \"\"))\n\n    async def get_merge_status(self, task_id: str) -&gt; MergeTask:\n        \"\"\"Check the status of a merge operation.\"\"\"\n        data = await self._client.get(f\"/tasks/company-merges/{task_id}\")\n        return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.all","title":"<code>all(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; Iterator[Company]</code>","text":"<p>Iterate through all companies with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[CompanyId] | None</code> <p>Specific company IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression</p> <code>None</code> <p>Yields:</p> Type Description <code>Company</code> <p>Company objects</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def all(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; Iterator[Company]:\n    \"\"\"\n    Iterate through all companies with automatic pagination.\n\n    Args:\n        ids: Specific company IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include\n        field_types: Field types to include\n        filter: V2 filter expression\n\n    Yields:\n        Company objects\n    \"\"\"\n\n    def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Company]:\n        if next_url:\n            data = self._client.get_url(next_url)\n        else:\n            return self.list(\n                ids=ids,\n                field_ids=field_ids,\n                field_types=field_types,\n                filter=filter,\n            )\n        return PaginatedResponse[Company](\n            data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.create","title":"<code>create(data: CompanyCreate) -&gt; Company</code>","text":"<p>Create a new company.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CompanyCreate</code> <p>Company creation data</p> required <p>Returns:</p> Type Description <code>Company</code> <p>Created company</p> Note <p>Creates use V1 API, while reads use V2 API. Due to eventual consistency between V1 and V2, a <code>get()</code> call immediately after <code>create()</code> may return 404 NotFoundError. If you need to read immediately after creation, either: - Use the Company object returned by this method (it contains the created data) - Add a short delay (100-500ms) before calling get() - Implement retry logic in your application</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def create(self, data: CompanyCreate) -&gt; Company:\n    \"\"\"\n    Create a new company.\n\n    Args:\n        data: Company creation data\n\n    Returns:\n        Created company\n\n    Note:\n        Creates use V1 API, while reads use V2 API. Due to eventual consistency\n        between V1 and V2, a `get()` call immediately after `create()` may return\n        404 NotFoundError. If you need to read immediately after creation, either:\n        - Use the Company object returned by this method (it contains the created data)\n        - Add a short delay (100-500ms) before calling get()\n        - Implement retry logic in your application\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n    if not data.person_ids:\n        payload.pop(\"person_ids\", None)\n\n    result = self._client.post(\"/organizations\", json=payload, v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"company\")\n\n    return Company.model_validate(result)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.delete","title":"<code>delete(company_id: CompanyId) -&gt; bool</code>","text":"<p>Delete a company.</p> <p>Note: Cannot delete global companies.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def delete(self, company_id: CompanyId) -&gt; bool:\n    \"\"\"\n    Delete a company.\n\n    Note: Cannot delete global companies.\n    \"\"\"\n    result = self._client.delete(f\"/organizations/{company_id}\", v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"company\")\n\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get","title":"<code>get(company_id: CompanyId, *, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, retries: int = 0, with_interaction_dates: bool = False, with_interaction_persons: bool = False) -&gt; Company</code>","text":"<p>Get a single company by ID.</p> <p>Parameters:</p> Name Type Description Default <code>company_id</code> <code>CompanyId</code> <p>The company ID</p> required <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>retries</code> <code>int</code> <p>Number of retries on 404 NotFoundError. Default is 0 (fail fast). Set to 2-3 if calling immediately after create() to handle eventual consistency lag.</p> <code>0</code> <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date summaries (last/next meeting dates, email dates).</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include person IDs for each interaction. Only applies when with_interaction_dates=True.</p> <code>False</code> <p>Returns:</p> Type Description <code>Company</code> <p>Company object with requested field data. When with_interaction_dates=True,</p> <code>Company</code> <p>the Company will have interaction_dates and interactions populated.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If company does not exist after all retries.</p> Note <p>When combining with_interaction_dates with field_ids/field_types, two API calls are made internally and the results are merged.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get(\n    self,\n    company_id: CompanyId,\n    *,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    retries: int = 0,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n) -&gt; Company:\n    \"\"\"\n    Get a single company by ID.\n\n    Args:\n        company_id: The company ID\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n            Set to 2-3 if calling immediately after create() to handle eventual\n            consistency lag.\n        with_interaction_dates: Include interaction date summaries (last/next\n            meeting dates, email dates).\n        with_interaction_persons: Include person IDs for each interaction.\n            Only applies when with_interaction_dates=True.\n\n    Returns:\n        Company object with requested field data. When with_interaction_dates=True,\n        the Company will have interaction_dates and interactions populated.\n\n    Raises:\n        NotFoundError: If company does not exist after all retries.\n\n    Note:\n        When combining with_interaction_dates with field_ids/field_types,\n        two API calls are made internally and the results are merged.\n    \"\"\"\n    last_error: NotFoundError | None = None\n    attempts = retries + 1  # retries=0 means 1 attempt\n    has_field_filters = field_ids is not None or field_types is not None\n\n    for attempt in range(attempts):\n        try:\n            if with_interaction_dates:\n                # Fetch interaction data\n                v1_params: dict[str, Any] = {\"with_interaction_dates\": True}\n                if with_interaction_persons:\n                    v1_params[\"with_interaction_persons\"] = True\n                interaction_data = self._client.get(\n                    f\"/organizations/{company_id}\",\n                    params=v1_params,\n                    v1=True,\n                )\n\n                # If field filtering is also requested, fetch filtered fields and merge\n                if has_field_filters:\n                    v2_params: dict[str, Any] = {}\n                    if field_ids:\n                        v2_params[\"fieldIds\"] = [str(fid) for fid in field_ids]\n                    if field_types:\n                        v2_params[\"fieldTypes\"] = [ft.value for ft in field_types]\n\n                    filtered_data = self._client.get(\n                        f\"/companies/{company_id}\",\n                        params=v2_params,\n                    )\n\n                    # Merge: filtered fields + interaction data\n                    filtered_data[\"interaction_dates\"] = interaction_data.get(\n                        \"interaction_dates\"\n                    )\n                    filtered_data[\"interactions\"] = interaction_data.get(\"interactions\")\n                    return Company.model_validate(filtered_data)\n\n                # No field filtering, return interaction data directly\n                return Company.model_validate(interaction_data)\n\n            # Standard path - supports field filtering\n            params: dict[str, Any] = {}\n            if field_ids:\n                params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n            if field_types:\n                params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n            data = self._client.get(\n                f\"/companies/{company_id}\",\n                params=params or None,\n            )\n            return Company.model_validate(data)\n        except NotFoundError as e:\n            last_error = e\n            if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                time.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n    # V1 fallback: If V2 returned 404, try V1 API (handles V1\u2192V2 sync delays)\n    # Skip if already using V1 path (with_interaction_dates=True)\n    if last_error is not None and not with_interaction_dates:\n        try:\n            v1_data = self._client.get(f\"/organizations/{company_id}\", v1=True)\n            return Company.model_validate(v1_data)\n        except NotFoundError:\n            pass  # V1 also failed, raise original V2 error\n\n    raise last_error  # type: ignore[misc]\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_associated_opportunity_ids","title":"<code>get_associated_opportunity_ids(company_id: CompanyId, *, max_results: int | None = None) -&gt; builtins.list[OpportunityId]</code>","text":"<p>Get associated opportunity IDs for a company.</p> <p>V1-only: V2 does not expose company -&gt; opportunity associations directly. Uses GET <code>/organizations/{id}</code> (V1) and returns <code>opportunity_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>company_id</code> <code>CompanyId</code> <p>The company ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of opportunity IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OpportunityId]</code> <p>List of OpportunityId values associated with this company</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_associated_opportunity_ids(\n    self,\n    company_id: CompanyId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[OpportunityId]:\n    \"\"\"\n    Get associated opportunity IDs for a company.\n\n    V1-only: V2 does not expose company -&gt; opportunity associations directly.\n    Uses GET `/organizations/{id}` (V1) and returns `opportunity_ids`.\n\n    Args:\n        company_id: The company ID\n        max_results: Maximum number of opportunity IDs to return\n\n    Returns:\n        List of OpportunityId values associated with this company\n    \"\"\"\n    data = self._client.get(f\"/organizations/{company_id}\", v1=True)\n    # Defensive: handle potential {\"organization\": {...}} wrapper\n    organization = data.get(\"organization\") if isinstance(data, dict) else None\n    source = organization if isinstance(organization, dict) else data\n    opp_ids = None\n    if isinstance(source, dict):\n        opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n    if not isinstance(opp_ids, list):\n        return []\n\n    ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_associated_opportunity_ids_batch","title":"<code>get_associated_opportunity_ids_batch(company_ids: Sequence[CompanyId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[CompanyId, builtins.list[OpportunityId]]</code>","text":"<p>Get opportunity associations for multiple companies.</p> <p>Makes one V1 API call per company.</p> <p>Parameters:</p> Name Type Description Default <code>company_ids</code> <code>Sequence[CompanyId]</code> <p>Sequence of company IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[CompanyId, list[OpportunityId]]</code> <p>Dict mapping company_id -&gt; list of opportunity_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_associated_opportunity_ids_batch(\n    self,\n    company_ids: Sequence[CompanyId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[CompanyId, builtins.list[OpportunityId]]:\n    \"\"\"\n    Get opportunity associations for multiple companies.\n\n    Makes one V1 API call per company.\n\n    Args:\n        company_ids: Sequence of company IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping company_id -&gt; list of opportunity_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n    \"\"\"\n    result: dict[CompanyId, builtins.list[OpportunityId]] = {}\n    for company_id in company_ids:\n        try:\n            result[company_id] = self.get_associated_opportunity_ids(company_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this company\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for company {company_id}: {e}\"\n                ) from e\n            # skip: continue without this company\n    return result\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_associated_people","title":"<code>get_associated_people(company_id: CompanyId, *, max_results: int | None = None) -&gt; builtins.list[Person]</code>","text":"<p>Get Person objects associated with a company.</p> <p>Uses V2 batch lookup for efficiency (1 API call per 100 persons instead of 1 per person).</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_associated_people(\n    self,\n    company_id: CompanyId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[Person]:\n    \"\"\"\n    Get Person objects associated with a company.\n\n    Uses V2 batch lookup for efficiency (1 API call per 100 persons\n    instead of 1 per person).\n    \"\"\"\n    person_ids = self.get_associated_person_ids(company_id, max_results=max_results)\n    if not person_ids:\n        return []\n\n    # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n    # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n    params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n    people: builtins.list[Person] = []\n    data = self._client.get(\"/persons\", params=params)  # V2 batch\n    for item in data.get(\"data\", []):\n        people.append(Person.model_validate(item))\n\n    # Handle pagination if needed (&gt;100 persons)\n    # Note: max_results check is defensive - person_ids was already truncated above\n    pagination = data.get(\"pagination\", {})\n    next_url = pagination.get(\"nextUrl\")\n    while next_url and (max_results is None or len(people) &lt; max_results):\n        data = self._client.get_url(next_url)\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n        next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n    if max_results:\n        return people[:max_results]\n    return people\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_associated_person_ids","title":"<code>get_associated_person_ids(company_id: CompanyId, *, max_results: int | None = None) -&gt; builtins.list[PersonId]</code>","text":"<p>Get associated person IDs for a company.</p> <p>V1-only exception: V2 does not expose company -&gt; people associations. Uses GET <code>/organizations/{id}</code> and returns <code>person_ids</code> if present.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_associated_person_ids(\n    self,\n    company_id: CompanyId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[PersonId]:\n    \"\"\"\n    Get associated person IDs for a company.\n\n    V1-only exception: V2 does not expose company -&gt; people associations.\n    Uses GET `/organizations/{id}` and returns `person_ids` if present.\n    \"\"\"\n    data = self._client.get(f\"/organizations/{company_id}\", v1=True)\n    organization = data.get(\"organization\") if isinstance(data, dict) else None\n    source = organization if isinstance(organization, dict) else data\n    person_ids = None\n    if isinstance(source, dict):\n        person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n    if not isinstance(person_ids, list):\n        return []\n\n    ids = [PersonId(int(value)) for value in person_ids if value is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_associated_person_ids_batch","title":"<code>get_associated_person_ids_batch(company_ids: Sequence[CompanyId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[CompanyId, builtins.list[PersonId]]</code>","text":"<p>Get person associations for multiple companies.</p> <p>Makes one V1 API call per company.</p> <p>Parameters:</p> Name Type Description Default <code>company_ids</code> <code>Sequence[CompanyId]</code> <p>Sequence of company IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[CompanyId, list[PersonId]]</code> <p>Dict mapping company_id -&gt; list of person_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_associated_person_ids_batch(\n    self,\n    company_ids: Sequence[CompanyId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[CompanyId, builtins.list[PersonId]]:\n    \"\"\"\n    Get person associations for multiple companies.\n\n    Makes one V1 API call per company.\n\n    Args:\n        company_ids: Sequence of company IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping company_id -&gt; list of person_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n    \"\"\"\n    result: dict[CompanyId, builtins.list[PersonId]] = {}\n    for company_id in company_ids:\n        try:\n            result[company_id] = self.get_associated_person_ids(company_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this company\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for company {company_id}: {e}\"\n                ) from e\n            # skip: continue without this company\n    return result\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_fields","title":"<code>get_fields(*, field_types: Sequence[FieldType] | None = None) -&gt; builtins.list[FieldMetadata]</code>","text":"<p>Get metadata about company fields.</p> <p>Cached for performance.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_fields(\n    self,\n    *,\n    field_types: Sequence[FieldType] | None = None,\n) -&gt; builtins.list[FieldMetadata]:\n    \"\"\"\n    Get metadata about company fields.\n\n    Cached for performance.\n    \"\"\"\n    params: dict[str, Any] = {}\n    if field_types:\n        params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n    data = self._client.get(\n        \"/companies/fields\",\n        params=params or None,\n        cache_key=(\n            \"company_fields:_all_\"\n            if field_types is None\n            else f\"company_fields:{','.join(field_types)}\"\n        ),\n        cache_ttl=300,\n    )\n\n    return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_list_entries","title":"<code>get_list_entries(company_id: CompanyId, *, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[ListEntry]</code>","text":"<p>Get all list entries for a company across all lists.</p> <p>Returns comprehensive field data for each list entry.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_list_entries(\n    self,\n    company_id: CompanyId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[ListEntry]:\n    \"\"\"\n    Get all list entries for a company across all lists.\n\n    Returns comprehensive field data for each list entry.\n    \"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if limit:\n            params[\"limit\"] = limit\n        data = self._client.get(\n            f\"/companies/{company_id}/list-entries\",\n            params=params or None,\n        )\n\n    return PaginatedResponse[ListEntry](\n        data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_lists","title":"<code>get_lists(company_id: CompanyId, *, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[ListSummary]</code>","text":"<p>Get all lists that contain this company.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_lists(\n    self,\n    company_id: CompanyId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[ListSummary]:\n    \"\"\"Get all lists that contain this company.\"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if limit:\n            params[\"limit\"] = limit\n        data = self._client.get(\n            f\"/companies/{company_id}/lists\",\n            params=params or None,\n        )\n\n    return PaginatedResponse[ListSummary](\n        data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.get_merge_status","title":"<code>get_merge_status(task_id: str) -&gt; MergeTask</code>","text":"<p>Check the status of a merge operation.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def get_merge_status(self, task_id: str) -&gt; MergeTask:\n    \"\"\"Check the status of a merge operation.\"\"\"\n    data = self._client.get(f\"/tasks/company-merges/{task_id}\")\n    return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.iter","title":"<code>iter(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; Iterator[Company]</code>","text":"<p>Auto-paginate all companies.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def iter(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; Iterator[Company]:\n    \"\"\"\n    Auto-paginate all companies.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.list","title":"<code>list(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[Company]</code>","text":"<p>Get a page of companies.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[CompanyId] | None</code> <p>Specific company IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string, or a FilterExpression built via <code>affinity.F</code> (e.g., <code>F.field(\"domain\").contains(\"acme\")</code>)</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results (API default: 100)</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses)</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Company]</code> <p>Paginated response with companies</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def list(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[Company]:\n    \"\"\"\n    Get a page of companies.\n\n    Args:\n        ids: Specific company IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n            (e.g., `F.field(\"domain\").contains(\"acme\")`)\n        limit: Maximum number of results (API default: 100)\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n    Returns:\n        Paginated response with companies\n    \"\"\"\n    if cursor is not None:\n        if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if ids:\n            params[\"ids\"] = [int(id_) for id_ in ids]\n        if field_ids:\n            params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n        if filter is not None:\n            filter_text = str(filter).strip()\n            if filter_text:\n                params[\"filter\"] = filter_text\n        if limit:\n            params[\"limit\"] = limit\n        data = self._client.get(\"/companies\", params=params or None)\n\n    return PaginatedResponse[Company](\n        data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.merge","title":"<code>merge(primary_id: CompanyId, duplicate_id: CompanyId) -&gt; str</code>","text":"<p>Merge a duplicate company into a primary company.</p> <p>Returns a task URL to check merge status.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def merge(\n    self,\n    primary_id: CompanyId,\n    duplicate_id: CompanyId,\n) -&gt; str:\n    \"\"\"\n    Merge a duplicate company into a primary company.\n\n    Returns a task URL to check merge status.\n    \"\"\"\n    if not self._client.enable_beta_endpoints:\n        raise BetaEndpointDisabledError(\n            \"Company merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n        )\n    result = self._client.post(\n        \"/company-merges\",\n        json={\n            \"primaryCompanyId\": int(primary_id),\n            \"duplicateCompanyId\": int(duplicate_id),\n        },\n    )\n    return str(result.get(\"taskUrl\", \"\"))\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.pages","title":"<code>pages(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; Iterator[PaginatedResponse[Company]]</code>","text":"<p>Iterate company pages (not items), yielding <code>PaginatedResponse[Company]</code>.</p> <p>Useful for ETL scripts that need checkpoint/resume via <code>page.next_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[CompanyId] | None</code> <p>Specific company IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string or FilterExpression</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination</p> <code>None</code> <p>Yields:</p> Type Description <code>PaginatedResponse[Company]</code> <p>PaginatedResponse[Company] for each page</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def pages(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; Iterator[PaginatedResponse[Company]]:\n    \"\"\"\n    Iterate company pages (not items), yielding `PaginatedResponse[Company]`.\n\n    Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n    Args:\n        ids: Specific company IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        filter: V2 filter expression string or FilterExpression\n        limit: Maximum results per page\n        cursor: Cursor to resume pagination\n\n    Yields:\n        PaginatedResponse[Company] for each page\n    \"\"\"\n    other_params = (ids, field_ids, field_types, filter, limit)\n    if cursor is not None and any(p is not None for p in other_params):\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = (\n        self.list(cursor=cursor)\n        if cursor is not None\n        else self.list(\n            ids=ids, field_ids=field_ids, field_types=field_types, filter=filter, limit=limit\n        )\n    )\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.resolve","title":"<code>resolve(*, domain: str | None = None, name: str | None = None) -&gt; Company | None</code>","text":"<p>Find a single company by domain or name.</p> <p>This is a convenience helper that searches and returns the first exact match, or None if not found. Uses V1 search internally.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str | None</code> <p>Domain to search for (e.g., \"acme.com\")</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Company name to search for</p> <code>None</code> <p>Returns:</p> Type Description <code>Company | None</code> <p>The matching Company, or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither domain nor name is provided</p> Note <p>If multiple matches are found, returns the first one. For disambiguation, use search() directly.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def resolve(\n    self,\n    *,\n    domain: str | None = None,\n    name: str | None = None,\n) -&gt; Company | None:\n    \"\"\"\n    Find a single company by domain or name.\n\n    This is a convenience helper that searches and returns the first exact match,\n    or None if not found. Uses V1 search internally.\n\n    Args:\n        domain: Domain to search for (e.g., \"acme.com\")\n        name: Company name to search for\n\n    Returns:\n        The matching Company, or None if not found\n\n    Raises:\n        ValueError: If neither domain nor name is provided\n\n    Note:\n        If multiple matches are found, returns the first one.\n        For disambiguation, use search() directly.\n    \"\"\"\n    if not domain and not name:\n        raise ValueError(\"Must provide either domain or name\")\n\n    term = domain or name or \"\"\n    result = self.search(term, page_size=10)\n\n    for company in result.data:\n        if domain and company.domain and company.domain.lower() == domain.lower():\n            return company\n        if name and company.name and company.name.lower() == name.lower():\n            return company\n\n    return None\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.search","title":"<code>search(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Company]</code>","text":"<p>Search for companies by name or domain.</p> <p>Uses V1 API for search functionality not available in V2.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or domain)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Pagination token</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Company]</code> <p>Dict with 'organizations' and 'next_page_token'</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def search(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Company]:\n    \"\"\"\n    Search for companies by name or domain.\n\n    Uses V1 API for search functionality not available in V2.\n\n    Args:\n        term: Search term (name or domain)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Pagination token\n\n    Returns:\n        Dict with 'organizations' and 'next_page_token'\n    \"\"\"\n    params: dict[str, Any] = {\"term\": term}\n    if with_interaction_dates:\n        params[\"with_interaction_dates\"] = True\n    if with_interaction_persons:\n        params[\"with_interaction_persons\"] = True\n    if with_opportunities:\n        params[\"with_opportunities\"] = True\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = self._client.get(\"/organizations\", params=params, v1=True)\n    items = [Company.model_validate(o) for o in data.get(\"organizations\", [])]\n    return PaginatedResponse[Company](\n        data=items,\n        next_page_token=data.get(\"next_page_token\"),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.search_all","title":"<code>search_all(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; Iterator[Company]</code>","text":"<p>Iterate all V1 company-search results with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or domain)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>Company</code> <p>Company objects matching the search term</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def search_all(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; Iterator[Company]:\n    \"\"\"\n    Iterate all V1 company-search results with automatic pagination.\n\n    Args:\n        term: Search term (name or domain)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        Company objects matching the search term\n    \"\"\"\n    for page in self.search_pages(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    ):\n        yield from page.data\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.search_pages","title":"<code>search_pages(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; Iterator[PaginatedResponse[Company]]</code>","text":"<p>Iterate V1 company-search result pages.</p> <p>Useful for scripts that need checkpoint/resume via <code>next_page_token</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or domain)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>PaginatedResponse[Company]</code> <p>PaginatedResponse[Company] for each page</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def search_pages(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; Iterator[PaginatedResponse[Company]]:\n    \"\"\"\n    Iterate V1 company-search result pages.\n\n    Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n    Args:\n        term: Search term (name or domain)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        PaginatedResponse[Company] for each page\n    \"\"\"\n    requested_token = page_token\n    page = self.search(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    )\n    while True:\n        yield page\n        next_token = page.next_page_token\n        if not next_token or next_token == requested_token:\n            return\n        requested_token = next_token\n        page = self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=next_token,\n        )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.CompanyService.update","title":"<code>update(company_id: CompanyId, data: CompanyUpdate) -&gt; Company</code>","text":"<p>Update an existing company.</p> <p>Note: Cannot update name/domain of global companies.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def update(\n    self,\n    company_id: CompanyId,\n    data: CompanyUpdate,\n) -&gt; Company:\n    \"\"\"\n    Update an existing company.\n\n    Note: Cannot update name/domain of global companies.\n    \"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"json\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n\n    result = self._client.put(\n        f\"/organizations/{company_id}\",\n        json=payload,\n        v1=True,\n    )\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"company\")\n\n    return Company.model_validate(result)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.all","title":"<code>all(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; AsyncIterator[Company]</code>","text":"<p>Iterate through all companies with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[CompanyId] | None</code> <p>Specific company IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Company]</code> <p>Company objects</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def all(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; AsyncIterator[Company]:\n    \"\"\"\n    Iterate through all companies with automatic pagination.\n\n    Args:\n        ids: Specific company IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include\n        field_types: Field types to include\n        filter: V2 filter expression\n\n    Yields:\n        Company objects\n    \"\"\"\n\n    async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Company]:\n        if next_url:\n            data = await self._client.get_url(next_url)\n            return PaginatedResponse[Company](\n                data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n                pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n            )\n        return await self.list(\n            ids=ids, field_ids=field_ids, field_types=field_types, filter=filter\n        )\n\n    return AsyncPageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.create","title":"<code>create(data: CompanyCreate) -&gt; Company</code>  <code>async</code>","text":"<p>Create a new company.</p> <p>Uses V1 API.</p> Note <p>Creates use V1 API, while reads use V2 API. Due to eventual consistency between V1 and V2, a <code>get()</code> call immediately after <code>create()</code> may return 404 NotFoundError. If you need to read immediately after creation, either: - Use the Company object returned by this method (it contains the created data) - Add a short delay (100-500ms) before calling get() - Implement retry logic in your application</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def create(self, data: CompanyCreate) -&gt; Company:\n    \"\"\"\n    Create a new company.\n\n    Uses V1 API.\n\n    Note:\n        Creates use V1 API, while reads use V2 API. Due to eventual consistency\n        between V1 and V2, a `get()` call immediately after `create()` may return\n        404 NotFoundError. If you need to read immediately after creation, either:\n        - Use the Company object returned by this method (it contains the created data)\n        - Add a short delay (100-500ms) before calling get()\n        - Implement retry logic in your application\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n    if not data.person_ids:\n        payload.pop(\"person_ids\", None)\n    result = await self._client.post(\"/organizations\", json=payload, v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"company\")\n\n    return Company.model_validate(result)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.delete","title":"<code>delete(company_id: CompanyId) -&gt; bool</code>  <code>async</code>","text":"<p>Delete a company.</p> <p>Uses V1 API.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def delete(self, company_id: CompanyId) -&gt; bool:\n    \"\"\"\n    Delete a company.\n\n    Uses V1 API.\n    \"\"\"\n    result = await self._client.delete(f\"/organizations/{company_id}\", v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"company\")\n\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get","title":"<code>get(company_id: CompanyId, *, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, retries: int = 0, with_interaction_dates: bool = False, with_interaction_persons: bool = False) -&gt; Company</code>  <code>async</code>","text":"<p>Get a single company by ID.</p> <p>Parameters:</p> Name Type Description Default <code>company_id</code> <code>CompanyId</code> <p>The company ID</p> required <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>retries</code> <code>int</code> <p>Number of retries on 404 NotFoundError. Default is 0 (fail fast). Set to 2-3 if calling immediately after create() to handle eventual consistency lag.</p> <code>0</code> <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date summaries (last/next meeting dates, email dates).</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include person IDs for each interaction. Only applies when with_interaction_dates=True.</p> <code>False</code> <p>Returns:</p> Type Description <code>Company</code> <p>Company object with requested field data. When with_interaction_dates=True,</p> <code>Company</code> <p>the Company will have interaction_dates and interactions populated.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If company does not exist after all retries.</p> Note <p>When combining with_interaction_dates with field_ids/field_types, two API calls are made internally and the results are merged.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get(\n    self,\n    company_id: CompanyId,\n    *,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    retries: int = 0,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n) -&gt; Company:\n    \"\"\"\n    Get a single company by ID.\n\n    Args:\n        company_id: The company ID\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n            Set to 2-3 if calling immediately after create() to handle eventual\n            consistency lag.\n        with_interaction_dates: Include interaction date summaries (last/next\n            meeting dates, email dates).\n        with_interaction_persons: Include person IDs for each interaction.\n            Only applies when with_interaction_dates=True.\n\n    Returns:\n        Company object with requested field data. When with_interaction_dates=True,\n        the Company will have interaction_dates and interactions populated.\n\n    Raises:\n        NotFoundError: If company does not exist after all retries.\n\n    Note:\n        When combining with_interaction_dates with field_ids/field_types,\n        two API calls are made internally and the results are merged.\n    \"\"\"\n    last_error: NotFoundError | None = None\n    attempts = retries + 1  # retries=0 means 1 attempt\n    has_field_filters = field_ids is not None or field_types is not None\n\n    for attempt in range(attempts):\n        try:\n            if with_interaction_dates:\n                # Fetch interaction data\n                v1_params: dict[str, Any] = {\"with_interaction_dates\": True}\n                if with_interaction_persons:\n                    v1_params[\"with_interaction_persons\"] = True\n                interaction_data = await self._client.get(\n                    f\"/organizations/{company_id}\",\n                    params=v1_params,\n                    v1=True,\n                )\n\n                # If field filtering is also requested, fetch filtered fields and merge\n                if has_field_filters:\n                    v2_params: dict[str, Any] = {}\n                    if field_ids:\n                        v2_params[\"fieldIds\"] = [str(fid) for fid in field_ids]\n                    if field_types:\n                        v2_params[\"fieldTypes\"] = [ft.value for ft in field_types]\n\n                    filtered_data = await self._client.get(\n                        f\"/companies/{company_id}\",\n                        params=v2_params,\n                    )\n\n                    # Merge: filtered fields + interaction data\n                    filtered_data[\"interaction_dates\"] = interaction_data.get(\n                        \"interaction_dates\"\n                    )\n                    filtered_data[\"interactions\"] = interaction_data.get(\"interactions\")\n                    return Company.model_validate(filtered_data)\n\n                # No field filtering, return interaction data directly\n                return Company.model_validate(interaction_data)\n\n            # Standard path - supports field filtering\n            params: dict[str, Any] = {}\n            if field_ids:\n                params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n            if field_types:\n                params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n            data = await self._client.get(f\"/companies/{company_id}\", params=params or None)\n            return Company.model_validate(data)\n        except NotFoundError as e:\n            last_error = e\n            if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                await asyncio.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n    # V1 fallback: If V2 returned 404, try V1 API (handles V1\u2192V2 sync delays)\n    # Skip if already using V1 path (with_interaction_dates=True)\n    if last_error is not None and not with_interaction_dates:\n        try:\n            v1_data = await self._client.get(f\"/organizations/{company_id}\", v1=True)\n            return Company.model_validate(v1_data)\n        except NotFoundError:\n            pass  # V1 also failed, raise original V2 error\n\n    raise last_error  # type: ignore[misc]\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_associated_opportunity_ids","title":"<code>get_associated_opportunity_ids(company_id: CompanyId, *, max_results: int | None = None) -&gt; builtins.list[OpportunityId]</code>  <code>async</code>","text":"<p>Get associated opportunity IDs for a company.</p> <p>V1-only: V2 does not expose company -&gt; opportunity associations directly. Uses GET <code>/organizations/{id}</code> (V1) and returns <code>opportunity_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>company_id</code> <code>CompanyId</code> <p>The company ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of opportunity IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OpportunityId]</code> <p>List of OpportunityId values associated with this company</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_associated_opportunity_ids(\n    self,\n    company_id: CompanyId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[OpportunityId]:\n    \"\"\"\n    Get associated opportunity IDs for a company.\n\n    V1-only: V2 does not expose company -&gt; opportunity associations directly.\n    Uses GET `/organizations/{id}` (V1) and returns `opportunity_ids`.\n\n    Args:\n        company_id: The company ID\n        max_results: Maximum number of opportunity IDs to return\n\n    Returns:\n        List of OpportunityId values associated with this company\n    \"\"\"\n    data = await self._client.get(f\"/organizations/{company_id}\", v1=True)\n    # Defensive: handle potential {\"organization\": {...}} wrapper\n    organization = data.get(\"organization\") if isinstance(data, dict) else None\n    source = organization if isinstance(organization, dict) else data\n    opp_ids = None\n    if isinstance(source, dict):\n        opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n    if not isinstance(opp_ids, list):\n        return []\n\n    ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_associated_opportunity_ids_batch","title":"<code>get_associated_opportunity_ids_batch(company_ids: Sequence[CompanyId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[CompanyId, builtins.list[OpportunityId]]</code>  <code>async</code>","text":"<p>Get opportunity associations for multiple companies.</p> <p>Makes one V1 API call per company.</p> <p>Parameters:</p> Name Type Description Default <code>company_ids</code> <code>Sequence[CompanyId]</code> <p>Sequence of company IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[CompanyId, list[OpportunityId]]</code> <p>Dict mapping company_id -&gt; list of opportunity_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_associated_opportunity_ids_batch(\n    self,\n    company_ids: Sequence[CompanyId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[CompanyId, builtins.list[OpportunityId]]:\n    \"\"\"\n    Get opportunity associations for multiple companies.\n\n    Makes one V1 API call per company.\n\n    Args:\n        company_ids: Sequence of company IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping company_id -&gt; list of opportunity_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n    \"\"\"\n    result: dict[CompanyId, builtins.list[OpportunityId]] = {}\n    for company_id in company_ids:\n        try:\n            result[company_id] = await self.get_associated_opportunity_ids(company_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this company\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for company {company_id}: {e}\"\n                ) from e\n            # skip: continue without this company\n    return result\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_associated_people","title":"<code>get_associated_people(company_id: CompanyId, *, max_results: int | None = None) -&gt; builtins.list[Person]</code>  <code>async</code>","text":"<p>Get Person objects associated with a company.</p> <p>Uses V2 batch lookup for efficiency (1 API call per 100 persons instead of 1 per person).</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_associated_people(\n    self,\n    company_id: CompanyId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[Person]:\n    \"\"\"\n    Get Person objects associated with a company.\n\n    Uses V2 batch lookup for efficiency (1 API call per 100 persons\n    instead of 1 per person).\n    \"\"\"\n    person_ids = await self.get_associated_person_ids(company_id, max_results=max_results)\n    if not person_ids:\n        return []\n\n    # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n    # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n    params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n    people: builtins.list[Person] = []\n    data = await self._client.get(\"/persons\", params=params)  # V2 batch\n    for item in data.get(\"data\", []):\n        people.append(Person.model_validate(item))\n\n    # Handle pagination if needed (&gt;100 persons)\n    # Note: max_results check is defensive - person_ids was already truncated above\n    pagination = data.get(\"pagination\", {})\n    next_url = pagination.get(\"nextUrl\")\n    while next_url and (max_results is None or len(people) &lt; max_results):\n        data = await self._client.get_url(next_url)\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n        next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n    if max_results:\n        return people[:max_results]\n    return people\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_associated_person_ids","title":"<code>get_associated_person_ids(company_id: CompanyId, *, max_results: int | None = None) -&gt; builtins.list[PersonId]</code>  <code>async</code>","text":"<p>Get associated person IDs for a company.</p> <p>V1-only exception: V2 does not expose company -&gt; people associations. Uses GET <code>/organizations/{id}</code> and returns <code>person_ids</code> if present.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_associated_person_ids(\n    self,\n    company_id: CompanyId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[PersonId]:\n    \"\"\"\n    Get associated person IDs for a company.\n\n    V1-only exception: V2 does not expose company -&gt; people associations.\n    Uses GET `/organizations/{id}` and returns `person_ids` if present.\n    \"\"\"\n    data = await self._client.get(f\"/organizations/{company_id}\", v1=True)\n    organization = data.get(\"organization\") if isinstance(data, dict) else None\n    source = organization if isinstance(organization, dict) else data\n    person_ids = None\n    if isinstance(source, dict):\n        person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n    if not isinstance(person_ids, list):\n        return []\n\n    ids = [PersonId(int(value)) for value in person_ids if value is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_associated_person_ids_batch","title":"<code>get_associated_person_ids_batch(company_ids: Sequence[CompanyId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[CompanyId, builtins.list[PersonId]]</code>  <code>async</code>","text":"<p>Get person associations for multiple companies.</p> <p>Makes one V1 API call per company.</p> <p>Parameters:</p> Name Type Description Default <code>company_ids</code> <code>Sequence[CompanyId]</code> <p>Sequence of company IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[CompanyId, list[PersonId]]</code> <p>Dict mapping company_id -&gt; list of person_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_associated_person_ids_batch(\n    self,\n    company_ids: Sequence[CompanyId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[CompanyId, builtins.list[PersonId]]:\n    \"\"\"\n    Get person associations for multiple companies.\n\n    Makes one V1 API call per company.\n\n    Args:\n        company_ids: Sequence of company IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping company_id -&gt; list of person_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n    \"\"\"\n    result: dict[CompanyId, builtins.list[PersonId]] = {}\n    for company_id in company_ids:\n        try:\n            result[company_id] = await self.get_associated_person_ids(company_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this company\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for company {company_id}: {e}\"\n                ) from e\n            # skip: continue without this company\n    return result\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_fields","title":"<code>get_fields(*, field_types: Sequence[FieldType] | None = None) -&gt; builtins.list[FieldMetadata]</code>  <code>async</code>","text":"<p>Get metadata about company fields.</p> <p>Cached for performance.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_fields(\n    self,\n    *,\n    field_types: Sequence[FieldType] | None = None,\n) -&gt; builtins.list[FieldMetadata]:\n    \"\"\"\n    Get metadata about company fields.\n\n    Cached for performance.\n    \"\"\"\n    params: dict[str, Any] = {}\n    if field_types:\n        params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n    data = await self._client.get(\n        \"/companies/fields\",\n        params=params or None,\n        cache_key=(\n            \"company_fields:_all_\"\n            if field_types is None\n            else f\"company_fields:{','.join(field_types)}\"\n        ),\n        cache_ttl=300,\n    )\n\n    return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_list_entries","title":"<code>get_list_entries(company_id: CompanyId, *, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[ListEntry]</code>  <code>async</code>","text":"<p>Get all list entries for a company across all lists.</p> <p>Returns comprehensive field data for each list entry.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_list_entries(\n    self,\n    company_id: CompanyId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[ListEntry]:\n    \"\"\"\n    Get all list entries for a company across all lists.\n\n    Returns comprehensive field data for each list entry.\n    \"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = await self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if limit:\n            params[\"limit\"] = limit\n        data = await self._client.get(\n            f\"/companies/{company_id}/list-entries\",\n            params=params or None,\n        )\n\n    return PaginatedResponse[ListEntry](\n        data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_lists","title":"<code>get_lists(company_id: CompanyId, *, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[ListSummary]</code>  <code>async</code>","text":"<p>Get all lists that contain this company.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_lists(\n    self,\n    company_id: CompanyId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[ListSummary]:\n    \"\"\"Get all lists that contain this company.\"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = await self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if limit:\n            params[\"limit\"] = limit\n        data = await self._client.get(\n            f\"/companies/{company_id}/lists\",\n            params=params or None,\n        )\n\n    return PaginatedResponse[ListSummary](\n        data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.get_merge_status","title":"<code>get_merge_status(task_id: str) -&gt; MergeTask</code>  <code>async</code>","text":"<p>Check the status of a merge operation.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def get_merge_status(self, task_id: str) -&gt; MergeTask:\n    \"\"\"Check the status of a merge operation.\"\"\"\n    data = await self._client.get(f\"/tasks/company-merges/{task_id}\")\n    return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.iter","title":"<code>iter(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; AsyncIterator[Company]</code>","text":"<p>Auto-paginate all companies.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/companies.py</code> <pre><code>def iter(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; AsyncIterator[Company]:\n    \"\"\"\n    Auto-paginate all companies.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.list","title":"<code>list(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[Company]</code>  <code>async</code>","text":"<p>Get a page of companies.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[CompanyId] | None</code> <p>Specific company IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string, or a FilterExpression built via <code>affinity.F</code> (e.g., <code>F.field(\"domain\").contains(\"acme\")</code>)</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results (API default: 100)</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses)</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Company]</code> <p>Paginated response with companies</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def list(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[Company]:\n    \"\"\"\n    Get a page of companies.\n\n    Args:\n        ids: Specific company IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n            (e.g., `F.field(\"domain\").contains(\"acme\")`)\n        limit: Maximum number of results (API default: 100)\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n    Returns:\n        Paginated response with companies\n    \"\"\"\n    if cursor is not None:\n        if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = await self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if ids:\n            params[\"ids\"] = [int(id_) for id_ in ids]\n        if field_ids:\n            params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n        if filter is not None:\n            filter_text = str(filter).strip()\n            if filter_text:\n                params[\"filter\"] = filter_text\n        if limit:\n            params[\"limit\"] = limit\n        data = await self._client.get(\"/companies\", params=params or None)\n\n    return PaginatedResponse[Company](\n        data=[Company.model_validate(c) for c in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.merge","title":"<code>merge(primary_id: CompanyId, duplicate_id: CompanyId) -&gt; str</code>  <code>async</code>","text":"<p>Merge a duplicate company into a primary company.</p> <p>Returns a task URL to check merge status.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def merge(\n    self,\n    primary_id: CompanyId,\n    duplicate_id: CompanyId,\n) -&gt; str:\n    \"\"\"\n    Merge a duplicate company into a primary company.\n\n    Returns a task URL to check merge status.\n    \"\"\"\n    if not self._client.enable_beta_endpoints:\n        raise BetaEndpointDisabledError(\n            \"Company merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n        )\n    result = await self._client.post(\n        \"/company-merges\",\n        json={\n            \"primaryCompanyId\": int(primary_id),\n            \"duplicateCompanyId\": int(duplicate_id),\n        },\n    )\n    return str(result.get(\"taskUrl\", \"\"))\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.pages","title":"<code>pages(*, ids: Sequence[CompanyId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; AsyncIterator[PaginatedResponse[Company]]</code>  <code>async</code>","text":"<p>Iterate company pages (not items), yielding <code>PaginatedResponse[Company]</code>.</p> <p>Useful for ETL scripts that need checkpoint/resume via <code>page.next_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[CompanyId] | None</code> <p>Specific company IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string or FilterExpression</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[PaginatedResponse[Company]]</code> <p>PaginatedResponse[Company] for each page</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def pages(\n    self,\n    *,\n    ids: Sequence[CompanyId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[Company]]:\n    \"\"\"\n    Iterate company pages (not items), yielding `PaginatedResponse[Company]`.\n\n    Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n    Args:\n        ids: Specific company IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        filter: V2 filter expression string or FilterExpression\n        limit: Maximum results per page\n        cursor: Cursor to resume pagination\n\n    Yields:\n        PaginatedResponse[Company] for each page\n    \"\"\"\n    other_params = (ids, field_ids, field_types, filter, limit)\n    if cursor is not None and any(p is not None for p in other_params):\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    if cursor is not None:\n        page = await self.list(cursor=cursor)\n    else:\n        page = await self.list(\n            ids=ids,\n            field_ids=field_ids,\n            field_types=field_types,\n            filter=filter,\n            limit=limit,\n        )\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = await self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.resolve","title":"<code>resolve(*, domain: str | None = None, name: str | None = None) -&gt; Company | None</code>  <code>async</code>","text":"<p>Find a single company by domain or name.</p> <p>This is a convenience helper that searches and returns the first exact match, or None if not found. Uses V1 search internally.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def resolve(\n    self,\n    *,\n    domain: str | None = None,\n    name: str | None = None,\n) -&gt; Company | None:\n    \"\"\"\n    Find a single company by domain or name.\n\n    This is a convenience helper that searches and returns the first exact match,\n    or None if not found. Uses V1 search internally.\n    \"\"\"\n    if not domain and not name:\n        raise ValueError(\"Must provide either domain or name\")\n\n    term = domain or name or \"\"\n    result = await self.search(term, page_size=10)\n\n    for company in result.data:\n        if domain and company.domain and company.domain.lower() == domain.lower():\n            return company\n        if name and company.name and company.name.lower() == name.lower():\n            return company\n\n    return None\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.search","title":"<code>search(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Company]</code>  <code>async</code>","text":"<p>Search for companies by name or domain.</p> <p>Uses V1 API for search functionality not available in V2.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def search(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Company]:\n    \"\"\"\n    Search for companies by name or domain.\n\n    Uses V1 API for search functionality not available in V2.\n    \"\"\"\n    params: dict[str, Any] = {\"term\": term}\n    if with_interaction_dates:\n        params[\"with_interaction_dates\"] = True\n    if with_interaction_persons:\n        params[\"with_interaction_persons\"] = True\n    if with_opportunities:\n        params[\"with_opportunities\"] = True\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = await self._client.get(\"/organizations\", params=params, v1=True)\n    items = [Company.model_validate(o) for o in data.get(\"organizations\", [])]\n    return PaginatedResponse[Company](\n        data=items,\n        next_page_token=data.get(\"next_page_token\"),\n    )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.search_all","title":"<code>search_all(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; AsyncIterator[Company]</code>  <code>async</code>","text":"<p>Iterate all V1 company-search results with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or domain)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Company]</code> <p>Company objects matching the search term</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def search_all(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; AsyncIterator[Company]:\n    \"\"\"\n    Iterate all V1 company-search results with automatic pagination.\n\n    Args:\n        term: Search term (name or domain)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        Company objects matching the search term\n    \"\"\"\n    async for page in self.search_pages(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    ):\n        for company in page.data:\n            yield company\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.search_pages","title":"<code>search_pages(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; AsyncIterator[PaginatedResponse[Company]]</code>  <code>async</code>","text":"<p>Iterate V1 company-search result pages.</p> <p>Useful for scripts that need checkpoint/resume via <code>next_page_token</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or domain)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[PaginatedResponse[Company]]</code> <p>PaginatedResponse[Company] for each page</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def search_pages(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[Company]]:\n    \"\"\"\n    Iterate V1 company-search result pages.\n\n    Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n    Args:\n        term: Search term (name or domain)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        PaginatedResponse[Company] for each page\n    \"\"\"\n    requested_token = page_token\n    page = await self.search(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    )\n    while True:\n        yield page\n        next_token = page.next_page_token\n        if not next_token or next_token == requested_token:\n            return\n        requested_token = next_token\n        page = await self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=next_token,\n        )\n</code></pre>"},{"location":"reference/services/companies/#affinity.services.companies.AsyncCompanyService.update","title":"<code>update(company_id: CompanyId, data: CompanyUpdate) -&gt; Company</code>  <code>async</code>","text":"<p>Update an existing company.</p> <p>Uses V1 API.</p> Source code in <code>affinity/services/companies.py</code> <pre><code>async def update(self, company_id: CompanyId, data: CompanyUpdate) -&gt; Company:\n    \"\"\"\n    Update an existing company.\n\n    Uses V1 API.\n    \"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"json\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n    result = await self._client.put(\n        f\"/organizations/{company_id}\",\n        json=payload,\n        v1=True,\n    )\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"company\")\n\n    return Company.model_validate(result)\n</code></pre>"},{"location":"reference/services/lists/","title":"Lists","text":"<p>Service for managing lists.</p> <p>Lists are spreadsheet-like collections of people, companies, or opportunities.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>class ListService:\n    \"\"\"\n    Service for managing lists.\n\n    Lists are spreadsheet-like collections of people, companies, or opportunities.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n        self._resolve_cache: dict[tuple[str, ListType | None], AffinityList | None] = {}\n        self._size_cache: dict[ListId, tuple[float, int]] = {}  # (timestamp, size)\n\n    def entries(self, list_id: ListId) -&gt; ListEntryService:\n        \"\"\"\n        Get a ListEntryService for a specific list.\n\n        This is the explicit path for retrieving \"full row\" data via list entries.\n        \"\"\"\n        return ListEntryService(self._client, list_id)\n\n    # =========================================================================\n    # List Operations (V2 for read, V1 for write)\n    # =========================================================================\n\n    def list(\n        self,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[AffinityList]:\n        \"\"\"\n        Get all lists accessible to you.\n\n        Args:\n            limit: Maximum results per page.\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n\n        Returns:\n            Paginated list of lists (without field metadata)\n        \"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = self._client.get_url(cursor)\n        else:\n            if limit is not None and limit &lt;= 0:\n                raise ValueError(\"'limit' must be &gt; 0\")\n            params: dict[str, Any] = {}\n            if limit is not None:\n                params[\"limit\"] = limit\n            data = self._client.get(\"/lists\", params=params or None)\n\n        return PaginatedResponse[AffinityList](\n            data=[\n                _safe_model_validate(AffinityList, list_item) for list_item in data.get(\"data\", [])\n            ],\n            pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n        )\n\n    def pages(\n        self,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[AffinityList]]:\n        \"\"\"\n        Iterate list pages (not items), yielding `PaginatedResponse[AffinityList]`.\n\n        This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n        \"\"\"\n        if cursor is not None and limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = self.list(limit=limit) if cursor is None else self.list(cursor=cursor)\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = self.list(cursor=next_cursor)\n\n    def all(self) -&gt; Iterator[AffinityList]:\n        \"\"\"Iterate through all accessible lists.\"\"\"\n\n        def fetch_page(next_url: str | None) -&gt; PaginatedResponse[AffinityList]:\n            if next_url:\n                data = self._client.get_url(next_url)\n                return PaginatedResponse[AffinityList](\n                    data=[\n                        _safe_model_validate(AffinityList, list_item)\n                        for list_item in data.get(\"data\", [])\n                    ],\n                    pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n                )\n            return self.list()\n\n        return PageIterator(fetch_page)\n\n    def iter(self) -&gt; Iterator[AffinityList]:\n        \"\"\"\n        Auto-paginate all lists.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all()\n\n    def get(self, list_id: ListId) -&gt; AffinityList:\n        \"\"\"\n        Get a single list by ID.\n\n        Includes field metadata for the list.\n\n        Note: Uses V1 API because V2's listSize field is undocumented and\n        returns incorrect values (often 0 for non-empty lists).\n        \"\"\"\n        data = self._client.get(f\"/lists/{list_id}\", v1=True)\n        return _safe_model_validate(AffinityList, data)\n\n    def get_size(self, list_id: ListId, *, force: bool = False) -&gt; int:\n        \"\"\"\n        Get accurate list size. Uses V1 API, cached for 5 minutes.\n\n        Args:\n            list_id: The list ID.\n            force: If True, bypass cache and fetch fresh value from API.\n\n        Note: The V2 API's listSize field is unreliable (often returns 0 for\n        non-empty lists). This method uses the V1 API which returns accurate values.\n        \"\"\"\n        if not force and list_id in self._size_cache:\n            cached_at, size = self._size_cache[list_id]\n            if time.monotonic() - cached_at &lt; _SIZE_CACHE_TTL:\n                return size\n\n        lst = self.get(list_id)\n        size = lst._list_size_hint\n        self._size_cache[list_id] = (time.monotonic(), size)\n        return size\n\n    def resolve(\n        self,\n        *,\n        name: str,\n        list_type: ListType | None = None,\n    ) -&gt; AffinityList | None:\n        \"\"\"\n        Find a single list by name (optionally filtered by type).\n\n        Notes:\n        - This iterates list pages client-side (the API does not expose a list-search endpoint).\n        - Results are cached in-memory on this service instance. If you call this frequently,\n          reuse the client, or persist the resolved `ListId` in your own configuration.\n\n        If multiple matches exist, returns the first match in server-provided order.\n        \"\"\"\n        key = (name.lower(), list_type)\n        if key in self._resolve_cache:\n            return self._resolve_cache[key]\n\n        for item in self.all():\n            if item.name.lower() == name.lower() and (list_type is None or item.type == list_type):\n                self._resolve_cache[key] = item\n                return item\n\n        self._resolve_cache[key] = None\n        return None\n\n    def resolve_all(\n        self,\n        *,\n        name: str,\n        list_type: ListType | None = None,\n    ) -&gt; builtins.list[AffinityList]:\n        \"\"\"\n        Find all lists matching a name (optionally filtered by type).\n\n        Notes:\n        - This iterates list pages client-side (the API does not expose a list-search endpoint).\n        - Unlike `resolve()`, this does not cache results.\n        \"\"\"\n        matches: builtins.list[AffinityList] = []\n        name_lower = name.lower()\n        for item in self.all():\n            if item.name.lower() != name_lower:\n                continue\n            if list_type is not None and item.type != list_type:\n                continue\n            matches.append(item)\n        return matches\n\n    def create(self, data: ListCreate) -&gt; AffinityList:\n        \"\"\"\n        Create a new list.\n\n        Uses V1 API.\n        \"\"\"\n        payload = data.model_dump(mode=\"json\", exclude_none=True, exclude_unset=True)\n        if not data.additional_permissions:\n            payload.pop(\"additional_permissions\", None)\n\n        result = self._client.post(\"/lists\", json=payload, v1=True)\n\n        # Invalidate cache\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"list\")\n        self._resolve_cache.clear()\n\n        return _safe_model_validate(AffinityList, result)\n\n    # =========================================================================\n    # Field Operations\n    # =========================================================================\n\n    def get_fields(\n        self,\n        list_id: ListId,\n        *,\n        field_types: Sequence[FieldType] | None = None,\n    ) -&gt; builtins.list[FieldMetadata]:\n        \"\"\"\n        Get fields (columns) for a list.\n\n        Includes list-specific, global, enriched, and relationship intelligence fields.\n        Cached for performance.\n        \"\"\"\n        params: dict[str, Any] = {}\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = self._client.get(\n            f\"/lists/{list_id}/fields\",\n            params=params or None,\n            cache_key=f\"list_{list_id}_fields:{','.join(field_types or [])}\",\n            cache_ttl=300,\n        )\n\n        return [_safe_model_validate(FieldMetadata, f) for f in data.get(\"data\", [])]\n\n    # =========================================================================\n    # Saved View Operations\n    # =========================================================================\n\n    def get_saved_views(\n        self,\n        list_id: ListId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[SavedView]:\n        \"\"\"\n        Get saved views for a list.\n\n        Args:\n            list_id: List id for the initial request.\n            limit: Maximum results per page.\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n        \"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            cursor_list_id = _saved_views_list_id_from_cursor(cursor)\n            if cursor_list_id is not None and int(list_id) != cursor_list_id:\n                raise ValueError(\n                    f\"Cursor does not match list_id: cursor is for list {cursor_list_id}, \"\n                    f\"requested list_id is {int(list_id)}\"\n                )\n            data = self._client.get_url(cursor)\n        else:\n            if limit is not None and limit &lt;= 0:\n                raise ValueError(\"'limit' must be &gt; 0\")\n            params: dict[str, Any] = {}\n            if limit is not None:\n                params[\"limit\"] = limit\n            data = self._client.get(f\"/lists/{list_id}/saved-views\", params=params or None)\n\n        return PaginatedResponse[SavedView](\n            data=[_safe_model_validate(SavedView, v) for v in data.get(\"data\", [])],\n            pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n        )\n\n    def saved_views_pages(\n        self,\n        list_id: ListId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[SavedView]]:\n        \"\"\"Iterate saved view pages, yielding `PaginatedResponse[SavedView]`.\"\"\"\n        if cursor is not None and limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = (\n            self.get_saved_views(list_id, limit=limit)\n            if cursor is None\n            else self.get_saved_views(list_id, cursor=cursor)\n        )\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = self.get_saved_views(list_id, cursor=next_cursor)\n\n    def saved_views_all(self, list_id: ListId) -&gt; Iterator[SavedView]:\n        \"\"\"Iterate all saved views for a list.\"\"\"\n        for page in self.saved_views_pages(list_id):\n            yield from page.data\n\n    def get_saved_view(self, list_id: ListId, view_id: SavedViewId) -&gt; SavedView:\n        \"\"\"Get a single saved view.\"\"\"\n        data = self._client.get(f\"/lists/{list_id}/saved-views/{view_id}\")\n        return _safe_model_validate(SavedView, data)\n</code></pre> <p>Async list operations (TR-009).</p> Source code in <code>affinity/services/lists.py</code> <pre><code>class AsyncListService:\n    \"\"\"Async list operations (TR-009).\"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        self._client = client\n        self._resolve_cache: dict[tuple[str, ListType | None], AffinityList | None] = {}\n        self._size_cache: dict[ListId, tuple[float, int]] = {}  # (timestamp, size)\n\n    def entries(self, list_id: ListId) -&gt; AsyncListEntryService:\n        \"\"\"\n        Get an AsyncListEntryService for a specific list.\n\n        This is the explicit path for retrieving \"full row\" data via list entries.\n        \"\"\"\n        return AsyncListEntryService(self._client, list_id)\n\n    async def list(\n        self,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[AffinityList]:\n        \"\"\"\n        Get all lists accessible to you.\n\n        Args:\n            limit: Maximum results per page.\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n\n        Returns:\n            Paginated list of lists (without field metadata)\n        \"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = await self._client.get_url(cursor)\n        else:\n            if limit is not None and limit &lt;= 0:\n                raise ValueError(\"'limit' must be &gt; 0\")\n            params: dict[str, Any] = {}\n            if limit is not None:\n                params[\"limit\"] = limit\n            data = await self._client.get(\"/lists\", params=params or None)\n        return PaginatedResponse[AffinityList](\n            data=[\n                _safe_model_validate(AffinityList, list_item) for list_item in data.get(\"data\", [])\n            ],\n            pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n        )\n\n    async def pages(\n        self,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[AffinityList]]:\n        \"\"\"\n        Iterate list pages (not items), yielding `PaginatedResponse[AffinityList]`.\n\n        This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n        \"\"\"\n        if cursor is not None and limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = await self.list(limit=limit) if cursor is None else await self.list(cursor=cursor)\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = await self.list(cursor=next_cursor)\n\n    def all(self) -&gt; AsyncIterator[AffinityList]:\n        \"\"\"Iterate through all accessible lists.\"\"\"\n\n        async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[AffinityList]:\n            if next_url:\n                data = await self._client.get_url(next_url)\n                return PaginatedResponse[AffinityList](\n                    data=[\n                        _safe_model_validate(AffinityList, list_item)\n                        for list_item in data.get(\"data\", [])\n                    ],\n                    pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n                )\n            return await self.list()\n\n        return AsyncPageIterator(fetch_page)\n\n    def iter(self) -&gt; AsyncIterator[AffinityList]:\n        \"\"\"\n        Auto-paginate all lists.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all()\n\n    # =========================================================================\n    # Saved View Operations\n    # =========================================================================\n\n    async def get_saved_views(\n        self,\n        list_id: ListId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[SavedView]:\n        \"\"\"\n        Get saved views for a list.\n\n        Args:\n            list_id: List id for the initial request.\n            limit: Maximum results per page.\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n        \"\"\"\n        if cursor is not None:\n            if limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            cursor_list_id = _saved_views_list_id_from_cursor(cursor)\n            if cursor_list_id is not None and int(list_id) != cursor_list_id:\n                raise ValueError(\n                    f\"Cursor does not match list_id: cursor is for list {cursor_list_id}, \"\n                    f\"requested list_id is {int(list_id)}\"\n                )\n            data = await self._client.get_url(cursor)\n        else:\n            if limit is not None and limit &lt;= 0:\n                raise ValueError(\"'limit' must be &gt; 0\")\n            params: dict[str, Any] = {}\n            if limit is not None:\n                params[\"limit\"] = limit\n            data = await self._client.get(f\"/lists/{list_id}/saved-views\", params=params or None)\n\n        return PaginatedResponse[SavedView](\n            data=[_safe_model_validate(SavedView, v) for v in data.get(\"data\", [])],\n            pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n        )\n\n    async def saved_views_pages(\n        self,\n        list_id: ListId,\n        *,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[SavedView]]:\n        \"\"\"Iterate saved view pages, yielding `PaginatedResponse[SavedView]`.\"\"\"\n        if cursor is not None and limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = (\n            await self.get_saved_views(list_id, limit=limit)\n            if cursor is None\n            else await self.get_saved_views(list_id, cursor=cursor)\n        )\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = await self.get_saved_views(list_id, cursor=next_cursor)\n\n    async def saved_views_all(self, list_id: ListId) -&gt; AsyncIterator[SavedView]:\n        \"\"\"Iterate all saved views for a list.\"\"\"\n        async for page in self.saved_views_pages(list_id):\n            for item in page.data:\n                yield item\n\n    async def get_saved_view(self, list_id: ListId, view_id: SavedViewId) -&gt; SavedView:\n        \"\"\"Get a single saved view.\"\"\"\n        data = await self._client.get(f\"/lists/{list_id}/saved-views/{view_id}\")\n        return _safe_model_validate(SavedView, data)\n\n    async def get(self, list_id: ListId) -&gt; AffinityList:\n        \"\"\"\n        Get a single list by ID.\n\n        Includes field metadata for the list.\n\n        Note: Uses V1 API because V2's listSize field is undocumented and\n        returns incorrect values (often 0 for non-empty lists).\n        \"\"\"\n        data = await self._client.get(f\"/lists/{list_id}\", v1=True)\n        return _safe_model_validate(AffinityList, data)\n\n    async def get_size(self, list_id: ListId, *, force: bool = False) -&gt; int:\n        \"\"\"\n        Get accurate list size. Uses V1 API, cached for 5 minutes.\n\n        Args:\n            list_id: The list ID.\n            force: If True, bypass cache and fetch fresh value from API.\n\n        Note: The V2 API's listSize field is unreliable (often returns 0 for\n        non-empty lists). This method uses the V1 API which returns accurate values.\n        \"\"\"\n        if not force and list_id in self._size_cache:\n            cached_at, size = self._size_cache[list_id]\n            if time.monotonic() - cached_at &lt; _SIZE_CACHE_TTL:\n                return size\n\n        lst = await self.get(list_id)\n        size = lst._list_size_hint\n        self._size_cache[list_id] = (time.monotonic(), size)\n        return size\n\n    async def resolve(\n        self,\n        *,\n        name: str,\n        list_type: ListType | None = None,\n    ) -&gt; AffinityList | None:\n        \"\"\"\n        Find a single list by name (optionally filtered by type).\n\n        Notes:\n        - This iterates list pages client-side (the API does not expose a list-search endpoint).\n        - Results are cached in-memory on this service instance. If you call this frequently,\n          reuse the client, or persist the resolved `ListId` in your own configuration.\n\n        If multiple matches exist, returns the first match in server-provided order.\n        \"\"\"\n        key = (name.lower(), list_type)\n        if key in self._resolve_cache:\n            return self._resolve_cache[key]\n\n        async for item in self.all():\n            if item.name.lower() == name.lower() and (list_type is None or item.type == list_type):\n                self._resolve_cache[key] = item\n                return item\n\n        self._resolve_cache[key] = None\n        return None\n\n    async def resolve_all(\n        self,\n        *,\n        name: str,\n        list_type: ListType | None = None,\n    ) -&gt; builtins.list[AffinityList]:\n        \"\"\"\n        Find all lists matching a name (optionally filtered by type).\n\n        Notes:\n        - This iterates list pages client-side (the API does not expose a list-search endpoint).\n        - Unlike `resolve()`, this does not cache results.\n        \"\"\"\n        matches: builtins.list[AffinityList] = []\n        name_lower = name.lower()\n        async for item in self.all():\n            if item.name.lower() != name_lower:\n                continue\n            if list_type is not None and item.type != list_type:\n                continue\n            matches.append(item)\n        return matches\n\n    # =========================================================================\n    # Write Operations (V1 API)\n    # =========================================================================\n\n    async def create(self, data: ListCreate) -&gt; AffinityList:\n        \"\"\"\n        Create a new list.\n\n        Uses V1 API.\n        \"\"\"\n        payload = data.model_dump(mode=\"json\", exclude_none=True, exclude_unset=True)\n        if not data.additional_permissions:\n            payload.pop(\"additional_permissions\", None)\n\n        result = await self._client.post(\"/lists\", json=payload, v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"list\")\n        self._resolve_cache.clear()\n\n        return _safe_model_validate(AffinityList, result)\n\n    # =========================================================================\n    # Field Operations\n    # =========================================================================\n\n    async def get_fields(\n        self,\n        list_id: ListId,\n        *,\n        field_types: Sequence[FieldType] | None = None,\n    ) -&gt; builtins.list[FieldMetadata]:\n        \"\"\"\n        Get fields (columns) for a list.\n\n        Includes list-specific, global, enriched, and relationship intelligence fields.\n        Cached for performance.\n        \"\"\"\n        params: dict[str, Any] = {}\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = await self._client.get(\n            f\"/lists/{list_id}/fields\",\n            params=params or None,\n            cache_key=f\"list_{list_id}_fields:{','.join(field_types or [])}\",\n            cache_ttl=300,\n        )\n\n        return [_safe_model_validate(FieldMetadata, f) for f in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.all","title":"<code>all() -&gt; Iterator[AffinityList]</code>","text":"<p>Iterate through all accessible lists.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def all(self) -&gt; Iterator[AffinityList]:\n    \"\"\"Iterate through all accessible lists.\"\"\"\n\n    def fetch_page(next_url: str | None) -&gt; PaginatedResponse[AffinityList]:\n        if next_url:\n            data = self._client.get_url(next_url)\n            return PaginatedResponse[AffinityList](\n                data=[\n                    _safe_model_validate(AffinityList, list_item)\n                    for list_item in data.get(\"data\", [])\n                ],\n                pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n            )\n        return self.list()\n\n    return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.create","title":"<code>create(data: ListCreate) -&gt; AffinityList</code>","text":"<p>Create a new list.</p> <p>Uses V1 API.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def create(self, data: ListCreate) -&gt; AffinityList:\n    \"\"\"\n    Create a new list.\n\n    Uses V1 API.\n    \"\"\"\n    payload = data.model_dump(mode=\"json\", exclude_none=True, exclude_unset=True)\n    if not data.additional_permissions:\n        payload.pop(\"additional_permissions\", None)\n\n    result = self._client.post(\"/lists\", json=payload, v1=True)\n\n    # Invalidate cache\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"list\")\n    self._resolve_cache.clear()\n\n    return _safe_model_validate(AffinityList, result)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.entries","title":"<code>entries(list_id: ListId) -&gt; ListEntryService</code>","text":"<p>Get a ListEntryService for a specific list.</p> <p>This is the explicit path for retrieving \"full row\" data via list entries.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def entries(self, list_id: ListId) -&gt; ListEntryService:\n    \"\"\"\n    Get a ListEntryService for a specific list.\n\n    This is the explicit path for retrieving \"full row\" data via list entries.\n    \"\"\"\n    return ListEntryService(self._client, list_id)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.get","title":"<code>get(list_id: ListId) -&gt; AffinityList</code>","text":"<p>Get a single list by ID.</p> <p>Includes field metadata for the list.</p> <p>Note: Uses V1 API because V2's listSize field is undocumented and returns incorrect values (often 0 for non-empty lists).</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def get(self, list_id: ListId) -&gt; AffinityList:\n    \"\"\"\n    Get a single list by ID.\n\n    Includes field metadata for the list.\n\n    Note: Uses V1 API because V2's listSize field is undocumented and\n    returns incorrect values (often 0 for non-empty lists).\n    \"\"\"\n    data = self._client.get(f\"/lists/{list_id}\", v1=True)\n    return _safe_model_validate(AffinityList, data)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.get_fields","title":"<code>get_fields(list_id: ListId, *, field_types: Sequence[FieldType] | None = None) -&gt; builtins.list[FieldMetadata]</code>","text":"<p>Get fields (columns) for a list.</p> <p>Includes list-specific, global, enriched, and relationship intelligence fields. Cached for performance.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def get_fields(\n    self,\n    list_id: ListId,\n    *,\n    field_types: Sequence[FieldType] | None = None,\n) -&gt; builtins.list[FieldMetadata]:\n    \"\"\"\n    Get fields (columns) for a list.\n\n    Includes list-specific, global, enriched, and relationship intelligence fields.\n    Cached for performance.\n    \"\"\"\n    params: dict[str, Any] = {}\n    if field_types:\n        params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n    data = self._client.get(\n        f\"/lists/{list_id}/fields\",\n        params=params or None,\n        cache_key=f\"list_{list_id}_fields:{','.join(field_types or [])}\",\n        cache_ttl=300,\n    )\n\n    return [_safe_model_validate(FieldMetadata, f) for f in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.get_saved_view","title":"<code>get_saved_view(list_id: ListId, view_id: SavedViewId) -&gt; SavedView</code>","text":"<p>Get a single saved view.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def get_saved_view(self, list_id: ListId, view_id: SavedViewId) -&gt; SavedView:\n    \"\"\"Get a single saved view.\"\"\"\n    data = self._client.get(f\"/lists/{list_id}/saved-views/{view_id}\")\n    return _safe_model_validate(SavedView, data)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.get_saved_views","title":"<code>get_saved_views(list_id: ListId, *, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[SavedView]</code>","text":"<p>Get saved views for a list.</p> <p>Parameters:</p> Name Type Description Default <code>list_id</code> <code>ListId</code> <p>List id for the initial request.</p> required <code>limit</code> <code>int | None</code> <p>Maximum results per page.</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses).</p> <code>None</code> Source code in <code>affinity/services/lists.py</code> <pre><code>def get_saved_views(\n    self,\n    list_id: ListId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[SavedView]:\n    \"\"\"\n    Get saved views for a list.\n\n    Args:\n        list_id: List id for the initial request.\n        limit: Maximum results per page.\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n    \"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        cursor_list_id = _saved_views_list_id_from_cursor(cursor)\n        if cursor_list_id is not None and int(list_id) != cursor_list_id:\n            raise ValueError(\n                f\"Cursor does not match list_id: cursor is for list {cursor_list_id}, \"\n                f\"requested list_id is {int(list_id)}\"\n            )\n        data = self._client.get_url(cursor)\n    else:\n        if limit is not None and limit &lt;= 0:\n            raise ValueError(\"'limit' must be &gt; 0\")\n        params: dict[str, Any] = {}\n        if limit is not None:\n            params[\"limit\"] = limit\n        data = self._client.get(f\"/lists/{list_id}/saved-views\", params=params or None)\n\n    return PaginatedResponse[SavedView](\n        data=[_safe_model_validate(SavedView, v) for v in data.get(\"data\", [])],\n        pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.get_size","title":"<code>get_size(list_id: ListId, *, force: bool = False) -&gt; int</code>","text":"<p>Get accurate list size. Uses V1 API, cached for 5 minutes.</p> <p>Parameters:</p> Name Type Description Default <code>list_id</code> <code>ListId</code> <p>The list ID.</p> required <code>force</code> <code>bool</code> <p>If True, bypass cache and fetch fresh value from API.</p> <code>False</code> <p>Note: The V2 API's listSize field is unreliable (often returns 0 for non-empty lists). This method uses the V1 API which returns accurate values.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def get_size(self, list_id: ListId, *, force: bool = False) -&gt; int:\n    \"\"\"\n    Get accurate list size. Uses V1 API, cached for 5 minutes.\n\n    Args:\n        list_id: The list ID.\n        force: If True, bypass cache and fetch fresh value from API.\n\n    Note: The V2 API's listSize field is unreliable (often returns 0 for\n    non-empty lists). This method uses the V1 API which returns accurate values.\n    \"\"\"\n    if not force and list_id in self._size_cache:\n        cached_at, size = self._size_cache[list_id]\n        if time.monotonic() - cached_at &lt; _SIZE_CACHE_TTL:\n            return size\n\n    lst = self.get(list_id)\n    size = lst._list_size_hint\n    self._size_cache[list_id] = (time.monotonic(), size)\n    return size\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.iter","title":"<code>iter() -&gt; Iterator[AffinityList]</code>","text":"<p>Auto-paginate all lists.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def iter(self) -&gt; Iterator[AffinityList]:\n    \"\"\"\n    Auto-paginate all lists.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all()\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.list","title":"<code>list(*, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[AffinityList]</code>","text":"<p>Get all lists accessible to you.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum results per page.</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses).</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[AffinityList]</code> <p>Paginated list of lists (without field metadata)</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[AffinityList]:\n    \"\"\"\n    Get all lists accessible to you.\n\n    Args:\n        limit: Maximum results per page.\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n\n    Returns:\n        Paginated list of lists (without field metadata)\n    \"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = self._client.get_url(cursor)\n    else:\n        if limit is not None and limit &lt;= 0:\n            raise ValueError(\"'limit' must be &gt; 0\")\n        params: dict[str, Any] = {}\n        if limit is not None:\n            params[\"limit\"] = limit\n        data = self._client.get(\"/lists\", params=params or None)\n\n    return PaginatedResponse[AffinityList](\n        data=[\n            _safe_model_validate(AffinityList, list_item) for list_item in data.get(\"data\", [])\n        ],\n        pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.pages","title":"<code>pages(*, limit: int | None = None, cursor: str | None = None) -&gt; Iterator[PaginatedResponse[AffinityList]]</code>","text":"<p>Iterate list pages (not items), yielding <code>PaginatedResponse[AffinityList]</code>.</p> <p>This is useful for ETL scripts that want checkpoint/resume via <code>page.next_cursor</code>.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def pages(\n    self,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; Iterator[PaginatedResponse[AffinityList]]:\n    \"\"\"\n    Iterate list pages (not items), yielding `PaginatedResponse[AffinityList]`.\n\n    This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n    \"\"\"\n    if cursor is not None and limit is not None:\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = self.list(limit=limit) if cursor is None else self.list(cursor=cursor)\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.resolve","title":"<code>resolve(*, name: str, list_type: ListType | None = None) -&gt; AffinityList | None</code>","text":"<p>Find a single list by name (optionally filtered by type).</p> <p>Notes: - This iterates list pages client-side (the API does not expose a list-search endpoint). - Results are cached in-memory on this service instance. If you call this frequently,   reuse the client, or persist the resolved <code>ListId</code> in your own configuration.</p> <p>If multiple matches exist, returns the first match in server-provided order.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def resolve(\n    self,\n    *,\n    name: str,\n    list_type: ListType | None = None,\n) -&gt; AffinityList | None:\n    \"\"\"\n    Find a single list by name (optionally filtered by type).\n\n    Notes:\n    - This iterates list pages client-side (the API does not expose a list-search endpoint).\n    - Results are cached in-memory on this service instance. If you call this frequently,\n      reuse the client, or persist the resolved `ListId` in your own configuration.\n\n    If multiple matches exist, returns the first match in server-provided order.\n    \"\"\"\n    key = (name.lower(), list_type)\n    if key in self._resolve_cache:\n        return self._resolve_cache[key]\n\n    for item in self.all():\n        if item.name.lower() == name.lower() and (list_type is None or item.type == list_type):\n            self._resolve_cache[key] = item\n            return item\n\n    self._resolve_cache[key] = None\n    return None\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.resolve_all","title":"<code>resolve_all(*, name: str, list_type: ListType | None = None) -&gt; builtins.list[AffinityList]</code>","text":"<p>Find all lists matching a name (optionally filtered by type).</p> <p>Notes: - This iterates list pages client-side (the API does not expose a list-search endpoint). - Unlike <code>resolve()</code>, this does not cache results.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def resolve_all(\n    self,\n    *,\n    name: str,\n    list_type: ListType | None = None,\n) -&gt; builtins.list[AffinityList]:\n    \"\"\"\n    Find all lists matching a name (optionally filtered by type).\n\n    Notes:\n    - This iterates list pages client-side (the API does not expose a list-search endpoint).\n    - Unlike `resolve()`, this does not cache results.\n    \"\"\"\n    matches: builtins.list[AffinityList] = []\n    name_lower = name.lower()\n    for item in self.all():\n        if item.name.lower() != name_lower:\n            continue\n        if list_type is not None and item.type != list_type:\n            continue\n        matches.append(item)\n    return matches\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.saved_views_all","title":"<code>saved_views_all(list_id: ListId) -&gt; Iterator[SavedView]</code>","text":"<p>Iterate all saved views for a list.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def saved_views_all(self, list_id: ListId) -&gt; Iterator[SavedView]:\n    \"\"\"Iterate all saved views for a list.\"\"\"\n    for page in self.saved_views_pages(list_id):\n        yield from page.data\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.ListService.saved_views_pages","title":"<code>saved_views_pages(list_id: ListId, *, limit: int | None = None, cursor: str | None = None) -&gt; Iterator[PaginatedResponse[SavedView]]</code>","text":"<p>Iterate saved view pages, yielding <code>PaginatedResponse[SavedView]</code>.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def saved_views_pages(\n    self,\n    list_id: ListId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; Iterator[PaginatedResponse[SavedView]]:\n    \"\"\"Iterate saved view pages, yielding `PaginatedResponse[SavedView]`.\"\"\"\n    if cursor is not None and limit is not None:\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = (\n        self.get_saved_views(list_id, limit=limit)\n        if cursor is None\n        else self.get_saved_views(list_id, cursor=cursor)\n    )\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = self.get_saved_views(list_id, cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.all","title":"<code>all() -&gt; AsyncIterator[AffinityList]</code>","text":"<p>Iterate through all accessible lists.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def all(self) -&gt; AsyncIterator[AffinityList]:\n    \"\"\"Iterate through all accessible lists.\"\"\"\n\n    async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[AffinityList]:\n        if next_url:\n            data = await self._client.get_url(next_url)\n            return PaginatedResponse[AffinityList](\n                data=[\n                    _safe_model_validate(AffinityList, list_item)\n                    for list_item in data.get(\"data\", [])\n                ],\n                pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n            )\n        return await self.list()\n\n    return AsyncPageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.create","title":"<code>create(data: ListCreate) -&gt; AffinityList</code>  <code>async</code>","text":"<p>Create a new list.</p> <p>Uses V1 API.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def create(self, data: ListCreate) -&gt; AffinityList:\n    \"\"\"\n    Create a new list.\n\n    Uses V1 API.\n    \"\"\"\n    payload = data.model_dump(mode=\"json\", exclude_none=True, exclude_unset=True)\n    if not data.additional_permissions:\n        payload.pop(\"additional_permissions\", None)\n\n    result = await self._client.post(\"/lists\", json=payload, v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"list\")\n    self._resolve_cache.clear()\n\n    return _safe_model_validate(AffinityList, result)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.entries","title":"<code>entries(list_id: ListId) -&gt; AsyncListEntryService</code>","text":"<p>Get an AsyncListEntryService for a specific list.</p> <p>This is the explicit path for retrieving \"full row\" data via list entries.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def entries(self, list_id: ListId) -&gt; AsyncListEntryService:\n    \"\"\"\n    Get an AsyncListEntryService for a specific list.\n\n    This is the explicit path for retrieving \"full row\" data via list entries.\n    \"\"\"\n    return AsyncListEntryService(self._client, list_id)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.get","title":"<code>get(list_id: ListId) -&gt; AffinityList</code>  <code>async</code>","text":"<p>Get a single list by ID.</p> <p>Includes field metadata for the list.</p> <p>Note: Uses V1 API because V2's listSize field is undocumented and returns incorrect values (often 0 for non-empty lists).</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def get(self, list_id: ListId) -&gt; AffinityList:\n    \"\"\"\n    Get a single list by ID.\n\n    Includes field metadata for the list.\n\n    Note: Uses V1 API because V2's listSize field is undocumented and\n    returns incorrect values (often 0 for non-empty lists).\n    \"\"\"\n    data = await self._client.get(f\"/lists/{list_id}\", v1=True)\n    return _safe_model_validate(AffinityList, data)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.get_fields","title":"<code>get_fields(list_id: ListId, *, field_types: Sequence[FieldType] | None = None) -&gt; builtins.list[FieldMetadata]</code>  <code>async</code>","text":"<p>Get fields (columns) for a list.</p> <p>Includes list-specific, global, enriched, and relationship intelligence fields. Cached for performance.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def get_fields(\n    self,\n    list_id: ListId,\n    *,\n    field_types: Sequence[FieldType] | None = None,\n) -&gt; builtins.list[FieldMetadata]:\n    \"\"\"\n    Get fields (columns) for a list.\n\n    Includes list-specific, global, enriched, and relationship intelligence fields.\n    Cached for performance.\n    \"\"\"\n    params: dict[str, Any] = {}\n    if field_types:\n        params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n    data = await self._client.get(\n        f\"/lists/{list_id}/fields\",\n        params=params or None,\n        cache_key=f\"list_{list_id}_fields:{','.join(field_types or [])}\",\n        cache_ttl=300,\n    )\n\n    return [_safe_model_validate(FieldMetadata, f) for f in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.get_saved_view","title":"<code>get_saved_view(list_id: ListId, view_id: SavedViewId) -&gt; SavedView</code>  <code>async</code>","text":"<p>Get a single saved view.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def get_saved_view(self, list_id: ListId, view_id: SavedViewId) -&gt; SavedView:\n    \"\"\"Get a single saved view.\"\"\"\n    data = await self._client.get(f\"/lists/{list_id}/saved-views/{view_id}\")\n    return _safe_model_validate(SavedView, data)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.get_saved_views","title":"<code>get_saved_views(list_id: ListId, *, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[SavedView]</code>  <code>async</code>","text":"<p>Get saved views for a list.</p> <p>Parameters:</p> Name Type Description Default <code>list_id</code> <code>ListId</code> <p>List id for the initial request.</p> required <code>limit</code> <code>int | None</code> <p>Maximum results per page.</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses).</p> <code>None</code> Source code in <code>affinity/services/lists.py</code> <pre><code>async def get_saved_views(\n    self,\n    list_id: ListId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[SavedView]:\n    \"\"\"\n    Get saved views for a list.\n\n    Args:\n        list_id: List id for the initial request.\n        limit: Maximum results per page.\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n    \"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        cursor_list_id = _saved_views_list_id_from_cursor(cursor)\n        if cursor_list_id is not None and int(list_id) != cursor_list_id:\n            raise ValueError(\n                f\"Cursor does not match list_id: cursor is for list {cursor_list_id}, \"\n                f\"requested list_id is {int(list_id)}\"\n            )\n        data = await self._client.get_url(cursor)\n    else:\n        if limit is not None and limit &lt;= 0:\n            raise ValueError(\"'limit' must be &gt; 0\")\n        params: dict[str, Any] = {}\n        if limit is not None:\n            params[\"limit\"] = limit\n        data = await self._client.get(f\"/lists/{list_id}/saved-views\", params=params or None)\n\n    return PaginatedResponse[SavedView](\n        data=[_safe_model_validate(SavedView, v) for v in data.get(\"data\", [])],\n        pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.get_size","title":"<code>get_size(list_id: ListId, *, force: bool = False) -&gt; int</code>  <code>async</code>","text":"<p>Get accurate list size. Uses V1 API, cached for 5 minutes.</p> <p>Parameters:</p> Name Type Description Default <code>list_id</code> <code>ListId</code> <p>The list ID.</p> required <code>force</code> <code>bool</code> <p>If True, bypass cache and fetch fresh value from API.</p> <code>False</code> <p>Note: The V2 API's listSize field is unreliable (often returns 0 for non-empty lists). This method uses the V1 API which returns accurate values.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def get_size(self, list_id: ListId, *, force: bool = False) -&gt; int:\n    \"\"\"\n    Get accurate list size. Uses V1 API, cached for 5 minutes.\n\n    Args:\n        list_id: The list ID.\n        force: If True, bypass cache and fetch fresh value from API.\n\n    Note: The V2 API's listSize field is unreliable (often returns 0 for\n    non-empty lists). This method uses the V1 API which returns accurate values.\n    \"\"\"\n    if not force and list_id in self._size_cache:\n        cached_at, size = self._size_cache[list_id]\n        if time.monotonic() - cached_at &lt; _SIZE_CACHE_TTL:\n            return size\n\n    lst = await self.get(list_id)\n    size = lst._list_size_hint\n    self._size_cache[list_id] = (time.monotonic(), size)\n    return size\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.iter","title":"<code>iter() -&gt; AsyncIterator[AffinityList]</code>","text":"<p>Auto-paginate all lists.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/lists.py</code> <pre><code>def iter(self) -&gt; AsyncIterator[AffinityList]:\n    \"\"\"\n    Auto-paginate all lists.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all()\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.list","title":"<code>list(*, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[AffinityList]</code>  <code>async</code>","text":"<p>Get all lists accessible to you.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum results per page.</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses).</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[AffinityList]</code> <p>Paginated list of lists (without field metadata)</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def list(\n    self,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[AffinityList]:\n    \"\"\"\n    Get all lists accessible to you.\n\n    Args:\n        limit: Maximum results per page.\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses).\n\n    Returns:\n        Paginated list of lists (without field metadata)\n    \"\"\"\n    if cursor is not None:\n        if limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = await self._client.get_url(cursor)\n    else:\n        if limit is not None and limit &lt;= 0:\n            raise ValueError(\"'limit' must be &gt; 0\")\n        params: dict[str, Any] = {}\n        if limit is not None:\n            params[\"limit\"] = limit\n        data = await self._client.get(\"/lists\", params=params or None)\n    return PaginatedResponse[AffinityList](\n        data=[\n            _safe_model_validate(AffinityList, list_item) for list_item in data.get(\"data\", [])\n        ],\n        pagination=_safe_model_validate(PaginationInfo, data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.pages","title":"<code>pages(*, limit: int | None = None, cursor: str | None = None) -&gt; AsyncIterator[PaginatedResponse[AffinityList]]</code>  <code>async</code>","text":"<p>Iterate list pages (not items), yielding <code>PaginatedResponse[AffinityList]</code>.</p> <p>This is useful for ETL scripts that want checkpoint/resume via <code>page.next_cursor</code>.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def pages(\n    self,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[AffinityList]]:\n    \"\"\"\n    Iterate list pages (not items), yielding `PaginatedResponse[AffinityList]`.\n\n    This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n    \"\"\"\n    if cursor is not None and limit is not None:\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = await self.list(limit=limit) if cursor is None else await self.list(cursor=cursor)\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = await self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.resolve","title":"<code>resolve(*, name: str, list_type: ListType | None = None) -&gt; AffinityList | None</code>  <code>async</code>","text":"<p>Find a single list by name (optionally filtered by type).</p> <p>Notes: - This iterates list pages client-side (the API does not expose a list-search endpoint). - Results are cached in-memory on this service instance. If you call this frequently,   reuse the client, or persist the resolved <code>ListId</code> in your own configuration.</p> <p>If multiple matches exist, returns the first match in server-provided order.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def resolve(\n    self,\n    *,\n    name: str,\n    list_type: ListType | None = None,\n) -&gt; AffinityList | None:\n    \"\"\"\n    Find a single list by name (optionally filtered by type).\n\n    Notes:\n    - This iterates list pages client-side (the API does not expose a list-search endpoint).\n    - Results are cached in-memory on this service instance. If you call this frequently,\n      reuse the client, or persist the resolved `ListId` in your own configuration.\n\n    If multiple matches exist, returns the first match in server-provided order.\n    \"\"\"\n    key = (name.lower(), list_type)\n    if key in self._resolve_cache:\n        return self._resolve_cache[key]\n\n    async for item in self.all():\n        if item.name.lower() == name.lower() and (list_type is None or item.type == list_type):\n            self._resolve_cache[key] = item\n            return item\n\n    self._resolve_cache[key] = None\n    return None\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.resolve_all","title":"<code>resolve_all(*, name: str, list_type: ListType | None = None) -&gt; builtins.list[AffinityList]</code>  <code>async</code>","text":"<p>Find all lists matching a name (optionally filtered by type).</p> <p>Notes: - This iterates list pages client-side (the API does not expose a list-search endpoint). - Unlike <code>resolve()</code>, this does not cache results.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def resolve_all(\n    self,\n    *,\n    name: str,\n    list_type: ListType | None = None,\n) -&gt; builtins.list[AffinityList]:\n    \"\"\"\n    Find all lists matching a name (optionally filtered by type).\n\n    Notes:\n    - This iterates list pages client-side (the API does not expose a list-search endpoint).\n    - Unlike `resolve()`, this does not cache results.\n    \"\"\"\n    matches: builtins.list[AffinityList] = []\n    name_lower = name.lower()\n    async for item in self.all():\n        if item.name.lower() != name_lower:\n            continue\n        if list_type is not None and item.type != list_type:\n            continue\n        matches.append(item)\n    return matches\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.saved_views_all","title":"<code>saved_views_all(list_id: ListId) -&gt; AsyncIterator[SavedView]</code>  <code>async</code>","text":"<p>Iterate all saved views for a list.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def saved_views_all(self, list_id: ListId) -&gt; AsyncIterator[SavedView]:\n    \"\"\"Iterate all saved views for a list.\"\"\"\n    async for page in self.saved_views_pages(list_id):\n        for item in page.data:\n            yield item\n</code></pre>"},{"location":"reference/services/lists/#affinity.services.lists.AsyncListService.saved_views_pages","title":"<code>saved_views_pages(list_id: ListId, *, limit: int | None = None, cursor: str | None = None) -&gt; AsyncIterator[PaginatedResponse[SavedView]]</code>  <code>async</code>","text":"<p>Iterate saved view pages, yielding <code>PaginatedResponse[SavedView]</code>.</p> Source code in <code>affinity/services/lists.py</code> <pre><code>async def saved_views_pages(\n    self,\n    list_id: ListId,\n    *,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[SavedView]]:\n    \"\"\"Iterate saved view pages, yielding `PaginatedResponse[SavedView]`.\"\"\"\n    if cursor is not None and limit is not None:\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = (\n        await self.get_saved_views(list_id, limit=limit)\n        if cursor is None\n        else await self.get_saved_views(list_id, cursor=cursor)\n    )\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = await self.get_saved_views(list_id, cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/opportunities/","title":"Opportunities","text":"<p>Service for managing opportunities.</p> <p>Notes: - V2 opportunity endpoints may return partial representations (e.g. name and   listId only). The SDK does not perform hidden follow-up calls to \"complete\"   an opportunity. - For full opportunity row data (including list fields), use list entries   explicitly via <code>client.lists.entries(list_id)</code>.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>class OpportunityService:\n    \"\"\"\n    Service for managing opportunities.\n\n    Notes:\n    - V2 opportunity endpoints may return partial representations (e.g. name and\n      listId only). The SDK does not perform hidden follow-up calls to \"complete\"\n      an opportunity.\n    - For full opportunity row data (including list fields), use list entries\n      explicitly via `client.lists.entries(list_id)`.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    # =========================================================================\n    # Read Operations (V2 API by default)\n    # =========================================================================\n\n    def get(self, opportunity_id: OpportunityId, *, retries: int = 0) -&gt; Opportunity:\n        \"\"\"\n        Get a single opportunity by ID.\n\n        Args:\n            opportunity_id: The opportunity ID\n            retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n                Set to 2-3 if calling immediately after create() to handle V1\u2192V2\n                eventual consistency lag.\n\n        Returns:\n            The opportunity representation returned by v2 (may be partial).\n\n        Raises:\n            NotFoundError: If opportunity does not exist after all retries.\n        \"\"\"\n        last_error: NotFoundError | None = None\n        attempts = retries + 1  # retries=0 means 1 attempt\n\n        for attempt in range(attempts):\n            try:\n                data = self._client.get(f\"/opportunities/{opportunity_id}\")\n                return Opportunity.model_validate(data)\n            except NotFoundError as e:\n                last_error = e\n                if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                    time.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n        raise last_error  # type: ignore[misc]\n\n    def get_details(self, opportunity_id: OpportunityId) -&gt; Opportunity:\n        \"\"\"\n        Get a single opportunity by ID with a more complete representation.\n\n        Includes association IDs and (when present) list entries, which are not\n        always included in the default `get()` response.\n\n        See Also:\n            - :meth:`get_associated_person_ids`: Get just person IDs (single API call)\n            - :meth:`get_associated_people`: Get full Person objects\n            - :meth:`get_associated_company_ids`: Get just company IDs (single API call)\n            - :meth:`get_associated_companies`: Get full Company objects\n            - :meth:`get_associations`: Get both person and company IDs in one call\n        \"\"\"\n        # Uses the v1 endpoint because it returns a fuller payload (including\n        # association IDs and, when present, list entries).\n        data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        return Opportunity.model_validate(data)\n\n    def list(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[Opportunity]:\n        \"\"\"\n        List all opportunities.\n\n        Args:\n            ids: Specific opportunity IDs to fetch (batch lookup)\n            limit: Maximum number of results per page\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n        Returns the v2 opportunity representation (which may be partial).\n        For full opportunity row data, use list entries explicitly.\n        \"\"\"\n        if cursor is not None:\n            if ids is not None or limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if ids:\n                params[\"ids\"] = [int(id_) for id_ in ids]\n            if limit is not None:\n                params[\"limit\"] = limit\n            data = self._client.get(\"/opportunities\", params=params or None)\n\n        return PaginatedResponse[Opportunity](\n            data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    def pages(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[Opportunity]]:\n        \"\"\"\n        Iterate opportunity pages (not items), yielding `PaginatedResponse[Opportunity]`.\n\n        This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n\n        Args:\n            ids: Specific opportunity IDs to fetch (batch lookup)\n            limit: Maximum results per page\n            cursor: Cursor to resume pagination\n        \"\"\"\n        other_params = (ids, limit)\n        if cursor is not None and any(p is not None for p in other_params):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = self.list(cursor=cursor) if cursor is not None else self.list(ids=ids, limit=limit)\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = self.list(cursor=next_cursor)\n\n    def all(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n    ) -&gt; Iterator[Opportunity]:\n        \"\"\"\n        Iterate through all opportunities with automatic pagination.\n\n        Args:\n            ids: Specific opportunity IDs to fetch (batch lookup)\n        \"\"\"\n\n        def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Opportunity]:\n            if next_url:\n                data = self._client.get_url(next_url)\n                return PaginatedResponse[Opportunity](\n                    data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n                    pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n                )\n            return self.list(ids=ids)\n\n        return PageIterator(fetch_page)\n\n    def iter(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n    ) -&gt; Iterator[Opportunity]:\n        \"\"\"\n        Auto-paginate all opportunities.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all(ids=ids)\n\n    # =========================================================================\n    # Search (V1 API)\n    # =========================================================================\n\n    def search(\n        self,\n        term: str | None = None,\n        *,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Opportunity]:\n        \"\"\"\n        Search for opportunities by name.\n\n        Uses V1 API for search functionality.\n\n        Args:\n            term: Search term (matches opportunity name). If None, returns all.\n            page_size: Results per page (max 500)\n            page_token: Pagination token\n\n        Returns:\n            PaginatedResponse with opportunities and next_page_token\n        \"\"\"\n        params: dict[str, Any] = {}\n        if term:\n            params[\"term\"] = term\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = self._client.get(\"/opportunities\", params=params, v1=True)\n        items = [Opportunity.model_validate(o) for o in data.get(\"opportunities\", [])]\n        return PaginatedResponse[Opportunity](\n            data=items,\n            next_page_token=data.get(\"next_page_token\"),\n        )\n\n    def search_pages(\n        self,\n        term: str | None = None,\n        *,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[Opportunity]]:\n        \"\"\"\n        Iterate V1 opportunity-search result pages.\n\n        Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n        Args:\n            term: Search term (matches opportunity name). If None, returns all.\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            PaginatedResponse[Opportunity] for each page\n        \"\"\"\n        requested_token = page_token\n        page = self.search(term, page_size=page_size, page_token=page_token)\n        while True:\n            yield page\n            next_token = page.next_page_token\n            if not next_token or next_token == requested_token:\n                return\n            requested_token = next_token\n            page = self.search(term, page_size=page_size, page_token=next_token)\n\n    def search_all(\n        self,\n        term: str | None = None,\n        *,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; Iterator[Opportunity]:\n        \"\"\"\n        Iterate all V1 opportunity-search results with automatic pagination.\n\n        Args:\n            term: Search term (matches opportunity name). If None, returns all.\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            Each Opportunity individually\n        \"\"\"\n        for page in self.search_pages(term, page_size=page_size, page_token=page_token):\n            yield from page.data\n\n    def resolve(\n        self,\n        *,\n        name: str,\n        list_id: ListId,\n        limit: int | None = None,\n    ) -&gt; Opportunity | None:\n        \"\"\"\n        Find a single opportunity by exact name within a specific list.\n\n        Notes:\n        - Opportunities are list-scoped; a list id is required.\n        - This iterates list-entry pages client-side (no dedicated search endpoint).\n        - If multiple matches exist, returns the first match in server-provided order.\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name cannot be empty\")\n        name_lower = name.lower()\n\n        entries = ListEntryService(self._client, list_id)\n        for page in entries.pages(limit=limit):\n            for entry in page.data:\n                entity = entry.entity\n                if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                    return entity\n        return None\n\n    def resolve_all(\n        self,\n        *,\n        name: str,\n        list_id: ListId,\n        limit: int | None = None,\n    ) -&gt; builtins.list[Opportunity]:\n        \"\"\"\n        Find all opportunities matching a name within a specific list.\n\n        Notes:\n        - Opportunities are list-scoped; a list id is required.\n        - This iterates list-entry pages client-side (no dedicated search endpoint).\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name cannot be empty\")\n        name_lower = name.lower()\n        matches: builtins.list[Opportunity] = []\n\n        entries = ListEntryService(self._client, list_id)\n        for page in entries.pages(limit=limit):\n            for entry in page.data:\n                entity = entry.entity\n                if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                    matches.append(entity)\n        return matches\n\n    # =========================================================================\n    # Write Operations (V1 API)\n    # =========================================================================\n\n    def create(self, data: OpportunityCreate) -&gt; Opportunity:\n        \"\"\"\n        Create a new opportunity.\n\n        The opportunity will be added to the specified list.\n\n        Args:\n            data: Opportunity creation data including list_id and name\n\n        Returns:\n            The created opportunity\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n        if not data.person_ids:\n            payload.pop(\"person_ids\", None)\n        if not data.company_ids:\n            payload.pop(\"organization_ids\", None)\n\n        result = self._client.post(\"/opportunities\", json=payload, v1=True)\n        return Opportunity.model_validate(result)\n\n    def update(self, opportunity_id: OpportunityId, data: OpportunityUpdate) -&gt; Opportunity:\n        \"\"\"\n        Update an existing opportunity.\n\n        Note: When provided, `person_ids` and `company_ids` replace the existing\n        values. To add or remove associations safely, pass the full desired arrays.\n        \"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"json\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n\n        # Uses the v1 endpoint; its PUT semantics replace association arrays.\n        result = self._client.put(f\"/opportunities/{opportunity_id}\", json=payload, v1=True)\n        return Opportunity.model_validate(result)\n\n    def delete(self, opportunity_id: OpportunityId) -&gt; bool:\n        \"\"\"\n        Delete an opportunity.\n\n        This removes the opportunity and all associated list entries.\n\n        Args:\n            opportunity_id: The opportunity to delete\n\n        Returns:\n            True if successful\n        \"\"\"\n        result = self._client.delete(f\"/opportunities/{opportunity_id}\", v1=True)\n        return bool(result.get(\"success\", False))\n\n    # =========================================================================\n    # Association Methods (V1 API)\n    # =========================================================================\n\n    def get_associated_person_ids(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[PersonId]:\n        \"\"\"\n        Get associated person IDs for an opportunity.\n\n        V1-only: V2 does not expose opportunity -&gt; person associations.\n        Uses GET `/opportunities/{id}` (V1) and returns `person_ids`.\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of person IDs to return\n\n        Returns:\n            List of PersonId values associated with this opportunity\n\n        See Also:\n            - :meth:`get_associated_people`: Returns full Person objects\n            - :meth:`get_associations`: Get both person and company IDs in one call\n        \"\"\"\n        data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n        # for consistency with CompanyService pattern that handles \"organization\" wrapper\n        opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n        source = opportunity if isinstance(opportunity, dict) else data\n        person_ids = None\n        if isinstance(source, dict):\n            person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n        if not isinstance(person_ids, list):\n            return []\n\n        ids = [PersonId(int(pid)) for pid in person_ids if pid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    def get_associated_people(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[Person]:\n        \"\"\"\n        Get Person objects associated with an opportunity.\n\n        Uses V2 batch lookup for efficiency (1 API call per 100 persons\n        instead of 1 per person).\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of people to return\n\n        Returns:\n            List of Person objects associated with this opportunity\n        \"\"\"\n        person_ids = self.get_associated_person_ids(opportunity_id, max_results=max_results)\n        if not person_ids:\n            return []\n\n        # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n        # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n        params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n        people: builtins.list[Person] = []\n        data = self._client.get(\"/persons\", params=params)  # V2 batch\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n\n        # Handle pagination if needed (&gt;100 persons)\n        # Note: max_results check is defensive - person_ids was already truncated above\n        pagination = data.get(\"pagination\", {})\n        next_url = pagination.get(\"nextUrl\")\n        while next_url and (max_results is None or len(people) &lt; max_results):\n            data = self._client.get_url(next_url)\n            for item in data.get(\"data\", []):\n                people.append(Person.model_validate(item))\n            next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n        if max_results:\n            return people[:max_results]\n        return people\n\n    def get_associated_company_ids(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[CompanyId]:\n        \"\"\"\n        Get associated company IDs for an opportunity.\n\n        V1-only: V2 does not expose opportunity -&gt; company associations.\n        Uses GET `/opportunities/{id}` (V1) and returns `organization_ids`.\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of company IDs to return\n\n        Returns:\n            List of CompanyId values associated with this opportunity\n\n        See Also:\n            - :meth:`get_associated_companies`: Returns full Company objects\n            - :meth:`get_associations`: Get both person and company IDs in one call\n        \"\"\"\n        data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n        # for consistency with CompanyService pattern that handles \"organization\" wrapper\n        opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n        source = opportunity if isinstance(opportunity, dict) else data\n        company_ids = None\n        if isinstance(source, dict):\n            company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n        if not isinstance(company_ids, list):\n            return []\n\n        ids = [CompanyId(int(cid)) for cid in company_ids if cid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    def get_associated_companies(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[Company]:\n        \"\"\"\n        Get Company objects associated with an opportunity.\n\n        Uses V2 batch lookup for efficiency (1 API call per 100 companies\n        instead of 1 per company).\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of companies to return\n\n        Returns:\n            List of Company objects associated with this opportunity\n        \"\"\"\n        company_ids = self.get_associated_company_ids(opportunity_id, max_results=max_results)\n        if not company_ids:\n            return []\n\n        # Use V2 batch lookup: GET /companies?ids=1&amp;ids=2&amp;ids=3\n        # Note: company_ids is already truncated by get_associated_company_ids if max_results set\n        params: dict[str, Any] = {\"ids\": [int(cid) for cid in company_ids]}\n\n        companies: builtins.list[Company] = []\n        data = self._client.get(\"/companies\", params=params)  # V2 batch\n        for item in data.get(\"data\", []):\n            companies.append(Company.model_validate(item))\n\n        # Handle pagination if needed (&gt;100 companies)\n        # Note: max_results check is defensive - company_ids was already truncated above\n        pagination = data.get(\"pagination\", {})\n        next_url = pagination.get(\"nextUrl\")\n        while next_url and (max_results is None or len(companies) &lt; max_results):\n            data = self._client.get_url(next_url)\n            for item in data.get(\"data\", []):\n                companies.append(Company.model_validate(item))\n            next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n        if max_results:\n            return companies[:max_results]\n        return companies\n\n    def get_associations(\n        self,\n        opportunity_id: OpportunityId,\n    ) -&gt; OpportunityAssociations:\n        \"\"\"\n        Get both person and company associations in a single V1 call.\n\n        Use this when you need both types of associations to avoid\n        duplicate API calls from separate get_associated_*_ids() calls.\n\n        Args:\n            opportunity_id: The opportunity ID\n\n        Returns:\n            OpportunityAssociations named tuple with person_ids and company_ids\n\n        Example:\n            assoc = client.opportunities.get_associations(opp_id)\n            print(assoc.person_ids)   # IDE autocomplete works\n            print(assoc.company_ids)  # IDE autocomplete works\n        \"\"\"\n        data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n        opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n        source = opportunity if isinstance(opportunity, dict) else data\n\n        person_ids: builtins.list[PersonId] = []\n        company_ids: builtins.list[CompanyId] = []\n\n        if isinstance(source, dict):\n            raw_person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n            raw_company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n            if isinstance(raw_person_ids, list):\n                person_ids = [PersonId(int(pid)) for pid in raw_person_ids if pid is not None]\n            if isinstance(raw_company_ids, list):\n                company_ids = [CompanyId(int(cid)) for cid in raw_company_ids if cid is not None]\n\n        return OpportunityAssociations(person_ids=person_ids, company_ids=company_ids)\n\n    def get_associated_person_ids_batch(\n        self,\n        opportunity_ids: Sequence[OpportunityId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[OpportunityId, builtins.list[PersonId]]:\n        \"\"\"\n        Get person associations for multiple opportunities.\n\n        Makes one V1 API call per opportunity. Useful for iterating list entries\n        where V2 returns empty person_ids.\n\n        Args:\n            opportunity_ids: Sequence of opportunity IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping opportunity_id -&gt; list of person_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n                includes the failing opportunity_id in its context.\n\n        Example:\n            # Get all persons from an opportunity list\n            opp_ids = [entry.entity.id for entry in client.lists.entries(list_id).all()]\n            associations = client.opportunities.get_associated_person_ids_batch(opp_ids)\n            all_person_ids = set()\n            for person_ids in associations.values():\n                all_person_ids.update(person_ids)\n        \"\"\"\n        result: dict[OpportunityId, builtins.list[PersonId]] = {}\n        for opp_id in opportunity_ids:\n            try:\n                result[opp_id] = self.get_associated_person_ids(opp_id)\n            except AffinityError:\n                # Re-raise SDK errors directly - they already have good context\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this opportunity\n            except Exception as e:\n                if on_error == \"raise\":\n                    # Wrap non-SDK errors with context, preserving chain\n                    raise AffinityError(\n                        f\"Failed to get associations for opportunity {opp_id}: {e}\"\n                    ) from e\n                # skip: continue without this opportunity\n        return result\n\n    def get_associated_company_ids_batch(\n        self,\n        opportunity_ids: Sequence[OpportunityId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[OpportunityId, builtins.list[CompanyId]]:\n        \"\"\"\n        Get company associations for multiple opportunities.\n\n        Makes one V1 API call per opportunity. Useful for iterating list entries\n        where V2 returns empty company_ids.\n\n        Args:\n            opportunity_ids: Sequence of opportunity IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping opportunity_id -&gt; list of company_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n                includes the failing opportunity_id in its context.\n\n        Example:\n            # Get all companies from an opportunity list\n            opp_ids = [entry.entity.id for entry in client.lists.entries(list_id).all()]\n            associations = client.opportunities.get_associated_company_ids_batch(opp_ids)\n            all_company_ids = set()\n            for company_ids in associations.values():\n                all_company_ids.update(company_ids)\n        \"\"\"\n        result: dict[OpportunityId, builtins.list[CompanyId]] = {}\n        for opp_id in opportunity_ids:\n            try:\n                result[opp_id] = self.get_associated_company_ids(opp_id)\n            except AffinityError:\n                # Re-raise SDK errors directly - they already have good context\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this opportunity\n            except Exception as e:\n                if on_error == \"raise\":\n                    # Wrap non-SDK errors with context, preserving chain\n                    raise AffinityError(\n                        f\"Failed to get company associations for opportunity {opp_id}: {e}\"\n                    ) from e\n                # skip: continue without this opportunity\n        return result\n</code></pre> <p>Async version of OpportunityService (TR-009).</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>class AsyncOpportunityService:\n    \"\"\"Async version of OpportunityService (TR-009).\"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        self._client = client\n\n    async def get(self, opportunity_id: OpportunityId, *, retries: int = 0) -&gt; Opportunity:\n        \"\"\"\n        Get a single opportunity by ID.\n\n        Args:\n            opportunity_id: The opportunity ID\n            retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n                Set to 2-3 if calling immediately after create() to handle V1\u2192V2\n                eventual consistency lag.\n\n        Returns:\n            The opportunity representation returned by v2 (may be partial).\n\n        Raises:\n            NotFoundError: If opportunity does not exist after all retries.\n        \"\"\"\n        last_error: NotFoundError | None = None\n        attempts = retries + 1  # retries=0 means 1 attempt\n\n        for attempt in range(attempts):\n            try:\n                data = await self._client.get(f\"/opportunities/{opportunity_id}\")\n                return Opportunity.model_validate(data)\n            except NotFoundError as e:\n                last_error = e\n                if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                    await asyncio.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n        raise last_error  # type: ignore[misc]\n\n    async def get_details(self, opportunity_id: OpportunityId) -&gt; Opportunity:\n        \"\"\"\n        Get a single opportunity by ID with a more complete representation.\n\n        Includes association IDs and (when present) list entries, which are not\n        always included in the default `get()` response.\n\n        See Also:\n            - :meth:`get_associated_person_ids`: Get just person IDs (single API call)\n            - :meth:`get_associated_people`: Get full Person objects\n            - :meth:`get_associated_company_ids`: Get just company IDs (single API call)\n            - :meth:`get_associated_companies`: Get full Company objects\n            - :meth:`get_associations`: Get both person and company IDs in one call\n        \"\"\"\n        # Uses the v1 endpoint because it returns a fuller payload (including\n        # association IDs and, when present, list entries).\n        data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        return Opportunity.model_validate(data)\n\n    async def list(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[Opportunity]:\n        \"\"\"\n        List all opportunities.\n\n        Args:\n            ids: Specific opportunity IDs to fetch (batch lookup)\n            limit: Maximum number of results per page\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n        Returns the v2 opportunity representation (which may be partial).\n        For full opportunity row data, use list entries explicitly.\n        \"\"\"\n        if cursor is not None:\n            if ids is not None or limit is not None:\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = await self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if ids:\n                params[\"ids\"] = [int(id_) for id_ in ids]\n            if limit is not None:\n                params[\"limit\"] = limit\n            data = await self._client.get(\"/opportunities\", params=params or None)\n\n        return PaginatedResponse[Opportunity](\n            data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    async def pages(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[Opportunity]]:\n        \"\"\"\n        Iterate opportunity pages (not items), yielding `PaginatedResponse[Opportunity]`.\n\n        This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n\n        Args:\n            ids: Specific opportunity IDs to fetch (batch lookup)\n            limit: Maximum results per page\n            cursor: Cursor to resume pagination\n        \"\"\"\n        other_params = (ids, limit)\n        if cursor is not None and any(p is not None for p in other_params):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = (\n            await self.list(cursor=cursor)\n            if cursor is not None\n            else await self.list(ids=ids, limit=limit)\n        )\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = await self.list(cursor=next_cursor)\n\n    def all(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n    ) -&gt; AsyncIterator[Opportunity]:\n        \"\"\"\n        Iterate through all opportunities with automatic pagination.\n\n        Args:\n            ids: Specific opportunity IDs to fetch (batch lookup)\n        \"\"\"\n\n        async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Opportunity]:\n            if next_url:\n                data = await self._client.get_url(next_url)\n                return PaginatedResponse[Opportunity](\n                    data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n                    pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n                )\n            return await self.list(ids=ids)\n\n        return AsyncPageIterator(fetch_page)\n\n    def iter(\n        self,\n        *,\n        ids: Sequence[OpportunityId] | None = None,\n    ) -&gt; AsyncIterator[Opportunity]:\n        \"\"\"\n        Auto-paginate all opportunities.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all(ids=ids)\n\n    # =========================================================================\n    # Search (V1 API)\n    # =========================================================================\n\n    async def search(\n        self,\n        term: str | None = None,\n        *,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Opportunity]:\n        \"\"\"\n        Search for opportunities by name.\n\n        Uses V1 API for search functionality.\n\n        Args:\n            term: Search term (matches opportunity name). If None, returns all.\n            page_size: Results per page (max 500)\n            page_token: Pagination token\n\n        Returns:\n            PaginatedResponse with opportunities and next_page_token\n        \"\"\"\n        params: dict[str, Any] = {}\n        if term:\n            params[\"term\"] = term\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = await self._client.get(\"/opportunities\", params=params, v1=True)\n        items = [Opportunity.model_validate(o) for o in data.get(\"opportunities\", [])]\n        return PaginatedResponse[Opportunity](\n            data=items,\n            next_page_token=data.get(\"next_page_token\"),\n        )\n\n    async def search_pages(\n        self,\n        term: str | None = None,\n        *,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[Opportunity]]:\n        \"\"\"\n        Iterate V1 opportunity-search result pages.\n\n        Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n        Args:\n            term: Search term (matches opportunity name). If None, returns all.\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            PaginatedResponse[Opportunity] for each page\n        \"\"\"\n        requested_token = page_token\n        page = await self.search(term, page_size=page_size, page_token=page_token)\n        while True:\n            yield page\n            next_token = page.next_page_token\n            if not next_token or next_token == requested_token:\n                return\n            requested_token = next_token\n            page = await self.search(term, page_size=page_size, page_token=next_token)\n\n    async def search_all(\n        self,\n        term: str | None = None,\n        *,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; AsyncIterator[Opportunity]:\n        \"\"\"\n        Iterate all V1 opportunity-search results with automatic pagination.\n\n        Args:\n            term: Search term (matches opportunity name). If None, returns all.\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            Each Opportunity individually\n        \"\"\"\n        async for page in self.search_pages(term, page_size=page_size, page_token=page_token):\n            for opp in page.data:\n                yield opp\n\n    async def resolve(\n        self,\n        *,\n        name: str,\n        list_id: ListId,\n        limit: int | None = None,\n    ) -&gt; Opportunity | None:\n        \"\"\"\n        Find a single opportunity by exact name within a specific list.\n\n        Notes:\n        - Opportunities are list-scoped; a list id is required.\n        - This iterates list-entry pages client-side (no dedicated search endpoint).\n        - If multiple matches exist, returns the first match in server-provided order.\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name cannot be empty\")\n        name_lower = name.lower()\n\n        entries = AsyncListEntryService(self._client, list_id)\n        async for page in entries.pages(limit=limit):\n            for entry in page.data:\n                entity = entry.entity\n                if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                    return entity\n        return None\n\n    async def resolve_all(\n        self,\n        *,\n        name: str,\n        list_id: ListId,\n        limit: int | None = None,\n    ) -&gt; builtins.list[Opportunity]:\n        \"\"\"\n        Find all opportunities matching a name within a specific list.\n\n        Notes:\n        - Opportunities are list-scoped; a list id is required.\n        - This iterates list-entry pages client-side (no dedicated search endpoint).\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name cannot be empty\")\n        name_lower = name.lower()\n        matches: builtins.list[Opportunity] = []\n\n        entries = AsyncListEntryService(self._client, list_id)\n        async for page in entries.pages(limit=limit):\n            for entry in page.data:\n                entity = entry.entity\n                if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                    matches.append(entity)\n        return matches\n\n    # =========================================================================\n    # Write Operations (V1 API)\n    # =========================================================================\n\n    async def create(self, data: OpportunityCreate) -&gt; Opportunity:\n        \"\"\"\n        Create a new opportunity.\n\n        The opportunity will be added to the specified list.\n\n        Args:\n            data: Opportunity creation data including list_id and name\n\n        Returns:\n            The created opportunity\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n        if not data.person_ids:\n            payload.pop(\"person_ids\", None)\n        if not data.company_ids:\n            payload.pop(\"organization_ids\", None)\n\n        result = await self._client.post(\"/opportunities\", json=payload, v1=True)\n        return Opportunity.model_validate(result)\n\n    async def update(self, opportunity_id: OpportunityId, data: OpportunityUpdate) -&gt; Opportunity:\n        \"\"\"\n        Update an existing opportunity.\n\n        Note: When provided, `person_ids` and `company_ids` replace the existing\n        values. To add or remove associations safely, pass the full desired arrays.\n        \"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"json\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n\n        # Uses the v1 endpoint; its PUT semantics replace association arrays.\n        result = await self._client.put(f\"/opportunities/{opportunity_id}\", json=payload, v1=True)\n        return Opportunity.model_validate(result)\n\n    async def delete(self, opportunity_id: OpportunityId) -&gt; bool:\n        \"\"\"\n        Delete an opportunity.\n\n        This removes the opportunity and all associated list entries.\n\n        Args:\n            opportunity_id: The opportunity to delete\n\n        Returns:\n            True if successful\n        \"\"\"\n        result = await self._client.delete(f\"/opportunities/{opportunity_id}\", v1=True)\n        return bool(result.get(\"success\", False))\n\n    # =========================================================================\n    # Association Methods (V1 API)\n    # =========================================================================\n\n    async def get_associated_person_ids(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[PersonId]:\n        \"\"\"\n        Get associated person IDs for an opportunity.\n\n        V1-only: V2 does not expose opportunity -&gt; person associations.\n        Uses GET `/opportunities/{id}` (V1) and returns `person_ids`.\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of person IDs to return\n\n        Returns:\n            List of PersonId values associated with this opportunity\n\n        See Also:\n            - :meth:`get_associated_people`: Returns full Person objects\n            - :meth:`get_associations`: Get both person and company IDs in one call\n        \"\"\"\n        data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n        opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n        source = opportunity if isinstance(opportunity, dict) else data\n        person_ids = None\n        if isinstance(source, dict):\n            person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n        if not isinstance(person_ids, list):\n            return []\n\n        ids = [PersonId(int(pid)) for pid in person_ids if pid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    async def get_associated_people(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[Person]:\n        \"\"\"\n        Get Person objects associated with an opportunity.\n\n        Uses V2 batch lookup for efficiency (1 API call per 100 persons\n        instead of 1 per person).\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of people to return\n\n        Returns:\n            List of Person objects associated with this opportunity\n        \"\"\"\n        person_ids = await self.get_associated_person_ids(opportunity_id, max_results=max_results)\n        if not person_ids:\n            return []\n\n        # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n        # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n        params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n        people: builtins.list[Person] = []\n        data = await self._client.get(\"/persons\", params=params)  # V2 batch\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n\n        # Handle pagination if needed (&gt;100 persons)\n        # Note: max_results check is defensive - person_ids was already truncated above\n        pagination = data.get(\"pagination\", {})\n        next_url = pagination.get(\"nextUrl\")\n        while next_url and (max_results is None or len(people) &lt; max_results):\n            data = await self._client.get_url(next_url)\n            for item in data.get(\"data\", []):\n                people.append(Person.model_validate(item))\n            next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n        if max_results:\n            return people[:max_results]\n        return people\n\n    async def get_associated_company_ids(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[CompanyId]:\n        \"\"\"\n        Get associated company IDs for an opportunity.\n\n        V1-only: V2 does not expose opportunity -&gt; company associations.\n        Uses GET `/opportunities/{id}` (V1) and returns `organization_ids`.\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of company IDs to return\n\n        Returns:\n            List of CompanyId values associated with this opportunity\n\n        See Also:\n            - :meth:`get_associated_companies`: Returns full Company objects\n            - :meth:`get_associations`: Get both person and company IDs in one call\n        \"\"\"\n        data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n        opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n        source = opportunity if isinstance(opportunity, dict) else data\n        company_ids = None\n        if isinstance(source, dict):\n            company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n        if not isinstance(company_ids, list):\n            return []\n\n        ids = [CompanyId(int(cid)) for cid in company_ids if cid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    async def get_associated_companies(\n        self,\n        opportunity_id: OpportunityId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[Company]:\n        \"\"\"\n        Get Company objects associated with an opportunity.\n\n        Uses V2 batch lookup for efficiency (1 API call per 100 companies\n        instead of 1 per company).\n\n        Args:\n            opportunity_id: The opportunity ID\n            max_results: Maximum number of companies to return\n\n        Returns:\n            List of Company objects associated with this opportunity\n        \"\"\"\n        company_ids = await self.get_associated_company_ids(opportunity_id, max_results=max_results)\n        if not company_ids:\n            return []\n\n        # Use V2 batch lookup: GET /companies?ids=1&amp;ids=2&amp;ids=3\n        # Note: company_ids is already truncated by get_associated_company_ids if max_results set\n        params: dict[str, Any] = {\"ids\": [int(cid) for cid in company_ids]}\n\n        companies: builtins.list[Company] = []\n        data = await self._client.get(\"/companies\", params=params)  # V2 batch\n        for item in data.get(\"data\", []):\n            companies.append(Company.model_validate(item))\n\n        # Handle pagination if needed (&gt;100 companies)\n        # Note: max_results check is defensive - company_ids was already truncated above\n        pagination = data.get(\"pagination\", {})\n        next_url = pagination.get(\"nextUrl\")\n        while next_url and (max_results is None or len(companies) &lt; max_results):\n            data = await self._client.get_url(next_url)\n            for item in data.get(\"data\", []):\n                companies.append(Company.model_validate(item))\n            next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n        if max_results:\n            return companies[:max_results]\n        return companies\n\n    async def get_associations(\n        self,\n        opportunity_id: OpportunityId,\n    ) -&gt; OpportunityAssociations:\n        \"\"\"\n        Get both person and company associations in a single V1 call.\n\n        Use this when you need both types of associations to avoid\n        duplicate API calls from separate get_associated_*_ids() calls.\n\n        Args:\n            opportunity_id: The opportunity ID\n\n        Returns:\n            OpportunityAssociations named tuple with person_ids and company_ids\n\n        Example:\n            assoc = await client.opportunities.get_associations(opp_id)\n            print(assoc.person_ids)   # IDE autocomplete works\n            print(assoc.company_ids)  # IDE autocomplete works\n        \"\"\"\n        data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n        # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n        opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n        source = opportunity if isinstance(opportunity, dict) else data\n\n        person_ids: builtins.list[PersonId] = []\n        company_ids: builtins.list[CompanyId] = []\n\n        if isinstance(source, dict):\n            raw_person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n            raw_company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n            if isinstance(raw_person_ids, list):\n                person_ids = [PersonId(int(pid)) for pid in raw_person_ids if pid is not None]\n            if isinstance(raw_company_ids, list):\n                company_ids = [CompanyId(int(cid)) for cid in raw_company_ids if cid is not None]\n\n        return OpportunityAssociations(person_ids=person_ids, company_ids=company_ids)\n\n    async def get_associated_person_ids_batch(\n        self,\n        opportunity_ids: Sequence[OpportunityId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[OpportunityId, builtins.list[PersonId]]:\n        \"\"\"\n        Get person associations for multiple opportunities.\n\n        Makes one V1 API call per opportunity. Useful for iterating list entries\n        where V2 returns empty person_ids.\n\n        Args:\n            opportunity_ids: Sequence of opportunity IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping opportunity_id -&gt; list of person_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n                includes the failing opportunity_id in its context.\n\n        Example:\n            # Get all persons from an opportunity list\n            opp_ids = [entry.entity.id async for entry in client.lists.entries(list_id).all()]\n            associations = await client.opportunities.get_associated_person_ids_batch(opp_ids)\n            all_person_ids = set()\n            for person_ids in associations.values():\n                all_person_ids.update(person_ids)\n        \"\"\"\n        result: dict[OpportunityId, builtins.list[PersonId]] = {}\n        for opp_id in opportunity_ids:\n            try:\n                result[opp_id] = await self.get_associated_person_ids(opp_id)\n            except AffinityError:\n                # Re-raise SDK errors directly - they already have good context\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this opportunity\n            except Exception as e:\n                if on_error == \"raise\":\n                    # Wrap non-SDK errors with context, preserving chain\n                    raise AffinityError(\n                        f\"Failed to get associations for opportunity {opp_id}: {e}\"\n                    ) from e\n                # skip: continue without this opportunity\n        return result\n\n    async def get_associated_company_ids_batch(\n        self,\n        opportunity_ids: Sequence[OpportunityId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[OpportunityId, builtins.list[CompanyId]]:\n        \"\"\"\n        Get company associations for multiple opportunities.\n\n        Makes one V1 API call per opportunity. Useful for iterating list entries\n        where V2 returns empty company_ids.\n\n        Args:\n            opportunity_ids: Sequence of opportunity IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping opportunity_id -&gt; list of company_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n                includes the failing opportunity_id in its context.\n\n        Example:\n            # Get all companies from an opportunity list\n            opp_ids = [entry.entity.id async for entry in client.lists.entries(list_id).all()]\n            associations = await client.opportunities.get_associated_company_ids_batch(opp_ids)\n            all_company_ids = set()\n            for company_ids in associations.values():\n                all_company_ids.update(company_ids)\n        \"\"\"\n        result: dict[OpportunityId, builtins.list[CompanyId]] = {}\n        for opp_id in opportunity_ids:\n            try:\n                result[opp_id] = await self.get_associated_company_ids(opp_id)\n            except AffinityError:\n                # Re-raise SDK errors directly - they already have good context\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this opportunity\n            except Exception as e:\n                if on_error == \"raise\":\n                    # Wrap non-SDK errors with context, preserving chain\n                    raise AffinityError(\n                        f\"Failed to get company associations for opportunity {opp_id}: {e}\"\n                    ) from e\n                # skip: continue without this opportunity\n        return result\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.all","title":"<code>all(*, ids: Sequence[OpportunityId] | None = None) -&gt; Iterator[Opportunity]</code>","text":"<p>Iterate through all opportunities with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[OpportunityId] | None</code> <p>Specific opportunity IDs to fetch (batch lookup)</p> <code>None</code> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def all(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n) -&gt; Iterator[Opportunity]:\n    \"\"\"\n    Iterate through all opportunities with automatic pagination.\n\n    Args:\n        ids: Specific opportunity IDs to fetch (batch lookup)\n    \"\"\"\n\n    def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Opportunity]:\n        if next_url:\n            data = self._client.get_url(next_url)\n            return PaginatedResponse[Opportunity](\n                data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n                pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n            )\n        return self.list(ids=ids)\n\n    return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.create","title":"<code>create(data: OpportunityCreate) -&gt; Opportunity</code>","text":"<p>Create a new opportunity.</p> <p>The opportunity will be added to the specified list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>OpportunityCreate</code> <p>Opportunity creation data including list_id and name</p> required <p>Returns:</p> Type Description <code>Opportunity</code> <p>The created opportunity</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def create(self, data: OpportunityCreate) -&gt; Opportunity:\n    \"\"\"\n    Create a new opportunity.\n\n    The opportunity will be added to the specified list.\n\n    Args:\n        data: Opportunity creation data including list_id and name\n\n    Returns:\n        The created opportunity\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n    if not data.person_ids:\n        payload.pop(\"person_ids\", None)\n    if not data.company_ids:\n        payload.pop(\"organization_ids\", None)\n\n    result = self._client.post(\"/opportunities\", json=payload, v1=True)\n    return Opportunity.model_validate(result)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.delete","title":"<code>delete(opportunity_id: OpportunityId) -&gt; bool</code>","text":"<p>Delete an opportunity.</p> <p>This removes the opportunity and all associated list entries.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def delete(self, opportunity_id: OpportunityId) -&gt; bool:\n    \"\"\"\n    Delete an opportunity.\n\n    This removes the opportunity and all associated list entries.\n\n    Args:\n        opportunity_id: The opportunity to delete\n\n    Returns:\n        True if successful\n    \"\"\"\n    result = self._client.delete(f\"/opportunities/{opportunity_id}\", v1=True)\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get","title":"<code>get(opportunity_id: OpportunityId, *, retries: int = 0) -&gt; Opportunity</code>","text":"<p>Get a single opportunity by ID.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>retries</code> <code>int</code> <p>Number of retries on 404 NotFoundError. Default is 0 (fail fast). Set to 2-3 if calling immediately after create() to handle V1\u2192V2 eventual consistency lag.</p> <code>0</code> <p>Returns:</p> Type Description <code>Opportunity</code> <p>The opportunity representation returned by v2 (may be partial).</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If opportunity does not exist after all retries.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get(self, opportunity_id: OpportunityId, *, retries: int = 0) -&gt; Opportunity:\n    \"\"\"\n    Get a single opportunity by ID.\n\n    Args:\n        opportunity_id: The opportunity ID\n        retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n            Set to 2-3 if calling immediately after create() to handle V1\u2192V2\n            eventual consistency lag.\n\n    Returns:\n        The opportunity representation returned by v2 (may be partial).\n\n    Raises:\n        NotFoundError: If opportunity does not exist after all retries.\n    \"\"\"\n    last_error: NotFoundError | None = None\n    attempts = retries + 1  # retries=0 means 1 attempt\n\n    for attempt in range(attempts):\n        try:\n            data = self._client.get(f\"/opportunities/{opportunity_id}\")\n            return Opportunity.model_validate(data)\n        except NotFoundError as e:\n            last_error = e\n            if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                time.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n    raise last_error  # type: ignore[misc]\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_companies","title":"<code>get_associated_companies(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[Company]</code>","text":"<p>Get Company objects associated with an opportunity.</p> <p>Uses V2 batch lookup for efficiency (1 API call per 100 companies instead of 1 per company).</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of companies to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Company]</code> <p>List of Company objects associated with this opportunity</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_associated_companies(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[Company]:\n    \"\"\"\n    Get Company objects associated with an opportunity.\n\n    Uses V2 batch lookup for efficiency (1 API call per 100 companies\n    instead of 1 per company).\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of companies to return\n\n    Returns:\n        List of Company objects associated with this opportunity\n    \"\"\"\n    company_ids = self.get_associated_company_ids(opportunity_id, max_results=max_results)\n    if not company_ids:\n        return []\n\n    # Use V2 batch lookup: GET /companies?ids=1&amp;ids=2&amp;ids=3\n    # Note: company_ids is already truncated by get_associated_company_ids if max_results set\n    params: dict[str, Any] = {\"ids\": [int(cid) for cid in company_ids]}\n\n    companies: builtins.list[Company] = []\n    data = self._client.get(\"/companies\", params=params)  # V2 batch\n    for item in data.get(\"data\", []):\n        companies.append(Company.model_validate(item))\n\n    # Handle pagination if needed (&gt;100 companies)\n    # Note: max_results check is defensive - company_ids was already truncated above\n    pagination = data.get(\"pagination\", {})\n    next_url = pagination.get(\"nextUrl\")\n    while next_url and (max_results is None or len(companies) &lt; max_results):\n        data = self._client.get_url(next_url)\n        for item in data.get(\"data\", []):\n            companies.append(Company.model_validate(item))\n        next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n    if max_results:\n        return companies[:max_results]\n    return companies\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_company_ids","title":"<code>get_associated_company_ids(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[CompanyId]</code>","text":"<p>Get associated company IDs for an opportunity.</p> <p>V1-only: V2 does not expose opportunity -&gt; company associations. Uses GET <code>/opportunities/{id}</code> (V1) and returns <code>organization_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of company IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CompanyId]</code> <p>List of CompanyId values associated with this opportunity</p> See Also <ul> <li>:meth:<code>get_associated_companies</code>: Returns full Company objects</li> <li>:meth:<code>get_associations</code>: Get both person and company IDs in one call</li> </ul> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_associated_company_ids(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[CompanyId]:\n    \"\"\"\n    Get associated company IDs for an opportunity.\n\n    V1-only: V2 does not expose opportunity -&gt; company associations.\n    Uses GET `/opportunities/{id}` (V1) and returns `organization_ids`.\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of company IDs to return\n\n    Returns:\n        List of CompanyId values associated with this opportunity\n\n    See Also:\n        - :meth:`get_associated_companies`: Returns full Company objects\n        - :meth:`get_associations`: Get both person and company IDs in one call\n    \"\"\"\n    data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n    # for consistency with CompanyService pattern that handles \"organization\" wrapper\n    opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n    source = opportunity if isinstance(opportunity, dict) else data\n    company_ids = None\n    if isinstance(source, dict):\n        company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n    if not isinstance(company_ids, list):\n        return []\n\n    ids = [CompanyId(int(cid)) for cid in company_ids if cid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_company_ids_batch","title":"<code>get_associated_company_ids_batch(opportunity_ids: Sequence[OpportunityId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[OpportunityId, builtins.list[CompanyId]]</code>","text":"<p>Get company associations for multiple opportunities.</p> <p>Makes one V1 API call per opportunity. Useful for iterating list entries where V2 returns empty company_ids.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_ids</code> <code>Sequence[OpportunityId]</code> <p>Sequence of opportunity IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[OpportunityId, list[CompanyId]]</code> <p>Dict mapping opportunity_id -&gt; list of company_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails. The exception includes the failing opportunity_id in its context.</p> Example Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_associated_company_ids_batch(\n    self,\n    opportunity_ids: Sequence[OpportunityId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[OpportunityId, builtins.list[CompanyId]]:\n    \"\"\"\n    Get company associations for multiple opportunities.\n\n    Makes one V1 API call per opportunity. Useful for iterating list entries\n    where V2 returns empty company_ids.\n\n    Args:\n        opportunity_ids: Sequence of opportunity IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping opportunity_id -&gt; list of company_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n            includes the failing opportunity_id in its context.\n\n    Example:\n        # Get all companies from an opportunity list\n        opp_ids = [entry.entity.id for entry in client.lists.entries(list_id).all()]\n        associations = client.opportunities.get_associated_company_ids_batch(opp_ids)\n        all_company_ids = set()\n        for company_ids in associations.values():\n            all_company_ids.update(company_ids)\n    \"\"\"\n    result: dict[OpportunityId, builtins.list[CompanyId]] = {}\n    for opp_id in opportunity_ids:\n        try:\n            result[opp_id] = self.get_associated_company_ids(opp_id)\n        except AffinityError:\n            # Re-raise SDK errors directly - they already have good context\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this opportunity\n        except Exception as e:\n            if on_error == \"raise\":\n                # Wrap non-SDK errors with context, preserving chain\n                raise AffinityError(\n                    f\"Failed to get company associations for opportunity {opp_id}: {e}\"\n                ) from e\n            # skip: continue without this opportunity\n    return result\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_company_ids_batch--get-all-companies-from-an-opportunity-list","title":"Get all companies from an opportunity list","text":"<p>opp_ids = [entry.entity.id for entry in client.lists.entries(list_id).all()] associations = client.opportunities.get_associated_company_ids_batch(opp_ids) all_company_ids = set() for company_ids in associations.values():     all_company_ids.update(company_ids)</p>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_people","title":"<code>get_associated_people(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[Person]</code>","text":"<p>Get Person objects associated with an opportunity.</p> <p>Uses V2 batch lookup for efficiency (1 API call per 100 persons instead of 1 per person).</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of people to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Person]</code> <p>List of Person objects associated with this opportunity</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_associated_people(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[Person]:\n    \"\"\"\n    Get Person objects associated with an opportunity.\n\n    Uses V2 batch lookup for efficiency (1 API call per 100 persons\n    instead of 1 per person).\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of people to return\n\n    Returns:\n        List of Person objects associated with this opportunity\n    \"\"\"\n    person_ids = self.get_associated_person_ids(opportunity_id, max_results=max_results)\n    if not person_ids:\n        return []\n\n    # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n    # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n    params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n    people: builtins.list[Person] = []\n    data = self._client.get(\"/persons\", params=params)  # V2 batch\n    for item in data.get(\"data\", []):\n        people.append(Person.model_validate(item))\n\n    # Handle pagination if needed (&gt;100 persons)\n    # Note: max_results check is defensive - person_ids was already truncated above\n    pagination = data.get(\"pagination\", {})\n    next_url = pagination.get(\"nextUrl\")\n    while next_url and (max_results is None or len(people) &lt; max_results):\n        data = self._client.get_url(next_url)\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n        next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n    if max_results:\n        return people[:max_results]\n    return people\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_person_ids","title":"<code>get_associated_person_ids(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[PersonId]</code>","text":"<p>Get associated person IDs for an opportunity.</p> <p>V1-only: V2 does not expose opportunity -&gt; person associations. Uses GET <code>/opportunities/{id}</code> (V1) and returns <code>person_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of person IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[PersonId]</code> <p>List of PersonId values associated with this opportunity</p> See Also <ul> <li>:meth:<code>get_associated_people</code>: Returns full Person objects</li> <li>:meth:<code>get_associations</code>: Get both person and company IDs in one call</li> </ul> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_associated_person_ids(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[PersonId]:\n    \"\"\"\n    Get associated person IDs for an opportunity.\n\n    V1-only: V2 does not expose opportunity -&gt; person associations.\n    Uses GET `/opportunities/{id}` (V1) and returns `person_ids`.\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of person IDs to return\n\n    Returns:\n        List of PersonId values associated with this opportunity\n\n    See Also:\n        - :meth:`get_associated_people`: Returns full Person objects\n        - :meth:`get_associations`: Get both person and company IDs in one call\n    \"\"\"\n    data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n    # for consistency with CompanyService pattern that handles \"organization\" wrapper\n    opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n    source = opportunity if isinstance(opportunity, dict) else data\n    person_ids = None\n    if isinstance(source, dict):\n        person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n    if not isinstance(person_ids, list):\n        return []\n\n    ids = [PersonId(int(pid)) for pid in person_ids if pid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_person_ids_batch","title":"<code>get_associated_person_ids_batch(opportunity_ids: Sequence[OpportunityId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[OpportunityId, builtins.list[PersonId]]</code>","text":"<p>Get person associations for multiple opportunities.</p> <p>Makes one V1 API call per opportunity. Useful for iterating list entries where V2 returns empty person_ids.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_ids</code> <code>Sequence[OpportunityId]</code> <p>Sequence of opportunity IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[OpportunityId, list[PersonId]]</code> <p>Dict mapping opportunity_id -&gt; list of person_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails. The exception includes the failing opportunity_id in its context.</p> Example Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_associated_person_ids_batch(\n    self,\n    opportunity_ids: Sequence[OpportunityId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[OpportunityId, builtins.list[PersonId]]:\n    \"\"\"\n    Get person associations for multiple opportunities.\n\n    Makes one V1 API call per opportunity. Useful for iterating list entries\n    where V2 returns empty person_ids.\n\n    Args:\n        opportunity_ids: Sequence of opportunity IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping opportunity_id -&gt; list of person_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n            includes the failing opportunity_id in its context.\n\n    Example:\n        # Get all persons from an opportunity list\n        opp_ids = [entry.entity.id for entry in client.lists.entries(list_id).all()]\n        associations = client.opportunities.get_associated_person_ids_batch(opp_ids)\n        all_person_ids = set()\n        for person_ids in associations.values():\n            all_person_ids.update(person_ids)\n    \"\"\"\n    result: dict[OpportunityId, builtins.list[PersonId]] = {}\n    for opp_id in opportunity_ids:\n        try:\n            result[opp_id] = self.get_associated_person_ids(opp_id)\n        except AffinityError:\n            # Re-raise SDK errors directly - they already have good context\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this opportunity\n        except Exception as e:\n            if on_error == \"raise\":\n                # Wrap non-SDK errors with context, preserving chain\n                raise AffinityError(\n                    f\"Failed to get associations for opportunity {opp_id}: {e}\"\n                ) from e\n            # skip: continue without this opportunity\n    return result\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associated_person_ids_batch--get-all-persons-from-an-opportunity-list","title":"Get all persons from an opportunity list","text":"<p>opp_ids = [entry.entity.id for entry in client.lists.entries(list_id).all()] associations = client.opportunities.get_associated_person_ids_batch(opp_ids) all_person_ids = set() for person_ids in associations.values():     all_person_ids.update(person_ids)</p>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_associations","title":"<code>get_associations(opportunity_id: OpportunityId) -&gt; OpportunityAssociations</code>","text":"<p>Get both person and company associations in a single V1 call.</p> <p>Use this when you need both types of associations to avoid duplicate API calls from separate get_associated_*_ids() calls.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <p>Returns:</p> Type Description <code>OpportunityAssociations</code> <p>OpportunityAssociations named tuple with person_ids and company_ids</p> Example <p>assoc = client.opportunities.get_associations(opp_id) print(assoc.person_ids)   # IDE autocomplete works print(assoc.company_ids)  # IDE autocomplete works</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_associations(\n    self,\n    opportunity_id: OpportunityId,\n) -&gt; OpportunityAssociations:\n    \"\"\"\n    Get both person and company associations in a single V1 call.\n\n    Use this when you need both types of associations to avoid\n    duplicate API calls from separate get_associated_*_ids() calls.\n\n    Args:\n        opportunity_id: The opportunity ID\n\n    Returns:\n        OpportunityAssociations named tuple with person_ids and company_ids\n\n    Example:\n        assoc = client.opportunities.get_associations(opp_id)\n        print(assoc.person_ids)   # IDE autocomplete works\n        print(assoc.company_ids)  # IDE autocomplete works\n    \"\"\"\n    data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n    opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n    source = opportunity if isinstance(opportunity, dict) else data\n\n    person_ids: builtins.list[PersonId] = []\n    company_ids: builtins.list[CompanyId] = []\n\n    if isinstance(source, dict):\n        raw_person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n        raw_company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n        if isinstance(raw_person_ids, list):\n            person_ids = [PersonId(int(pid)) for pid in raw_person_ids if pid is not None]\n        if isinstance(raw_company_ids, list):\n            company_ids = [CompanyId(int(cid)) for cid in raw_company_ids if cid is not None]\n\n    return OpportunityAssociations(person_ids=person_ids, company_ids=company_ids)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.get_details","title":"<code>get_details(opportunity_id: OpportunityId) -&gt; Opportunity</code>","text":"<p>Get a single opportunity by ID with a more complete representation.</p> <p>Includes association IDs and (when present) list entries, which are not always included in the default <code>get()</code> response.</p> See Also <ul> <li>:meth:<code>get_associated_person_ids</code>: Get just person IDs (single API call)</li> <li>:meth:<code>get_associated_people</code>: Get full Person objects</li> <li>:meth:<code>get_associated_company_ids</code>: Get just company IDs (single API call)</li> <li>:meth:<code>get_associated_companies</code>: Get full Company objects</li> <li>:meth:<code>get_associations</code>: Get both person and company IDs in one call</li> </ul> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def get_details(self, opportunity_id: OpportunityId) -&gt; Opportunity:\n    \"\"\"\n    Get a single opportunity by ID with a more complete representation.\n\n    Includes association IDs and (when present) list entries, which are not\n    always included in the default `get()` response.\n\n    See Also:\n        - :meth:`get_associated_person_ids`: Get just person IDs (single API call)\n        - :meth:`get_associated_people`: Get full Person objects\n        - :meth:`get_associated_company_ids`: Get just company IDs (single API call)\n        - :meth:`get_associated_companies`: Get full Company objects\n        - :meth:`get_associations`: Get both person and company IDs in one call\n    \"\"\"\n    # Uses the v1 endpoint because it returns a fuller payload (including\n    # association IDs and, when present, list entries).\n    data = self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    return Opportunity.model_validate(data)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.iter","title":"<code>iter(*, ids: Sequence[OpportunityId] | None = None) -&gt; Iterator[Opportunity]</code>","text":"<p>Auto-paginate all opportunities.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def iter(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n) -&gt; Iterator[Opportunity]:\n    \"\"\"\n    Auto-paginate all opportunities.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all(ids=ids)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.list","title":"<code>list(*, ids: Sequence[OpportunityId] | None = None, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[Opportunity]</code>","text":"<p>List all opportunities.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[OpportunityId] | None</code> <p>Specific opportunity IDs to fetch (batch lookup)</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses)</p> <code>None</code> <p>Returns the v2 opportunity representation (which may be partial). For full opportunity row data, use list entries explicitly.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def list(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[Opportunity]:\n    \"\"\"\n    List all opportunities.\n\n    Args:\n        ids: Specific opportunity IDs to fetch (batch lookup)\n        limit: Maximum number of results per page\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n    Returns the v2 opportunity representation (which may be partial).\n    For full opportunity row data, use list entries explicitly.\n    \"\"\"\n    if cursor is not None:\n        if ids is not None or limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if ids:\n            params[\"ids\"] = [int(id_) for id_ in ids]\n        if limit is not None:\n            params[\"limit\"] = limit\n        data = self._client.get(\"/opportunities\", params=params or None)\n\n    return PaginatedResponse[Opportunity](\n        data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.pages","title":"<code>pages(*, ids: Sequence[OpportunityId] | None = None, limit: int | None = None, cursor: str | None = None) -&gt; Iterator[PaginatedResponse[Opportunity]]</code>","text":"<p>Iterate opportunity pages (not items), yielding <code>PaginatedResponse[Opportunity]</code>.</p> <p>This is useful for ETL scripts that want checkpoint/resume via <code>page.next_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[OpportunityId] | None</code> <p>Specific opportunity IDs to fetch (batch lookup)</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination</p> <code>None</code> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def pages(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; Iterator[PaginatedResponse[Opportunity]]:\n    \"\"\"\n    Iterate opportunity pages (not items), yielding `PaginatedResponse[Opportunity]`.\n\n    This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n\n    Args:\n        ids: Specific opportunity IDs to fetch (batch lookup)\n        limit: Maximum results per page\n        cursor: Cursor to resume pagination\n    \"\"\"\n    other_params = (ids, limit)\n    if cursor is not None and any(p is not None for p in other_params):\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = self.list(cursor=cursor) if cursor is not None else self.list(ids=ids, limit=limit)\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.resolve","title":"<code>resolve(*, name: str, list_id: ListId, limit: int | None = None) -&gt; Opportunity | None</code>","text":"<p>Find a single opportunity by exact name within a specific list.</p> <p>Notes: - Opportunities are list-scoped; a list id is required. - This iterates list-entry pages client-side (no dedicated search endpoint). - If multiple matches exist, returns the first match in server-provided order.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def resolve(\n    self,\n    *,\n    name: str,\n    list_id: ListId,\n    limit: int | None = None,\n) -&gt; Opportunity | None:\n    \"\"\"\n    Find a single opportunity by exact name within a specific list.\n\n    Notes:\n    - Opportunities are list-scoped; a list id is required.\n    - This iterates list-entry pages client-side (no dedicated search endpoint).\n    - If multiple matches exist, returns the first match in server-provided order.\n    \"\"\"\n    name = name.strip()\n    if not name:\n        raise ValueError(\"Name cannot be empty\")\n    name_lower = name.lower()\n\n    entries = ListEntryService(self._client, list_id)\n    for page in entries.pages(limit=limit):\n        for entry in page.data:\n            entity = entry.entity\n            if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                return entity\n    return None\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.resolve_all","title":"<code>resolve_all(*, name: str, list_id: ListId, limit: int | None = None) -&gt; builtins.list[Opportunity]</code>","text":"<p>Find all opportunities matching a name within a specific list.</p> <p>Notes: - Opportunities are list-scoped; a list id is required. - This iterates list-entry pages client-side (no dedicated search endpoint).</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def resolve_all(\n    self,\n    *,\n    name: str,\n    list_id: ListId,\n    limit: int | None = None,\n) -&gt; builtins.list[Opportunity]:\n    \"\"\"\n    Find all opportunities matching a name within a specific list.\n\n    Notes:\n    - Opportunities are list-scoped; a list id is required.\n    - This iterates list-entry pages client-side (no dedicated search endpoint).\n    \"\"\"\n    name = name.strip()\n    if not name:\n        raise ValueError(\"Name cannot be empty\")\n    name_lower = name.lower()\n    matches: builtins.list[Opportunity] = []\n\n    entries = ListEntryService(self._client, list_id)\n    for page in entries.pages(limit=limit):\n        for entry in page.data:\n            entity = entry.entity\n            if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                matches.append(entity)\n    return matches\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.search","title":"<code>search(term: str | None = None, *, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Opportunity]</code>","text":"<p>Search for opportunities by name.</p> <p>Uses V1 API for search functionality.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str | None</code> <p>Search term (matches opportunity name). If None, returns all.</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Pagination token</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Opportunity]</code> <p>PaginatedResponse with opportunities and next_page_token</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def search(\n    self,\n    term: str | None = None,\n    *,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Opportunity]:\n    \"\"\"\n    Search for opportunities by name.\n\n    Uses V1 API for search functionality.\n\n    Args:\n        term: Search term (matches opportunity name). If None, returns all.\n        page_size: Results per page (max 500)\n        page_token: Pagination token\n\n    Returns:\n        PaginatedResponse with opportunities and next_page_token\n    \"\"\"\n    params: dict[str, Any] = {}\n    if term:\n        params[\"term\"] = term\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = self._client.get(\"/opportunities\", params=params, v1=True)\n    items = [Opportunity.model_validate(o) for o in data.get(\"opportunities\", [])]\n    return PaginatedResponse[Opportunity](\n        data=items,\n        next_page_token=data.get(\"next_page_token\"),\n    )\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.search_all","title":"<code>search_all(term: str | None = None, *, page_size: int | None = None, page_token: str | None = None) -&gt; Iterator[Opportunity]</code>","text":"<p>Iterate all V1 opportunity-search results with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str | None</code> <p>Search term (matches opportunity name). If None, returns all.</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>Opportunity</code> <p>Each Opportunity individually</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def search_all(\n    self,\n    term: str | None = None,\n    *,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; Iterator[Opportunity]:\n    \"\"\"\n    Iterate all V1 opportunity-search results with automatic pagination.\n\n    Args:\n        term: Search term (matches opportunity name). If None, returns all.\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        Each Opportunity individually\n    \"\"\"\n    for page in self.search_pages(term, page_size=page_size, page_token=page_token):\n        yield from page.data\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.search_pages","title":"<code>search_pages(term: str | None = None, *, page_size: int | None = None, page_token: str | None = None) -&gt; Iterator[PaginatedResponse[Opportunity]]</code>","text":"<p>Iterate V1 opportunity-search result pages.</p> <p>Useful for scripts that need checkpoint/resume via <code>next_page_token</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str | None</code> <p>Search term (matches opportunity name). If None, returns all.</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>PaginatedResponse[Opportunity]</code> <p>PaginatedResponse[Opportunity] for each page</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def search_pages(\n    self,\n    term: str | None = None,\n    *,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; Iterator[PaginatedResponse[Opportunity]]:\n    \"\"\"\n    Iterate V1 opportunity-search result pages.\n\n    Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n    Args:\n        term: Search term (matches opportunity name). If None, returns all.\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        PaginatedResponse[Opportunity] for each page\n    \"\"\"\n    requested_token = page_token\n    page = self.search(term, page_size=page_size, page_token=page_token)\n    while True:\n        yield page\n        next_token = page.next_page_token\n        if not next_token or next_token == requested_token:\n            return\n        requested_token = next_token\n        page = self.search(term, page_size=page_size, page_token=next_token)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.OpportunityService.update","title":"<code>update(opportunity_id: OpportunityId, data: OpportunityUpdate) -&gt; Opportunity</code>","text":"<p>Update an existing opportunity.</p> <p>Note: When provided, <code>person_ids</code> and <code>company_ids</code> replace the existing values. To add or remove associations safely, pass the full desired arrays.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def update(self, opportunity_id: OpportunityId, data: OpportunityUpdate) -&gt; Opportunity:\n    \"\"\"\n    Update an existing opportunity.\n\n    Note: When provided, `person_ids` and `company_ids` replace the existing\n    values. To add or remove associations safely, pass the full desired arrays.\n    \"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"json\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n\n    # Uses the v1 endpoint; its PUT semantics replace association arrays.\n    result = self._client.put(f\"/opportunities/{opportunity_id}\", json=payload, v1=True)\n    return Opportunity.model_validate(result)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.all","title":"<code>all(*, ids: Sequence[OpportunityId] | None = None) -&gt; AsyncIterator[Opportunity]</code>","text":"<p>Iterate through all opportunities with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[OpportunityId] | None</code> <p>Specific opportunity IDs to fetch (batch lookup)</p> <code>None</code> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def all(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n) -&gt; AsyncIterator[Opportunity]:\n    \"\"\"\n    Iterate through all opportunities with automatic pagination.\n\n    Args:\n        ids: Specific opportunity IDs to fetch (batch lookup)\n    \"\"\"\n\n    async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Opportunity]:\n        if next_url:\n            data = await self._client.get_url(next_url)\n            return PaginatedResponse[Opportunity](\n                data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n                pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n            )\n        return await self.list(ids=ids)\n\n    return AsyncPageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.create","title":"<code>create(data: OpportunityCreate) -&gt; Opportunity</code>  <code>async</code>","text":"<p>Create a new opportunity.</p> <p>The opportunity will be added to the specified list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>OpportunityCreate</code> <p>Opportunity creation data including list_id and name</p> required <p>Returns:</p> Type Description <code>Opportunity</code> <p>The created opportunity</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def create(self, data: OpportunityCreate) -&gt; Opportunity:\n    \"\"\"\n    Create a new opportunity.\n\n    The opportunity will be added to the specified list.\n\n    Args:\n        data: Opportunity creation data including list_id and name\n\n    Returns:\n        The created opportunity\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n    if not data.person_ids:\n        payload.pop(\"person_ids\", None)\n    if not data.company_ids:\n        payload.pop(\"organization_ids\", None)\n\n    result = await self._client.post(\"/opportunities\", json=payload, v1=True)\n    return Opportunity.model_validate(result)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.delete","title":"<code>delete(opportunity_id: OpportunityId) -&gt; bool</code>  <code>async</code>","text":"<p>Delete an opportunity.</p> <p>This removes the opportunity and all associated list entries.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def delete(self, opportunity_id: OpportunityId) -&gt; bool:\n    \"\"\"\n    Delete an opportunity.\n\n    This removes the opportunity and all associated list entries.\n\n    Args:\n        opportunity_id: The opportunity to delete\n\n    Returns:\n        True if successful\n    \"\"\"\n    result = await self._client.delete(f\"/opportunities/{opportunity_id}\", v1=True)\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get","title":"<code>get(opportunity_id: OpportunityId, *, retries: int = 0) -&gt; Opportunity</code>  <code>async</code>","text":"<p>Get a single opportunity by ID.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>retries</code> <code>int</code> <p>Number of retries on 404 NotFoundError. Default is 0 (fail fast). Set to 2-3 if calling immediately after create() to handle V1\u2192V2 eventual consistency lag.</p> <code>0</code> <p>Returns:</p> Type Description <code>Opportunity</code> <p>The opportunity representation returned by v2 (may be partial).</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If opportunity does not exist after all retries.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get(self, opportunity_id: OpportunityId, *, retries: int = 0) -&gt; Opportunity:\n    \"\"\"\n    Get a single opportunity by ID.\n\n    Args:\n        opportunity_id: The opportunity ID\n        retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n            Set to 2-3 if calling immediately after create() to handle V1\u2192V2\n            eventual consistency lag.\n\n    Returns:\n        The opportunity representation returned by v2 (may be partial).\n\n    Raises:\n        NotFoundError: If opportunity does not exist after all retries.\n    \"\"\"\n    last_error: NotFoundError | None = None\n    attempts = retries + 1  # retries=0 means 1 attempt\n\n    for attempt in range(attempts):\n        try:\n            data = await self._client.get(f\"/opportunities/{opportunity_id}\")\n            return Opportunity.model_validate(data)\n        except NotFoundError as e:\n            last_error = e\n            if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                await asyncio.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n    raise last_error  # type: ignore[misc]\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_companies","title":"<code>get_associated_companies(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[Company]</code>  <code>async</code>","text":"<p>Get Company objects associated with an opportunity.</p> <p>Uses V2 batch lookup for efficiency (1 API call per 100 companies instead of 1 per company).</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of companies to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Company]</code> <p>List of Company objects associated with this opportunity</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_associated_companies(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[Company]:\n    \"\"\"\n    Get Company objects associated with an opportunity.\n\n    Uses V2 batch lookup for efficiency (1 API call per 100 companies\n    instead of 1 per company).\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of companies to return\n\n    Returns:\n        List of Company objects associated with this opportunity\n    \"\"\"\n    company_ids = await self.get_associated_company_ids(opportunity_id, max_results=max_results)\n    if not company_ids:\n        return []\n\n    # Use V2 batch lookup: GET /companies?ids=1&amp;ids=2&amp;ids=3\n    # Note: company_ids is already truncated by get_associated_company_ids if max_results set\n    params: dict[str, Any] = {\"ids\": [int(cid) for cid in company_ids]}\n\n    companies: builtins.list[Company] = []\n    data = await self._client.get(\"/companies\", params=params)  # V2 batch\n    for item in data.get(\"data\", []):\n        companies.append(Company.model_validate(item))\n\n    # Handle pagination if needed (&gt;100 companies)\n    # Note: max_results check is defensive - company_ids was already truncated above\n    pagination = data.get(\"pagination\", {})\n    next_url = pagination.get(\"nextUrl\")\n    while next_url and (max_results is None or len(companies) &lt; max_results):\n        data = await self._client.get_url(next_url)\n        for item in data.get(\"data\", []):\n            companies.append(Company.model_validate(item))\n        next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n    if max_results:\n        return companies[:max_results]\n    return companies\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_company_ids","title":"<code>get_associated_company_ids(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[CompanyId]</code>  <code>async</code>","text":"<p>Get associated company IDs for an opportunity.</p> <p>V1-only: V2 does not expose opportunity -&gt; company associations. Uses GET <code>/opportunities/{id}</code> (V1) and returns <code>organization_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of company IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CompanyId]</code> <p>List of CompanyId values associated with this opportunity</p> See Also <ul> <li>:meth:<code>get_associated_companies</code>: Returns full Company objects</li> <li>:meth:<code>get_associations</code>: Get both person and company IDs in one call</li> </ul> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_associated_company_ids(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[CompanyId]:\n    \"\"\"\n    Get associated company IDs for an opportunity.\n\n    V1-only: V2 does not expose opportunity -&gt; company associations.\n    Uses GET `/opportunities/{id}` (V1) and returns `organization_ids`.\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of company IDs to return\n\n    Returns:\n        List of CompanyId values associated with this opportunity\n\n    See Also:\n        - :meth:`get_associated_companies`: Returns full Company objects\n        - :meth:`get_associations`: Get both person and company IDs in one call\n    \"\"\"\n    data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n    opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n    source = opportunity if isinstance(opportunity, dict) else data\n    company_ids = None\n    if isinstance(source, dict):\n        company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n    if not isinstance(company_ids, list):\n        return []\n\n    ids = [CompanyId(int(cid)) for cid in company_ids if cid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_company_ids_batch","title":"<code>get_associated_company_ids_batch(opportunity_ids: Sequence[OpportunityId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[OpportunityId, builtins.list[CompanyId]]</code>  <code>async</code>","text":"<p>Get company associations for multiple opportunities.</p> <p>Makes one V1 API call per opportunity. Useful for iterating list entries where V2 returns empty company_ids.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_ids</code> <code>Sequence[OpportunityId]</code> <p>Sequence of opportunity IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[OpportunityId, list[CompanyId]]</code> <p>Dict mapping opportunity_id -&gt; list of company_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails. The exception includes the failing opportunity_id in its context.</p> Example Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_associated_company_ids_batch(\n    self,\n    opportunity_ids: Sequence[OpportunityId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[OpportunityId, builtins.list[CompanyId]]:\n    \"\"\"\n    Get company associations for multiple opportunities.\n\n    Makes one V1 API call per opportunity. Useful for iterating list entries\n    where V2 returns empty company_ids.\n\n    Args:\n        opportunity_ids: Sequence of opportunity IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping opportunity_id -&gt; list of company_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n            includes the failing opportunity_id in its context.\n\n    Example:\n        # Get all companies from an opportunity list\n        opp_ids = [entry.entity.id async for entry in client.lists.entries(list_id).all()]\n        associations = await client.opportunities.get_associated_company_ids_batch(opp_ids)\n        all_company_ids = set()\n        for company_ids in associations.values():\n            all_company_ids.update(company_ids)\n    \"\"\"\n    result: dict[OpportunityId, builtins.list[CompanyId]] = {}\n    for opp_id in opportunity_ids:\n        try:\n            result[opp_id] = await self.get_associated_company_ids(opp_id)\n        except AffinityError:\n            # Re-raise SDK errors directly - they already have good context\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this opportunity\n        except Exception as e:\n            if on_error == \"raise\":\n                # Wrap non-SDK errors with context, preserving chain\n                raise AffinityError(\n                    f\"Failed to get company associations for opportunity {opp_id}: {e}\"\n                ) from e\n            # skip: continue without this opportunity\n    return result\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_company_ids_batch--get-all-companies-from-an-opportunity-list","title":"Get all companies from an opportunity list","text":"<p>opp_ids = [entry.entity.id async for entry in client.lists.entries(list_id).all()] associations = await client.opportunities.get_associated_company_ids_batch(opp_ids) all_company_ids = set() for company_ids in associations.values():     all_company_ids.update(company_ids)</p>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_people","title":"<code>get_associated_people(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[Person]</code>  <code>async</code>","text":"<p>Get Person objects associated with an opportunity.</p> <p>Uses V2 batch lookup for efficiency (1 API call per 100 persons instead of 1 per person).</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of people to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Person]</code> <p>List of Person objects associated with this opportunity</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_associated_people(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[Person]:\n    \"\"\"\n    Get Person objects associated with an opportunity.\n\n    Uses V2 batch lookup for efficiency (1 API call per 100 persons\n    instead of 1 per person).\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of people to return\n\n    Returns:\n        List of Person objects associated with this opportunity\n    \"\"\"\n    person_ids = await self.get_associated_person_ids(opportunity_id, max_results=max_results)\n    if not person_ids:\n        return []\n\n    # Use V2 batch lookup: GET /persons?ids=1&amp;ids=2&amp;ids=3\n    # Note: person_ids is already truncated by get_associated_person_ids if max_results set\n    params: dict[str, Any] = {\"ids\": [int(pid) for pid in person_ids]}\n\n    people: builtins.list[Person] = []\n    data = await self._client.get(\"/persons\", params=params)  # V2 batch\n    for item in data.get(\"data\", []):\n        people.append(Person.model_validate(item))\n\n    # Handle pagination if needed (&gt;100 persons)\n    # Note: max_results check is defensive - person_ids was already truncated above\n    pagination = data.get(\"pagination\", {})\n    next_url = pagination.get(\"nextUrl\")\n    while next_url and (max_results is None or len(people) &lt; max_results):\n        data = await self._client.get_url(next_url)\n        for item in data.get(\"data\", []):\n            people.append(Person.model_validate(item))\n        next_url = data.get(\"pagination\", {}).get(\"nextUrl\")\n\n    if max_results:\n        return people[:max_results]\n    return people\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_person_ids","title":"<code>get_associated_person_ids(opportunity_id: OpportunityId, *, max_results: int | None = None) -&gt; builtins.list[PersonId]</code>  <code>async</code>","text":"<p>Get associated person IDs for an opportunity.</p> <p>V1-only: V2 does not expose opportunity -&gt; person associations. Uses GET <code>/opportunities/{id}</code> (V1) and returns <code>person_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of person IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[PersonId]</code> <p>List of PersonId values associated with this opportunity</p> See Also <ul> <li>:meth:<code>get_associated_people</code>: Returns full Person objects</li> <li>:meth:<code>get_associations</code>: Get both person and company IDs in one call</li> </ul> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_associated_person_ids(\n    self,\n    opportunity_id: OpportunityId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[PersonId]:\n    \"\"\"\n    Get associated person IDs for an opportunity.\n\n    V1-only: V2 does not expose opportunity -&gt; person associations.\n    Uses GET `/opportunities/{id}` (V1) and returns `person_ids`.\n\n    Args:\n        opportunity_id: The opportunity ID\n        max_results: Maximum number of person IDs to return\n\n    Returns:\n        List of PersonId values associated with this opportunity\n\n    See Also:\n        - :meth:`get_associated_people`: Returns full Person objects\n        - :meth:`get_associations`: Get both person and company IDs in one call\n    \"\"\"\n    data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n    opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n    source = opportunity if isinstance(opportunity, dict) else data\n    person_ids = None\n    if isinstance(source, dict):\n        person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n\n    if not isinstance(person_ids, list):\n        return []\n\n    ids = [PersonId(int(pid)) for pid in person_ids if pid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_person_ids_batch","title":"<code>get_associated_person_ids_batch(opportunity_ids: Sequence[OpportunityId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[OpportunityId, builtins.list[PersonId]]</code>  <code>async</code>","text":"<p>Get person associations for multiple opportunities.</p> <p>Makes one V1 API call per opportunity. Useful for iterating list entries where V2 returns empty person_ids.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_ids</code> <code>Sequence[OpportunityId]</code> <p>Sequence of opportunity IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[OpportunityId, list[PersonId]]</code> <p>Dict mapping opportunity_id -&gt; list of person_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails. The exception includes the failing opportunity_id in its context.</p> Example Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_associated_person_ids_batch(\n    self,\n    opportunity_ids: Sequence[OpportunityId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[OpportunityId, builtins.list[PersonId]]:\n    \"\"\"\n    Get person associations for multiple opportunities.\n\n    Makes one V1 API call per opportunity. Useful for iterating list entries\n    where V2 returns empty person_ids.\n\n    Args:\n        opportunity_ids: Sequence of opportunity IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping opportunity_id -&gt; list of person_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails. The exception\n            includes the failing opportunity_id in its context.\n\n    Example:\n        # Get all persons from an opportunity list\n        opp_ids = [entry.entity.id async for entry in client.lists.entries(list_id).all()]\n        associations = await client.opportunities.get_associated_person_ids_batch(opp_ids)\n        all_person_ids = set()\n        for person_ids in associations.values():\n            all_person_ids.update(person_ids)\n    \"\"\"\n    result: dict[OpportunityId, builtins.list[PersonId]] = {}\n    for opp_id in opportunity_ids:\n        try:\n            result[opp_id] = await self.get_associated_person_ids(opp_id)\n        except AffinityError:\n            # Re-raise SDK errors directly - they already have good context\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this opportunity\n        except Exception as e:\n            if on_error == \"raise\":\n                # Wrap non-SDK errors with context, preserving chain\n                raise AffinityError(\n                    f\"Failed to get associations for opportunity {opp_id}: {e}\"\n                ) from e\n            # skip: continue without this opportunity\n    return result\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associated_person_ids_batch--get-all-persons-from-an-opportunity-list","title":"Get all persons from an opportunity list","text":"<p>opp_ids = [entry.entity.id async for entry in client.lists.entries(list_id).all()] associations = await client.opportunities.get_associated_person_ids_batch(opp_ids) all_person_ids = set() for person_ids in associations.values():     all_person_ids.update(person_ids)</p>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_associations","title":"<code>get_associations(opportunity_id: OpportunityId) -&gt; OpportunityAssociations</code>  <code>async</code>","text":"<p>Get both person and company associations in a single V1 call.</p> <p>Use this when you need both types of associations to avoid duplicate API calls from separate get_associated_*_ids() calls.</p> <p>Parameters:</p> Name Type Description Default <code>opportunity_id</code> <code>OpportunityId</code> <p>The opportunity ID</p> required <p>Returns:</p> Type Description <code>OpportunityAssociations</code> <p>OpportunityAssociations named tuple with person_ids and company_ids</p> Example <p>assoc = await client.opportunities.get_associations(opp_id) print(assoc.person_ids)   # IDE autocomplete works print(assoc.company_ids)  # IDE autocomplete works</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_associations(\n    self,\n    opportunity_id: OpportunityId,\n) -&gt; OpportunityAssociations:\n    \"\"\"\n    Get both person and company associations in a single V1 call.\n\n    Use this when you need both types of associations to avoid\n    duplicate API calls from separate get_associated_*_ids() calls.\n\n    Args:\n        opportunity_id: The opportunity ID\n\n    Returns:\n        OpportunityAssociations named tuple with person_ids and company_ids\n\n    Example:\n        assoc = await client.opportunities.get_associations(opp_id)\n        print(assoc.person_ids)   # IDE autocomplete works\n        print(assoc.company_ids)  # IDE autocomplete works\n    \"\"\"\n    data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    # Defensive: V1 returns directly (not wrapped), but handle potential wrapper\n    opportunity = data.get(\"opportunity\") if isinstance(data, dict) else None\n    source = opportunity if isinstance(opportunity, dict) else data\n\n    person_ids: builtins.list[PersonId] = []\n    company_ids: builtins.list[CompanyId] = []\n\n    if isinstance(source, dict):\n        raw_person_ids = source.get(\"person_ids\") or source.get(\"personIds\")\n        raw_company_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n        if isinstance(raw_person_ids, list):\n            person_ids = [PersonId(int(pid)) for pid in raw_person_ids if pid is not None]\n        if isinstance(raw_company_ids, list):\n            company_ids = [CompanyId(int(cid)) for cid in raw_company_ids if cid is not None]\n\n    return OpportunityAssociations(person_ids=person_ids, company_ids=company_ids)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.get_details","title":"<code>get_details(opportunity_id: OpportunityId) -&gt; Opportunity</code>  <code>async</code>","text":"<p>Get a single opportunity by ID with a more complete representation.</p> <p>Includes association IDs and (when present) list entries, which are not always included in the default <code>get()</code> response.</p> See Also <ul> <li>:meth:<code>get_associated_person_ids</code>: Get just person IDs (single API call)</li> <li>:meth:<code>get_associated_people</code>: Get full Person objects</li> <li>:meth:<code>get_associated_company_ids</code>: Get just company IDs (single API call)</li> <li>:meth:<code>get_associated_companies</code>: Get full Company objects</li> <li>:meth:<code>get_associations</code>: Get both person and company IDs in one call</li> </ul> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def get_details(self, opportunity_id: OpportunityId) -&gt; Opportunity:\n    \"\"\"\n    Get a single opportunity by ID with a more complete representation.\n\n    Includes association IDs and (when present) list entries, which are not\n    always included in the default `get()` response.\n\n    See Also:\n        - :meth:`get_associated_person_ids`: Get just person IDs (single API call)\n        - :meth:`get_associated_people`: Get full Person objects\n        - :meth:`get_associated_company_ids`: Get just company IDs (single API call)\n        - :meth:`get_associated_companies`: Get full Company objects\n        - :meth:`get_associations`: Get both person and company IDs in one call\n    \"\"\"\n    # Uses the v1 endpoint because it returns a fuller payload (including\n    # association IDs and, when present, list entries).\n    data = await self._client.get(f\"/opportunities/{opportunity_id}\", v1=True)\n    return Opportunity.model_validate(data)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.iter","title":"<code>iter(*, ids: Sequence[OpportunityId] | None = None) -&gt; AsyncIterator[Opportunity]</code>","text":"<p>Auto-paginate all opportunities.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>def iter(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n) -&gt; AsyncIterator[Opportunity]:\n    \"\"\"\n    Auto-paginate all opportunities.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all(ids=ids)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.list","title":"<code>list(*, ids: Sequence[OpportunityId] | None = None, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[Opportunity]</code>  <code>async</code>","text":"<p>List all opportunities.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[OpportunityId] | None</code> <p>Specific opportunity IDs to fetch (batch lookup)</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses)</p> <code>None</code> <p>Returns the v2 opportunity representation (which may be partial). For full opportunity row data, use list entries explicitly.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def list(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[Opportunity]:\n    \"\"\"\n    List all opportunities.\n\n    Args:\n        ids: Specific opportunity IDs to fetch (batch lookup)\n        limit: Maximum number of results per page\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n    Returns the v2 opportunity representation (which may be partial).\n    For full opportunity row data, use list entries explicitly.\n    \"\"\"\n    if cursor is not None:\n        if ids is not None or limit is not None:\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = await self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if ids:\n            params[\"ids\"] = [int(id_) for id_ in ids]\n        if limit is not None:\n            params[\"limit\"] = limit\n        data = await self._client.get(\"/opportunities\", params=params or None)\n\n    return PaginatedResponse[Opportunity](\n        data=[Opportunity.model_validate(item) for item in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.pages","title":"<code>pages(*, ids: Sequence[OpportunityId] | None = None, limit: int | None = None, cursor: str | None = None) -&gt; AsyncIterator[PaginatedResponse[Opportunity]]</code>  <code>async</code>","text":"<p>Iterate opportunity pages (not items), yielding <code>PaginatedResponse[Opportunity]</code>.</p> <p>This is useful for ETL scripts that want checkpoint/resume via <code>page.next_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[OpportunityId] | None</code> <p>Specific opportunity IDs to fetch (batch lookup)</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination</p> <code>None</code> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def pages(\n    self,\n    *,\n    ids: Sequence[OpportunityId] | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[Opportunity]]:\n    \"\"\"\n    Iterate opportunity pages (not items), yielding `PaginatedResponse[Opportunity]`.\n\n    This is useful for ETL scripts that want checkpoint/resume via `page.next_cursor`.\n\n    Args:\n        ids: Specific opportunity IDs to fetch (batch lookup)\n        limit: Maximum results per page\n        cursor: Cursor to resume pagination\n    \"\"\"\n    other_params = (ids, limit)\n    if cursor is not None and any(p is not None for p in other_params):\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = (\n        await self.list(cursor=cursor)\n        if cursor is not None\n        else await self.list(ids=ids, limit=limit)\n    )\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = await self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.resolve","title":"<code>resolve(*, name: str, list_id: ListId, limit: int | None = None) -&gt; Opportunity | None</code>  <code>async</code>","text":"<p>Find a single opportunity by exact name within a specific list.</p> <p>Notes: - Opportunities are list-scoped; a list id is required. - This iterates list-entry pages client-side (no dedicated search endpoint). - If multiple matches exist, returns the first match in server-provided order.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def resolve(\n    self,\n    *,\n    name: str,\n    list_id: ListId,\n    limit: int | None = None,\n) -&gt; Opportunity | None:\n    \"\"\"\n    Find a single opportunity by exact name within a specific list.\n\n    Notes:\n    - Opportunities are list-scoped; a list id is required.\n    - This iterates list-entry pages client-side (no dedicated search endpoint).\n    - If multiple matches exist, returns the first match in server-provided order.\n    \"\"\"\n    name = name.strip()\n    if not name:\n        raise ValueError(\"Name cannot be empty\")\n    name_lower = name.lower()\n\n    entries = AsyncListEntryService(self._client, list_id)\n    async for page in entries.pages(limit=limit):\n        for entry in page.data:\n            entity = entry.entity\n            if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                return entity\n    return None\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.resolve_all","title":"<code>resolve_all(*, name: str, list_id: ListId, limit: int | None = None) -&gt; builtins.list[Opportunity]</code>  <code>async</code>","text":"<p>Find all opportunities matching a name within a specific list.</p> <p>Notes: - Opportunities are list-scoped; a list id is required. - This iterates list-entry pages client-side (no dedicated search endpoint).</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def resolve_all(\n    self,\n    *,\n    name: str,\n    list_id: ListId,\n    limit: int | None = None,\n) -&gt; builtins.list[Opportunity]:\n    \"\"\"\n    Find all opportunities matching a name within a specific list.\n\n    Notes:\n    - Opportunities are list-scoped; a list id is required.\n    - This iterates list-entry pages client-side (no dedicated search endpoint).\n    \"\"\"\n    name = name.strip()\n    if not name:\n        raise ValueError(\"Name cannot be empty\")\n    name_lower = name.lower()\n    matches: builtins.list[Opportunity] = []\n\n    entries = AsyncListEntryService(self._client, list_id)\n    async for page in entries.pages(limit=limit):\n        for entry in page.data:\n            entity = entry.entity\n            if isinstance(entity, Opportunity) and entity.name.lower() == name_lower:\n                matches.append(entity)\n    return matches\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.search","title":"<code>search(term: str | None = None, *, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Opportunity]</code>  <code>async</code>","text":"<p>Search for opportunities by name.</p> <p>Uses V1 API for search functionality.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str | None</code> <p>Search term (matches opportunity name). If None, returns all.</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Pagination token</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Opportunity]</code> <p>PaginatedResponse with opportunities and next_page_token</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def search(\n    self,\n    term: str | None = None,\n    *,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Opportunity]:\n    \"\"\"\n    Search for opportunities by name.\n\n    Uses V1 API for search functionality.\n\n    Args:\n        term: Search term (matches opportunity name). If None, returns all.\n        page_size: Results per page (max 500)\n        page_token: Pagination token\n\n    Returns:\n        PaginatedResponse with opportunities and next_page_token\n    \"\"\"\n    params: dict[str, Any] = {}\n    if term:\n        params[\"term\"] = term\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = await self._client.get(\"/opportunities\", params=params, v1=True)\n    items = [Opportunity.model_validate(o) for o in data.get(\"opportunities\", [])]\n    return PaginatedResponse[Opportunity](\n        data=items,\n        next_page_token=data.get(\"next_page_token\"),\n    )\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.search_all","title":"<code>search_all(term: str | None = None, *, page_size: int | None = None, page_token: str | None = None) -&gt; AsyncIterator[Opportunity]</code>  <code>async</code>","text":"<p>Iterate all V1 opportunity-search results with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str | None</code> <p>Search term (matches opportunity name). If None, returns all.</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Opportunity]</code> <p>Each Opportunity individually</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def search_all(\n    self,\n    term: str | None = None,\n    *,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; AsyncIterator[Opportunity]:\n    \"\"\"\n    Iterate all V1 opportunity-search results with automatic pagination.\n\n    Args:\n        term: Search term (matches opportunity name). If None, returns all.\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        Each Opportunity individually\n    \"\"\"\n    async for page in self.search_pages(term, page_size=page_size, page_token=page_token):\n        for opp in page.data:\n            yield opp\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.search_pages","title":"<code>search_pages(term: str | None = None, *, page_size: int | None = None, page_token: str | None = None) -&gt; AsyncIterator[PaginatedResponse[Opportunity]]</code>  <code>async</code>","text":"<p>Iterate V1 opportunity-search result pages.</p> <p>Useful for scripts that need checkpoint/resume via <code>next_page_token</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str | None</code> <p>Search term (matches opportunity name). If None, returns all.</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[PaginatedResponse[Opportunity]]</code> <p>PaginatedResponse[Opportunity] for each page</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def search_pages(\n    self,\n    term: str | None = None,\n    *,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[Opportunity]]:\n    \"\"\"\n    Iterate V1 opportunity-search result pages.\n\n    Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n    Args:\n        term: Search term (matches opportunity name). If None, returns all.\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        PaginatedResponse[Opportunity] for each page\n    \"\"\"\n    requested_token = page_token\n    page = await self.search(term, page_size=page_size, page_token=page_token)\n    while True:\n        yield page\n        next_token = page.next_page_token\n        if not next_token or next_token == requested_token:\n            return\n        requested_token = next_token\n        page = await self.search(term, page_size=page_size, page_token=next_token)\n</code></pre>"},{"location":"reference/services/opportunities/#affinity.services.opportunities.AsyncOpportunityService.update","title":"<code>update(opportunity_id: OpportunityId, data: OpportunityUpdate) -&gt; Opportunity</code>  <code>async</code>","text":"<p>Update an existing opportunity.</p> <p>Note: When provided, <code>person_ids</code> and <code>company_ids</code> replace the existing values. To add or remove associations safely, pass the full desired arrays.</p> Source code in <code>affinity/services/opportunities.py</code> <pre><code>async def update(self, opportunity_id: OpportunityId, data: OpportunityUpdate) -&gt; Opportunity:\n    \"\"\"\n    Update an existing opportunity.\n\n    Note: When provided, `person_ids` and `company_ids` replace the existing\n    values. To add or remove associations safely, pass the full desired arrays.\n    \"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"json\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n\n    # Uses the v1 endpoint; its PUT semantics replace association arrays.\n    result = await self._client.put(f\"/opportunities/{opportunity_id}\", json=payload, v1=True)\n    return Opportunity.model_validate(result)\n</code></pre>"},{"location":"reference/services/persons/","title":"Persons","text":""},{"location":"reference/services/persons/#interaction-dates","title":"Interaction Dates","text":"<p>The <code>get()</code> method supports fetching interaction date summaries for a person using the <code>with_interaction_dates</code> parameter. When enabled, the returned <code>Person</code> object will have its <code>interaction_dates</code> and <code>interactions</code> fields populated with:</p> <ul> <li>Last meeting date: When the last calendar event with this person occurred</li> <li>Next meeting date: When the next scheduled calendar event is</li> <li>Last email date: When the last email exchange happened</li> <li>Last interaction date: The most recent interaction of any type</li> </ul> <pre><code>from affinity import Affinity\nfrom affinity.types import PersonId\n\nwith Affinity(api_key=\"YOUR_API_KEY\") as client:\n    # Fetch person with interaction dates\n    person = client.persons.get(\n        PersonId(456),\n        with_interaction_dates=True,\n        with_interaction_persons=True,  # Include person IDs for each interaction\n    )\n\n    # Access interaction data\n    if person.interaction_dates:\n        print(f\"Last meeting: {person.interaction_dates.last_event_date}\")\n        print(f\"Next meeting: {person.interaction_dates.next_event_date}\")\n        print(f\"Last email: {person.interaction_dates.last_email_date}\")\n\n    # Access team member IDs from interactions\n    if person.interactions and person.interactions.last_event:\n        team_ids = person.interactions.last_event.person_ids\n        print(f\"Last meeting attendees: {team_ids}\")\n</code></pre> <p>Service for managing persons (contacts).</p> <p>Uses V2 API for efficient reading with field selection, V1 API for create/update/delete operations.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>class PersonService:\n    \"\"\"\n    Service for managing persons (contacts).\n\n    Uses V2 API for efficient reading with field selection,\n    V1 API for create/update/delete operations.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    # =========================================================================\n    # Read Operations (V2 API)\n    # =========================================================================\n\n    def list(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[Person]:\n        \"\"\"\n        Get a page of persons.\n\n        Args:\n            ids: Specific person IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include\n            filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n            limit: Maximum number of results\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n        Returns:\n            Paginated response with persons\n        \"\"\"\n        if cursor is not None:\n            if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if ids:\n                params[\"ids\"] = [int(id_) for id_ in ids]\n            if field_ids:\n                params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n            if field_types:\n                params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n            if filter is not None:\n                filter_text = str(filter).strip()\n                if filter_text:\n                    params[\"filter\"] = filter_text\n            if limit:\n                params[\"limit\"] = limit\n            data = self._client.get(\"/persons\", params=params or None)\n\n        return PaginatedResponse[Person](\n            data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    def pages(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[Person]]:\n        \"\"\"\n        Iterate person pages (not items), yielding `PaginatedResponse[Person]`.\n\n        Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n        Args:\n            ids: Specific person IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include\n            filter: V2 filter expression string or FilterExpression\n            limit: Maximum results per page\n            cursor: Cursor to resume pagination\n\n        Yields:\n            PaginatedResponse[Person] for each page\n        \"\"\"\n        other_params = (ids, field_ids, field_types, filter, limit)\n        if cursor is not None and any(p is not None for p in other_params):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        page = (\n            self.list(cursor=cursor)\n            if cursor is not None\n            else self.list(\n                ids=ids, field_ids=field_ids, field_types=field_types, filter=filter, limit=limit\n            )\n        )\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = self.list(cursor=next_cursor)\n\n    def all(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; Iterator[Person]:\n        \"\"\"\n        Iterate through all persons with automatic pagination.\n\n        Args:\n            ids: Specific person IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include\n            field_types: Field types to include\n            filter: V2 filter expression\n\n        Yields:\n            Person objects\n        \"\"\"\n\n        def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Person]:\n            if next_url:\n                data = self._client.get_url(next_url)\n                return PaginatedResponse[Person](\n                    data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n                    pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n                )\n            return self.list(\n                ids=ids,\n                field_ids=field_ids,\n                field_types=field_types,\n                filter=filter,\n            )\n\n        return PageIterator(fetch_page)\n\n    def iter(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; Iterator[Person]:\n        \"\"\"\n        Auto-paginate all persons.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n\n    def get(\n        self,\n        person_id: PersonId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        include_field_values: bool = False,\n        retries: int = 0,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Person:\n        \"\"\"\n        Get a single person by ID.\n\n        Args:\n            person_id: The person ID\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            include_field_values: If True, fetch embedded field values. This saves\n                one API call when you need both person info and field values.\n                Cannot be combined with field_ids/field_types.\n            retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n                Set to 2-3 if calling immediately after create() to handle eventual\n                consistency lag.\n            with_interaction_dates: Include interaction date summaries (last/next\n                meeting dates, email dates).\n            with_interaction_persons: Include person IDs for each interaction.\n                Only applies when with_interaction_dates=True.\n\n        Returns:\n            Person object with requested field data.\n            When include_field_values=True, the Person will have a `field_values`\n            attribute containing the list of FieldValue objects.\n            When with_interaction_dates=True, the Person will have interaction_dates\n            and interactions populated.\n\n        Raises:\n            NotFoundError: If person does not exist after all retries.\n            ValueError: If include_field_values is combined with field_ids/field_types.\n\n        Note:\n            When combining with_interaction_dates with field_ids/field_types,\n            two API calls are made internally and the results are merged.\n        \"\"\"\n        return self._get_with_retry(\n            person_id,\n            field_ids=field_ids,\n            field_types=field_types,\n            include_field_values=include_field_values,\n            retries=retries,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n        )\n\n    def _get_with_retry(\n        self,\n        person_id: PersonId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        include_field_values: bool = False,\n        retries: int = 0,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Person:\n        \"\"\"Internal: get with retry logic.\"\"\"\n        last_error: NotFoundError | None = None\n        attempts = retries + 1  # retries=0 means 1 attempt\n\n        for attempt in range(attempts):\n            try:\n                return self._get_impl(\n                    person_id,\n                    field_ids=field_ids,\n                    field_types=field_types,\n                    include_field_values=include_field_values,\n                    with_interaction_dates=with_interaction_dates,\n                    with_interaction_persons=with_interaction_persons,\n                )\n            except NotFoundError as e:\n                last_error = e\n                if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                    time.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n        # V1 fallback: If V2 returned 404, try V1 API (handles V1\u2192V2 sync delays)\n        # Skip if already using V1 path (include_field_values or with_interaction_dates)\n        if last_error is not None and not include_field_values and not with_interaction_dates:\n            try:\n                v1_data = self._client.get(f\"/persons/{person_id}\", v1=True)\n                normalized = _normalize_v1_person_response(v1_data)\n                return Person.model_validate(normalized)\n            except NotFoundError:\n                pass  # V1 also failed, raise original V2 error\n\n        raise last_error  # type: ignore[misc]\n\n    def _get_impl(\n        self,\n        person_id: PersonId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        include_field_values: bool = False,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Person:\n        \"\"\"Internal: actual get implementation.\"\"\"\n        has_field_filters = field_ids is not None or field_types is not None\n\n        # include_field_values returns embedded field values, which is incompatible\n        # with field_ids/field_types filtering (different data structures)\n        if include_field_values and has_field_filters:\n            raise ValueError(\n                \"Cannot combine 'include_field_values' with 'field_ids' or 'field_types'. \"\n                \"Use include_field_values alone for embedded field values, or use \"\n                \"field_ids/field_types alone for filtered fields.\"\n            )\n\n        # Path 1: include_field_values (V1 API, may include interaction dates)\n        if include_field_values:\n            v1_params: dict[str, Any] = {}\n            if with_interaction_dates:\n                v1_params[\"with_interaction_dates\"] = True\n            if with_interaction_persons:\n                v1_params[\"with_interaction_persons\"] = True\n\n            data = self._client.get(\n                f\"/persons/{person_id}\",\n                params=v1_params or None,\n                v1=True,\n            )\n\n            field_values_data = data.get(\"field_values\", [])\n            # V1 embedded field_values don't include entityId; add it before validation\n            field_values = [\n                FieldValue.model_validate({**fv, \"entityId\": int(person_id)})\n                for fv in field_values_data\n            ]\n            normalized = _normalize_v1_person_response(data)\n            person = Person.model_validate(normalized)\n            object.__setattr__(person, \"field_values\", field_values)\n            return person\n\n        # Path 2: with_interaction_dates (may need merge if field filters present)\n        if with_interaction_dates:\n            v1_params = {\"with_interaction_dates\": True}\n            if with_interaction_persons:\n                v1_params[\"with_interaction_persons\"] = True\n\n            interaction_data = self._client.get(\n                f\"/persons/{person_id}\",\n                params=v1_params,\n                v1=True,\n            )\n\n            # If field filtering is also requested, fetch filtered fields and merge\n            if has_field_filters:\n                v2_params: dict[str, Any] = {}\n                if field_ids:\n                    v2_params[\"fieldIds\"] = [str(fid) for fid in field_ids]\n                if field_types:\n                    v2_params[\"fieldTypes\"] = [ft.value for ft in field_types]\n\n                filtered_data = self._client.get(\n                    f\"/persons/{person_id}\",\n                    params=v2_params,\n                )\n\n                # Merge: filtered fields + interaction data\n                filtered_data[\"interaction_dates\"] = interaction_data.get(\"interaction_dates\")\n                filtered_data[\"interactions\"] = interaction_data.get(\"interactions\")\n                return Person.model_validate(filtered_data)\n\n            # No field filtering, normalize and return V1 data\n            normalized = _normalize_v1_person_response(interaction_data)\n            return Person.model_validate(normalized)\n\n        # Path 3: Standard path (supports field filtering)\n        params: dict[str, Any] = {}\n        if field_ids:\n            params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = self._client.get(\n            f\"/persons/{person_id}\",\n            params=params or None,\n        )\n        return Person.model_validate(data)\n\n    def get_list_entries(\n        self,\n        person_id: PersonId,\n    ) -&gt; PaginatedResponse[ListEntry]:\n        \"\"\"Get all list entries for a person across all lists.\"\"\"\n        data = self._client.get(f\"/persons/{person_id}/list-entries\")\n\n        return PaginatedResponse[ListEntry](\n            data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    def get_lists(\n        self,\n        person_id: PersonId,\n    ) -&gt; PaginatedResponse[ListSummary]:\n        \"\"\"Get all lists that contain this person.\"\"\"\n        data = self._client.get(f\"/persons/{person_id}/lists\")\n\n        return PaginatedResponse[ListSummary](\n            data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    def get_fields(\n        self,\n        *,\n        field_types: Sequence[FieldType] | None = None,\n    ) -&gt; builtins.list[FieldMetadata]:\n        \"\"\"\n        Get metadata about person fields.\n\n        Cached for performance.\n        \"\"\"\n        params: dict[str, Any] = {}\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = self._client.get(\n            \"/persons/fields\",\n            params=params or None,\n            cache_key=f\"person_fields:{','.join(field_types or [])}\",\n            cache_ttl=300,\n        )\n\n        return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n\n    # =========================================================================\n    # Associations (V1 API)\n    # =========================================================================\n\n    def get_associated_company_ids(\n        self,\n        person_id: PersonId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[CompanyId]:\n        \"\"\"\n        Get associated company IDs for a person.\n\n        V1-only: V2 does not expose person -&gt; company associations directly.\n        Uses GET `/persons/{id}` (V1) and returns `organization_ids`.\n\n        Args:\n            person_id: The person ID\n            max_results: Maximum number of company IDs to return\n\n        Returns:\n            List of CompanyId values associated with this person\n\n        Note:\n            The Person model already has `company_ids` populated from V1's\n            `organizationIds` field. This method provides API parity with\n            `CompanyService.get_associated_person_ids()`.\n        \"\"\"\n        data = self._client.get(f\"/persons/{person_id}\", v1=True)\n        # Defensive: handle potential {\"person\": {...}} wrapper\n        # (consistent with CompanyService.get_associated_person_ids pattern)\n        person = data.get(\"person\") if isinstance(data, dict) else None\n        source = person if isinstance(person, dict) else data\n        org_ids = None\n        if isinstance(source, dict):\n            org_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n        if not isinstance(org_ids, list):\n            return []\n\n        ids = [CompanyId(int(cid)) for cid in org_ids if cid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    def get_associated_company_ids_batch(\n        self,\n        person_ids: Sequence[PersonId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[PersonId, builtins.list[CompanyId]]:\n        \"\"\"\n        Get company associations for multiple persons.\n\n        Makes one V1 API call per person.\n\n        Args:\n            person_ids: Sequence of person IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping person_id -&gt; list of company_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n\n        Example:\n            associations = client.persons.get_associated_company_ids_batch(person_ids)\n            all_company_ids = set()\n            for company_ids in associations.values():\n                all_company_ids.update(company_ids)\n        \"\"\"\n        result: dict[PersonId, builtins.list[CompanyId]] = {}\n        for person_id in person_ids:\n            try:\n                result[person_id] = self.get_associated_company_ids(person_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this person\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for person {person_id}: {e}\"\n                    ) from e\n                # skip: continue without this person\n        return result\n\n    def get_associated_opportunity_ids(\n        self,\n        person_id: PersonId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[OpportunityId]:\n        \"\"\"\n        Get associated opportunity IDs for a person.\n\n        V1-only: V2 does not expose person -&gt; opportunity associations directly.\n        Uses GET `/persons/{id}` (V1) and returns `opportunity_ids`.\n\n        Args:\n            person_id: The person ID\n            max_results: Maximum number of opportunity IDs to return\n\n        Returns:\n            List of OpportunityId values associated with this person\n\n        Note:\n            The Person model already has `opportunity_ids` populated from V1's\n            `opportunityIds` field. This method provides API parity with\n            `OpportunityService.get_associated_person_ids()`.\n        \"\"\"\n        data = self._client.get(f\"/persons/{person_id}\", v1=True)\n        # Defensive: handle potential {\"person\": {...}} wrapper\n        person = data.get(\"person\") if isinstance(data, dict) else None\n        source = person if isinstance(person, dict) else data\n        opp_ids = None\n        if isinstance(source, dict):\n            opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n        if not isinstance(opp_ids, list):\n            return []\n\n        ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    def get_associated_opportunity_ids_batch(\n        self,\n        person_ids: Sequence[PersonId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[PersonId, builtins.list[OpportunityId]]:\n        \"\"\"\n        Get opportunity associations for multiple persons.\n\n        Makes one V1 API call per person.\n\n        Args:\n            person_ids: Sequence of person IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping person_id -&gt; list of opportunity_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n        \"\"\"\n        result: dict[PersonId, builtins.list[OpportunityId]] = {}\n        for person_id in person_ids:\n            try:\n                result[person_id] = self.get_associated_opportunity_ids(person_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this person\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for person {person_id}: {e}\"\n                    ) from e\n                # skip: continue without this person\n        return result\n\n    # =========================================================================\n    # Search (V1 API)\n    # =========================================================================\n\n    def search(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Person]:\n        \"\"\"\n        Search for persons by name or email.\n\n        Uses V1 API for search functionality.\n\n        Args:\n            term: Search term (name or email)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Pagination token\n\n        Returns:\n            PaginatedResponse[Person] with matching persons and pagination info\n        \"\"\"\n        params: dict[str, Any] = {\"term\": term}\n        if with_interaction_dates:\n            params[\"with_interaction_dates\"] = True\n        if with_interaction_persons:\n            params[\"with_interaction_persons\"] = True\n        if with_opportunities:\n            params[\"with_opportunities\"] = True\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = self._client.get(\"/persons\", params=params, v1=True)\n        items = [Person.model_validate(p) for p in data.get(\"persons\", [])]\n        return PaginatedResponse[Person](\n            data=items,\n            next_page_token=data.get(\"next_page_token\"),\n        )\n\n    def search_pages(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; Iterator[PaginatedResponse[Person]]:\n        \"\"\"\n        Iterate V1 person-search result pages.\n\n        Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n        Args:\n            term: Search term (name or email)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            PaginatedResponse[Person] for each page\n        \"\"\"\n        requested_token = page_token\n        page = self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        )\n        while True:\n            yield page\n            next_token = page.next_page_token\n            if not next_token or next_token == requested_token:\n                return\n            requested_token = next_token\n            page = self.search(\n                term,\n                with_interaction_dates=with_interaction_dates,\n                with_interaction_persons=with_interaction_persons,\n                with_opportunities=with_opportunities,\n                page_size=page_size,\n                page_token=next_token,\n            )\n\n    def search_all(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; Iterator[Person]:\n        \"\"\"\n        Iterate all V1 person-search results with automatic pagination.\n\n        Args:\n            term: Search term (name or email)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            Person objects matching the search term\n        \"\"\"\n        for page in self.search_pages(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        ):\n            yield from page.data\n\n    def resolve(\n        self,\n        *,\n        email: str | None = None,\n        name: str | None = None,\n    ) -&gt; Person | None:\n        \"\"\"\n        Find a single person by email or name.\n\n        This is a convenience helper that searches and returns the first exact match,\n        or None if not found. Uses V1 search internally.\n\n        Args:\n            email: Email address to search for\n            name: Person name to search for (first + last)\n\n        Returns:\n            The matching Person, or None if not found\n\n        Raises:\n            ValueError: If neither email nor name is provided\n\n        Note:\n            This auto-paginates V1 search results until a match is found.\n            If multiple matches are found, returns the first one. For full\n            disambiguation, use resolve_all() or search() directly.\n        \"\"\"\n        if not email and not name:\n            raise ValueError(\"Must provide either email or name\")\n\n        term = email or name or \"\"\n        for page in self.search_pages(term, page_size=10):\n            for person in page.data:\n                if _person_matches(person, email=email, name=name):\n                    return person\n\n        return None\n\n    def resolve_all(\n        self,\n        *,\n        email: str | None = None,\n        name: str | None = None,\n    ) -&gt; builtins.list[Person]:\n        \"\"\"\n        Find all persons matching an email or name.\n\n        Notes:\n        - This auto-paginates V1 search results to collect exact matches.\n        - Unlike resolve(), this returns every match in server-provided order.\n        \"\"\"\n        if not email and not name:\n            raise ValueError(\"Must provide either email or name\")\n\n        term = email or name or \"\"\n        matches: builtins.list[Person] = []\n        for page in self.search_pages(term, page_size=10):\n            for person in page.data:\n                if _person_matches(person, email=email, name=name):\n                    matches.append(person)\n        return matches\n\n    # =========================================================================\n    # Write Operations (V1 API)\n    # =========================================================================\n\n    def create(self, data: PersonCreate) -&gt; Person:\n        \"\"\"\n        Create a new person.\n\n        Note:\n            Creates use V1 API, while reads use V2 API. Due to eventual consistency\n            between V1 and V2, a `get()` call immediately after `create()` may return\n            404 NotFoundError. If you need to read immediately after creation, either:\n            - Use the Person object returned by this method (it contains the created data)\n            - Add a short delay (100-500ms) before calling get()\n            - Implement retry logic in your application\n\n        Raises:\n            ValidationError: If email conflicts with existing person\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"json\")\n        if not data.company_ids:\n            payload.pop(\"organization_ids\", None)\n\n        result = self._client.post(\"/persons\", json=payload, v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"person\")\n\n        return Person.model_validate(result)\n\n    def update(\n        self,\n        person_id: PersonId,\n        data: PersonUpdate,\n    ) -&gt; Person:\n        \"\"\"\n        Update an existing person.\n\n        Note: To add emails/organizations, include existing values plus new ones.\n        \"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"json\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n\n        result = self._client.put(\n            f\"/persons/{person_id}\",\n            json=payload,\n            v1=True,\n        )\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"person\")\n\n        return Person.model_validate(result)\n\n    def delete(self, person_id: PersonId) -&gt; bool:\n        \"\"\"Delete a person (also deletes associated field values).\"\"\"\n        result = self._client.delete(f\"/persons/{person_id}\", v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"person\")\n\n        return bool(result.get(\"success\", False))\n\n    # =========================================================================\n    # Merge Operations (V2 BETA)\n    # =========================================================================\n\n    def merge(\n        self,\n        primary_id: PersonId,\n        duplicate_id: PersonId,\n    ) -&gt; str:\n        \"\"\"\n        Merge a duplicate person into a primary person.\n\n        Returns a task URL to check merge status.\n        \"\"\"\n        if not self._client.enable_beta_endpoints:\n            raise BetaEndpointDisabledError(\n                \"Person merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n            )\n        result = self._client.post(\n            \"/person-merges\",\n            json={\n                \"primaryPersonId\": int(primary_id),\n                \"duplicatePersonId\": int(duplicate_id),\n            },\n        )\n        return str(result.get(\"taskUrl\", \"\"))\n\n    def get_merge_status(self, task_id: str) -&gt; MergeTask:\n        \"\"\"Check the status of a merge operation.\"\"\"\n        data = self._client.get(f\"/tasks/person-merges/{task_id}\")\n        return MergeTask.model_validate(data)\n</code></pre> <p>Async version of PersonService.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>class AsyncPersonService:\n    \"\"\"Async version of PersonService.\"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        self._client = client\n\n    async def list(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; PaginatedResponse[Person]:\n        \"\"\"\n        Get a page of persons.\n\n        Args:\n            ids: Specific person IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include\n            filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n            limit: Maximum number of results\n            cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n        Returns:\n            Paginated response with persons\n        \"\"\"\n        if cursor is not None:\n            if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n                raise ValueError(\n                    \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                    \"context. Start a new pagination sequence without a cursor to change \"\n                    \"parameters.\"\n                )\n            data = await self._client.get_url(cursor)\n        else:\n            params: dict[str, Any] = {}\n            if ids:\n                params[\"ids\"] = [int(id_) for id_ in ids]\n            if field_ids:\n                params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n            if field_types:\n                params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n            if filter is not None:\n                filter_text = str(filter).strip()\n                if filter_text:\n                    params[\"filter\"] = filter_text\n            if limit:\n                params[\"limit\"] = limit\n            data = await self._client.get(\"/persons\", params=params or None)\n\n        return PaginatedResponse[Person](\n            data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    async def pages(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n        limit: int | None = None,\n        cursor: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[Person]]:\n        \"\"\"\n        Iterate person pages (not items), yielding `PaginatedResponse[Person]`.\n\n        Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n        Args:\n            ids: Specific person IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include\n            filter: V2 filter expression string or FilterExpression\n            limit: Maximum results per page\n            cursor: Cursor to resume pagination\n\n        Yields:\n            PaginatedResponse[Person] for each page\n        \"\"\"\n        other_params = (ids, field_ids, field_types, filter, limit)\n        if cursor is not None and any(p is not None for p in other_params):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n                \"Start a new pagination sequence without a cursor to change parameters.\"\n            )\n        requested_cursor = cursor\n        if cursor is not None:\n            page = await self.list(cursor=cursor)\n        else:\n            page = await self.list(\n                ids=ids,\n                field_ids=field_ids,\n                field_types=field_types,\n                filter=filter,\n                limit=limit,\n            )\n        while True:\n            yield page\n            if not page.has_next:\n                return\n            next_cursor = page.next_cursor\n            if next_cursor is None or next_cursor == requested_cursor:\n                return\n            requested_cursor = next_cursor\n            page = await self.list(cursor=next_cursor)\n\n    def all(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; AsyncIterator[Person]:\n        \"\"\"\n        Iterate through all persons with automatic pagination.\n\n        Args:\n            ids: Specific person IDs to fetch (batch lookup)\n            field_ids: Specific field IDs to include\n            field_types: Field types to include\n            filter: V2 filter expression\n\n        Yields:\n            Person objects\n        \"\"\"\n\n        async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Person]:\n            if next_url:\n                data = await self._client.get_url(next_url)\n                return PaginatedResponse[Person](\n                    data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n                    pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n                )\n            return await self.list(\n                ids=ids, field_ids=field_ids, field_types=field_types, filter=filter\n            )\n\n        return AsyncPageIterator(fetch_page)\n\n    def iter(\n        self,\n        *,\n        ids: Sequence[PersonId] | None = None,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        filter: str | FilterExpression | None = None,\n    ) -&gt; AsyncIterator[Person]:\n        \"\"\"\n        Auto-paginate all persons.\n\n        Alias for `all()` (FR-006 public contract).\n        \"\"\"\n        return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n\n    async def get(\n        self,\n        person_id: PersonId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        include_field_values: bool = False,\n        retries: int = 0,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Person:\n        \"\"\"\n        Get a single person by ID.\n\n        Args:\n            person_id: The person ID\n            field_ids: Specific field IDs to include in response\n            field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n            include_field_values: If True, fetch embedded field values. This saves\n                one API call when you need both person info and field values.\n                Cannot be combined with field_ids/field_types.\n            retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n                Set to 2-3 if calling immediately after create() to handle eventual\n                consistency lag.\n            with_interaction_dates: Include interaction date summaries (last/next\n                meeting dates, email dates).\n            with_interaction_persons: Include person IDs for each interaction.\n                Only applies when with_interaction_dates=True.\n\n        Returns:\n            Person object with requested field data.\n            When include_field_values=True, the Person will have a `field_values`\n            attribute containing the list of FieldValue objects.\n            When with_interaction_dates=True, the Person will have interaction_dates\n            and interactions populated.\n\n        Raises:\n            NotFoundError: If person does not exist after all retries.\n            ValueError: If include_field_values is combined with field_ids/field_types.\n\n        Note:\n            When combining with_interaction_dates with field_ids/field_types,\n            two API calls are made internally and the results are merged.\n        \"\"\"\n        return await self._get_with_retry(\n            person_id,\n            field_ids=field_ids,\n            field_types=field_types,\n            include_field_values=include_field_values,\n            retries=retries,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n        )\n\n    async def _get_with_retry(\n        self,\n        person_id: PersonId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        include_field_values: bool = False,\n        retries: int = 0,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Person:\n        \"\"\"Internal: get with retry logic.\"\"\"\n        last_error: NotFoundError | None = None\n        attempts = retries + 1  # retries=0 means 1 attempt\n\n        for attempt in range(attempts):\n            try:\n                return await self._get_impl(\n                    person_id,\n                    field_ids=field_ids,\n                    field_types=field_types,\n                    include_field_values=include_field_values,\n                    with_interaction_dates=with_interaction_dates,\n                    with_interaction_persons=with_interaction_persons,\n                )\n            except NotFoundError as e:\n                last_error = e\n                if attempt &lt; attempts - 1:  # Don't sleep after last attempt\n                    await asyncio.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s backoff\n\n        # V1 fallback: If V2 returned 404, try V1 API (handles V1\u2192V2 sync delays)\n        # Skip if already using V1 path (include_field_values or with_interaction_dates)\n        if last_error is not None and not include_field_values and not with_interaction_dates:\n            try:\n                v1_data = await self._client.get(f\"/persons/{person_id}\", v1=True)\n                normalized = _normalize_v1_person_response(v1_data)\n                return Person.model_validate(normalized)\n            except NotFoundError:\n                pass  # V1 also failed, raise original V2 error\n\n        raise last_error  # type: ignore[misc]\n\n    async def _get_impl(\n        self,\n        person_id: PersonId,\n        *,\n        field_ids: Sequence[AnyFieldId] | None = None,\n        field_types: Sequence[FieldType] | None = None,\n        include_field_values: bool = False,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n    ) -&gt; Person:\n        \"\"\"Internal: actual get implementation.\"\"\"\n        has_field_filters = field_ids is not None or field_types is not None\n\n        # include_field_values returns embedded field values, which is incompatible\n        # with field_ids/field_types filtering (different data structures)\n        if include_field_values and has_field_filters:\n            raise ValueError(\n                \"Cannot combine 'include_field_values' with 'field_ids' or 'field_types'. \"\n                \"Use include_field_values alone for embedded field values, or use \"\n                \"field_ids/field_types alone for filtered fields.\"\n            )\n\n        # Path 1: include_field_values (V1 API, may include interaction dates)\n        if include_field_values:\n            v1_params: dict[str, Any] = {}\n            if with_interaction_dates:\n                v1_params[\"with_interaction_dates\"] = True\n            if with_interaction_persons:\n                v1_params[\"with_interaction_persons\"] = True\n\n            data = await self._client.get(\n                f\"/persons/{person_id}\",\n                params=v1_params or None,\n                v1=True,\n            )\n\n            field_values_data = data.get(\"field_values\", [])\n            # V1 embedded field_values don't include entityId; add it before validation\n            field_values = [\n                FieldValue.model_validate({**fv, \"entityId\": int(person_id)})\n                for fv in field_values_data\n            ]\n            normalized = _normalize_v1_person_response(data)\n            person = Person.model_validate(normalized)\n            object.__setattr__(person, \"field_values\", field_values)\n            return person\n\n        # Path 2: with_interaction_dates (may need merge if field filters present)\n        if with_interaction_dates:\n            v1_params = {\"with_interaction_dates\": True}\n            if with_interaction_persons:\n                v1_params[\"with_interaction_persons\"] = True\n\n            interaction_data = await self._client.get(\n                f\"/persons/{person_id}\",\n                params=v1_params,\n                v1=True,\n            )\n\n            # If field filtering is also requested, fetch filtered fields and merge\n            if has_field_filters:\n                v2_params: dict[str, Any] = {}\n                if field_ids:\n                    v2_params[\"fieldIds\"] = [str(fid) for fid in field_ids]\n                if field_types:\n                    v2_params[\"fieldTypes\"] = [ft.value for ft in field_types]\n\n                filtered_data = await self._client.get(\n                    f\"/persons/{person_id}\",\n                    params=v2_params,\n                )\n\n                # Merge: filtered fields + interaction data\n                filtered_data[\"interaction_dates\"] = interaction_data.get(\"interaction_dates\")\n                filtered_data[\"interactions\"] = interaction_data.get(\"interactions\")\n                return Person.model_validate(filtered_data)\n\n            # No field filtering, normalize and return V1 data\n            normalized = _normalize_v1_person_response(interaction_data)\n            return Person.model_validate(normalized)\n\n        # Path 3: Standard path (supports field filtering)\n        params: dict[str, Any] = {}\n        if field_ids:\n            params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = await self._client.get(f\"/persons/{person_id}\", params=params or None)\n        return Person.model_validate(data)\n\n    async def get_list_entries(\n        self,\n        person_id: PersonId,\n    ) -&gt; PaginatedResponse[ListEntry]:\n        \"\"\"Get all list entries for a person across all lists.\"\"\"\n        data = await self._client.get(f\"/persons/{person_id}/list-entries\")\n\n        return PaginatedResponse[ListEntry](\n            data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    async def get_lists(\n        self,\n        person_id: PersonId,\n    ) -&gt; PaginatedResponse[ListSummary]:\n        \"\"\"Get all lists that contain this person.\"\"\"\n        data = await self._client.get(f\"/persons/{person_id}/lists\")\n\n        return PaginatedResponse[ListSummary](\n            data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n            pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n        )\n\n    async def get_fields(\n        self,\n        *,\n        field_types: Sequence[FieldType] | None = None,\n    ) -&gt; builtins.list[FieldMetadata]:\n        \"\"\"\n        Get metadata about person fields.\n\n        Cached for performance.\n        \"\"\"\n        params: dict[str, Any] = {}\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n        data = await self._client.get(\n            \"/persons/fields\",\n            params=params or None,\n            cache_key=f\"person_fields:{','.join(field_types or [])}\",\n            cache_ttl=300,\n        )\n\n        return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n\n    # =========================================================================\n    # Associations (V1 API)\n    # =========================================================================\n\n    async def get_associated_company_ids(\n        self,\n        person_id: PersonId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[CompanyId]:\n        \"\"\"\n        Get associated company IDs for a person.\n\n        V1-only: V2 does not expose person -&gt; company associations directly.\n        Uses GET `/persons/{id}` (V1) and returns `organization_ids`.\n\n        Args:\n            person_id: The person ID\n            max_results: Maximum number of company IDs to return\n\n        Returns:\n            List of CompanyId values associated with this person\n\n        Note:\n            The Person model already has `company_ids` populated from V1's\n            `organizationIds` field. This method provides API parity with\n            `CompanyService.get_associated_person_ids()`.\n        \"\"\"\n        data = await self._client.get(f\"/persons/{person_id}\", v1=True)\n        # Defensive: handle potential {\"person\": {...}} wrapper\n        # (consistent with CompanyService.get_associated_person_ids pattern)\n        person = data.get(\"person\") if isinstance(data, dict) else None\n        source = person if isinstance(person, dict) else data\n        org_ids = None\n        if isinstance(source, dict):\n            org_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n        if not isinstance(org_ids, list):\n            return []\n\n        ids = [CompanyId(int(cid)) for cid in org_ids if cid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    async def get_associated_company_ids_batch(\n        self,\n        person_ids: Sequence[PersonId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[PersonId, builtins.list[CompanyId]]:\n        \"\"\"\n        Get company associations for multiple persons.\n\n        Makes one V1 API call per person.\n\n        Args:\n            person_ids: Sequence of person IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping person_id -&gt; list of company_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n        \"\"\"\n        result: dict[PersonId, builtins.list[CompanyId]] = {}\n        for person_id in person_ids:\n            try:\n                result[person_id] = await self.get_associated_company_ids(person_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this person\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for person {person_id}: {e}\"\n                    ) from e\n                # skip: continue without this person\n        return result\n\n    async def get_associated_opportunity_ids(\n        self,\n        person_id: PersonId,\n        *,\n        max_results: int | None = None,\n    ) -&gt; builtins.list[OpportunityId]:\n        \"\"\"\n        Get associated opportunity IDs for a person.\n\n        V1-only: V2 does not expose person -&gt; opportunity associations directly.\n        Uses GET `/persons/{id}` (V1) and returns `opportunity_ids`.\n\n        Args:\n            person_id: The person ID\n            max_results: Maximum number of opportunity IDs to return\n\n        Returns:\n            List of OpportunityId values associated with this person\n\n        Note:\n            The Person model already has `opportunity_ids` populated from V1's\n            `opportunityIds` field. This method provides API parity with\n            `OpportunityService.get_associated_person_ids()`.\n        \"\"\"\n        data = await self._client.get(f\"/persons/{person_id}\", v1=True)\n        # Defensive: handle potential {\"person\": {...}} wrapper\n        person = data.get(\"person\") if isinstance(data, dict) else None\n        source = person if isinstance(person, dict) else data\n        opp_ids = None\n        if isinstance(source, dict):\n            opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n        if not isinstance(opp_ids, list):\n            return []\n\n        ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n        if max_results is not None and max_results &gt;= 0:\n            return ids[:max_results]\n        return ids\n\n    async def get_associated_opportunity_ids_batch(\n        self,\n        person_ids: Sequence[PersonId],\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[PersonId, builtins.list[OpportunityId]]:\n        \"\"\"\n        Get opportunity associations for multiple persons.\n\n        Makes one V1 API call per person.\n\n        Args:\n            person_ids: Sequence of person IDs to fetch\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping person_id -&gt; list of opportunity_ids\n\n        Raises:\n            AffinityError: If on_error=\"raise\" and any fetch fails.\n        \"\"\"\n        result: dict[PersonId, builtins.list[OpportunityId]] = {}\n        for person_id in person_ids:\n            try:\n                result[person_id] = await self.get_associated_opportunity_ids(person_id)\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this person\n            except Exception as e:\n                if on_error == \"raise\":\n                    raise AffinityError(\n                        f\"Failed to get associations for person {person_id}: {e}\"\n                    ) from e\n                # skip: continue without this person\n        return result\n\n    # =========================================================================\n    # Search (V1 API)\n    # =========================================================================\n\n    async def search(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Person]:\n        \"\"\"\n        Search for persons by name or email.\n\n        Uses V1 API for search functionality.\n        \"\"\"\n        params: dict[str, Any] = {\"term\": term}\n        if with_interaction_dates:\n            params[\"with_interaction_dates\"] = True\n        if with_interaction_persons:\n            params[\"with_interaction_persons\"] = True\n        if with_opportunities:\n            params[\"with_opportunities\"] = True\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = await self._client.get(\"/persons\", params=params, v1=True)\n        items = [Person.model_validate(p) for p in data.get(\"persons\", [])]\n        return PaginatedResponse[Person](\n            data=items,\n            next_page_token=data.get(\"next_page_token\"),\n        )\n\n    async def search_pages(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; AsyncIterator[PaginatedResponse[Person]]:\n        \"\"\"\n        Iterate V1 person-search result pages.\n\n        Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n        Args:\n            term: Search term (name or email)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            PaginatedResponse[Person] for each page\n        \"\"\"\n        requested_token = page_token\n        page = await self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        )\n        while True:\n            yield page\n            next_token = page.next_page_token\n            if not next_token or next_token == requested_token:\n                return\n            requested_token = next_token\n            page = await self.search(\n                term,\n                with_interaction_dates=with_interaction_dates,\n                with_interaction_persons=with_interaction_persons,\n                with_opportunities=with_opportunities,\n                page_size=page_size,\n                page_token=next_token,\n            )\n\n    async def search_all(\n        self,\n        term: str,\n        *,\n        with_interaction_dates: bool = False,\n        with_interaction_persons: bool = False,\n        with_opportunities: bool = False,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; AsyncIterator[Person]:\n        \"\"\"\n        Iterate all V1 person-search results with automatic pagination.\n\n        Args:\n            term: Search term (name or email)\n            with_interaction_dates: Include interaction date data\n            with_interaction_persons: Include persons for interactions\n            with_opportunities: Include associated opportunity IDs\n            page_size: Results per page (max 500)\n            page_token: Resume from this pagination token\n\n        Yields:\n            Person objects matching the search term\n        \"\"\"\n        async for page in self.search_pages(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=page_token,\n        ):\n            for person in page.data:\n                yield person\n\n    async def resolve(\n        self,\n        *,\n        email: str | None = None,\n        name: str | None = None,\n    ) -&gt; Person | None:\n        \"\"\"\n        Find a single person by email or name.\n\n        This is a convenience helper that searches and returns the first exact match,\n        or None if not found. Uses V1 search internally.\n        \"\"\"\n        if not email and not name:\n            raise ValueError(\"Must provide either email or name\")\n\n        term = email or name or \"\"\n        async for page in self.search_pages(term, page_size=10):\n            for person in page.data:\n                if _person_matches(person, email=email, name=name):\n                    return person\n\n        return None\n\n    async def resolve_all(\n        self,\n        *,\n        email: str | None = None,\n        name: str | None = None,\n    ) -&gt; builtins.list[Person]:\n        \"\"\"\n        Find all persons matching an email or name.\n\n        Notes:\n        - This auto-paginates V1 search results to collect exact matches.\n        - Unlike resolve(), this returns every match in server-provided order.\n        \"\"\"\n        if not email and not name:\n            raise ValueError(\"Must provide either email or name\")\n\n        term = email or name or \"\"\n        matches: builtins.list[Person] = []\n        async for page in self.search_pages(term, page_size=10):\n            for person in page.data:\n                if _person_matches(person, email=email, name=name):\n                    matches.append(person)\n        return matches\n\n    # =========================================================================\n    # Write Operations (V1 API)\n    # =========================================================================\n\n    async def create(self, data: PersonCreate) -&gt; Person:\n        \"\"\"\n        Create a new person.\n\n        Note:\n            Creates use V1 API, while reads use V2 API. Due to eventual consistency\n            between V1 and V2, a `get()` call immediately after `create()` may return\n            404 NotFoundError. If you need to read immediately after creation, either:\n            - Use the Person object returned by this method (it contains the created data)\n            - Add a short delay (100-500ms) before calling get()\n            - Implement retry logic in your application\n\n        Raises:\n            ValidationError: If email conflicts with existing person\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"json\")\n        if not data.company_ids:\n            payload.pop(\"organization_ids\", None)\n\n        result = await self._client.post(\"/persons\", json=payload, v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"person\")\n\n        return Person.model_validate(result)\n\n    async def update(\n        self,\n        person_id: PersonId,\n        data: PersonUpdate,\n    ) -&gt; Person:\n        \"\"\"\n        Update an existing person.\n\n        Note: To add emails/organizations, include existing values plus new ones.\n        \"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"json\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n\n        result = await self._client.put(\n            f\"/persons/{person_id}\",\n            json=payload,\n            v1=True,\n        )\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"person\")\n\n        return Person.model_validate(result)\n\n    async def delete(self, person_id: PersonId) -&gt; bool:\n        \"\"\"Delete a person (also deletes associated field values).\"\"\"\n        result = await self._client.delete(f\"/persons/{person_id}\", v1=True)\n\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"person\")\n\n        return bool(result.get(\"success\", False))\n\n    # =========================================================================\n    # Merge Operations (V2 BETA)\n    # =========================================================================\n\n    async def merge(\n        self,\n        primary_id: PersonId,\n        duplicate_id: PersonId,\n    ) -&gt; str:\n        \"\"\"\n        Merge a duplicate person into a primary person.\n\n        Returns a task URL to check merge status.\n        \"\"\"\n        if not self._client.enable_beta_endpoints:\n            raise BetaEndpointDisabledError(\n                \"Person merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n            )\n        result = await self._client.post(\n            \"/person-merges\",\n            json={\n                \"primaryPersonId\": int(primary_id),\n                \"duplicatePersonId\": int(duplicate_id),\n            },\n        )\n        return str(result.get(\"taskUrl\", \"\"))\n\n    async def get_merge_status(self, task_id: str) -&gt; MergeTask:\n        \"\"\"Check the status of a merge operation.\"\"\"\n        data = await self._client.get(f\"/tasks/person-merges/{task_id}\")\n        return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.all","title":"<code>all(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; Iterator[Person]</code>","text":"<p>Iterate through all persons with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[PersonId] | None</code> <p>Specific person IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression</p> <code>None</code> <p>Yields:</p> Type Description <code>Person</code> <p>Person objects</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def all(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; Iterator[Person]:\n    \"\"\"\n    Iterate through all persons with automatic pagination.\n\n    Args:\n        ids: Specific person IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include\n        field_types: Field types to include\n        filter: V2 filter expression\n\n    Yields:\n        Person objects\n    \"\"\"\n\n    def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Person]:\n        if next_url:\n            data = self._client.get_url(next_url)\n            return PaginatedResponse[Person](\n                data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n                pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n            )\n        return self.list(\n            ids=ids,\n            field_ids=field_ids,\n            field_types=field_types,\n            filter=filter,\n        )\n\n    return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.create","title":"<code>create(data: PersonCreate) -&gt; Person</code>","text":"<p>Create a new person.</p> Note <p>Creates use V1 API, while reads use V2 API. Due to eventual consistency between V1 and V2, a <code>get()</code> call immediately after <code>create()</code> may return 404 NotFoundError. If you need to read immediately after creation, either: - Use the Person object returned by this method (it contains the created data) - Add a short delay (100-500ms) before calling get() - Implement retry logic in your application</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If email conflicts with existing person</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def create(self, data: PersonCreate) -&gt; Person:\n    \"\"\"\n    Create a new person.\n\n    Note:\n        Creates use V1 API, while reads use V2 API. Due to eventual consistency\n        between V1 and V2, a `get()` call immediately after `create()` may return\n        404 NotFoundError. If you need to read immediately after creation, either:\n        - Use the Person object returned by this method (it contains the created data)\n        - Add a short delay (100-500ms) before calling get()\n        - Implement retry logic in your application\n\n    Raises:\n        ValidationError: If email conflicts with existing person\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"json\")\n    if not data.company_ids:\n        payload.pop(\"organization_ids\", None)\n\n    result = self._client.post(\"/persons\", json=payload, v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"person\")\n\n    return Person.model_validate(result)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.delete","title":"<code>delete(person_id: PersonId) -&gt; bool</code>","text":"<p>Delete a person (also deletes associated field values).</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def delete(self, person_id: PersonId) -&gt; bool:\n    \"\"\"Delete a person (also deletes associated field values).\"\"\"\n    result = self._client.delete(f\"/persons/{person_id}\", v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"person\")\n\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get","title":"<code>get(person_id: PersonId, *, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, include_field_values: bool = False, retries: int = 0, with_interaction_dates: bool = False, with_interaction_persons: bool = False) -&gt; Person</code>","text":"<p>Get a single person by ID.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId</code> <p>The person ID</p> required <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>include_field_values</code> <code>bool</code> <p>If True, fetch embedded field values. This saves one API call when you need both person info and field values. Cannot be combined with field_ids/field_types.</p> <code>False</code> <code>retries</code> <code>int</code> <p>Number of retries on 404 NotFoundError. Default is 0 (fail fast). Set to 2-3 if calling immediately after create() to handle eventual consistency lag.</p> <code>0</code> <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date summaries (last/next meeting dates, email dates).</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include person IDs for each interaction. Only applies when with_interaction_dates=True.</p> <code>False</code> <p>Returns:</p> Type Description <code>Person</code> <p>Person object with requested field data.</p> <code>Person</code> <p>When include_field_values=True, the Person will have a <code>field_values</code></p> <code>Person</code> <p>attribute containing the list of FieldValue objects.</p> <code>Person</code> <p>When with_interaction_dates=True, the Person will have interaction_dates</p> <code>Person</code> <p>and interactions populated.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If person does not exist after all retries.</p> <code>ValueError</code> <p>If include_field_values is combined with field_ids/field_types.</p> Note <p>When combining with_interaction_dates with field_ids/field_types, two API calls are made internally and the results are merged.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get(\n    self,\n    person_id: PersonId,\n    *,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    include_field_values: bool = False,\n    retries: int = 0,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n) -&gt; Person:\n    \"\"\"\n    Get a single person by ID.\n\n    Args:\n        person_id: The person ID\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        include_field_values: If True, fetch embedded field values. This saves\n            one API call when you need both person info and field values.\n            Cannot be combined with field_ids/field_types.\n        retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n            Set to 2-3 if calling immediately after create() to handle eventual\n            consistency lag.\n        with_interaction_dates: Include interaction date summaries (last/next\n            meeting dates, email dates).\n        with_interaction_persons: Include person IDs for each interaction.\n            Only applies when with_interaction_dates=True.\n\n    Returns:\n        Person object with requested field data.\n        When include_field_values=True, the Person will have a `field_values`\n        attribute containing the list of FieldValue objects.\n        When with_interaction_dates=True, the Person will have interaction_dates\n        and interactions populated.\n\n    Raises:\n        NotFoundError: If person does not exist after all retries.\n        ValueError: If include_field_values is combined with field_ids/field_types.\n\n    Note:\n        When combining with_interaction_dates with field_ids/field_types,\n        two API calls are made internally and the results are merged.\n    \"\"\"\n    return self._get_with_retry(\n        person_id,\n        field_ids=field_ids,\n        field_types=field_types,\n        include_field_values=include_field_values,\n        retries=retries,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_associated_company_ids","title":"<code>get_associated_company_ids(person_id: PersonId, *, max_results: int | None = None) -&gt; builtins.list[CompanyId]</code>","text":"<p>Get associated company IDs for a person.</p> <p>V1-only: V2 does not expose person -&gt; company associations directly. Uses GET <code>/persons/{id}</code> (V1) and returns <code>organization_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId</code> <p>The person ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of company IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CompanyId]</code> <p>List of CompanyId values associated with this person</p> Note <p>The Person model already has <code>company_ids</code> populated from V1's <code>organizationIds</code> field. This method provides API parity with <code>CompanyService.get_associated_person_ids()</code>.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_associated_company_ids(\n    self,\n    person_id: PersonId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[CompanyId]:\n    \"\"\"\n    Get associated company IDs for a person.\n\n    V1-only: V2 does not expose person -&gt; company associations directly.\n    Uses GET `/persons/{id}` (V1) and returns `organization_ids`.\n\n    Args:\n        person_id: The person ID\n        max_results: Maximum number of company IDs to return\n\n    Returns:\n        List of CompanyId values associated with this person\n\n    Note:\n        The Person model already has `company_ids` populated from V1's\n        `organizationIds` field. This method provides API parity with\n        `CompanyService.get_associated_person_ids()`.\n    \"\"\"\n    data = self._client.get(f\"/persons/{person_id}\", v1=True)\n    # Defensive: handle potential {\"person\": {...}} wrapper\n    # (consistent with CompanyService.get_associated_person_ids pattern)\n    person = data.get(\"person\") if isinstance(data, dict) else None\n    source = person if isinstance(person, dict) else data\n    org_ids = None\n    if isinstance(source, dict):\n        org_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n    if not isinstance(org_ids, list):\n        return []\n\n    ids = [CompanyId(int(cid)) for cid in org_ids if cid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_associated_company_ids_batch","title":"<code>get_associated_company_ids_batch(person_ids: Sequence[PersonId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[PersonId, builtins.list[CompanyId]]</code>","text":"<p>Get company associations for multiple persons.</p> <p>Makes one V1 API call per person.</p> <p>Parameters:</p> Name Type Description Default <code>person_ids</code> <code>Sequence[PersonId]</code> <p>Sequence of person IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[PersonId, list[CompanyId]]</code> <p>Dict mapping person_id -&gt; list of company_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Example <p>associations = client.persons.get_associated_company_ids_batch(person_ids) all_company_ids = set() for company_ids in associations.values():     all_company_ids.update(company_ids)</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_associated_company_ids_batch(\n    self,\n    person_ids: Sequence[PersonId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[PersonId, builtins.list[CompanyId]]:\n    \"\"\"\n    Get company associations for multiple persons.\n\n    Makes one V1 API call per person.\n\n    Args:\n        person_ids: Sequence of person IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping person_id -&gt; list of company_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n\n    Example:\n        associations = client.persons.get_associated_company_ids_batch(person_ids)\n        all_company_ids = set()\n        for company_ids in associations.values():\n            all_company_ids.update(company_ids)\n    \"\"\"\n    result: dict[PersonId, builtins.list[CompanyId]] = {}\n    for person_id in person_ids:\n        try:\n            result[person_id] = self.get_associated_company_ids(person_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this person\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for person {person_id}: {e}\"\n                ) from e\n            # skip: continue without this person\n    return result\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_associated_opportunity_ids","title":"<code>get_associated_opportunity_ids(person_id: PersonId, *, max_results: int | None = None) -&gt; builtins.list[OpportunityId]</code>","text":"<p>Get associated opportunity IDs for a person.</p> <p>V1-only: V2 does not expose person -&gt; opportunity associations directly. Uses GET <code>/persons/{id}</code> (V1) and returns <code>opportunity_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId</code> <p>The person ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of opportunity IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OpportunityId]</code> <p>List of OpportunityId values associated with this person</p> Note <p>The Person model already has <code>opportunity_ids</code> populated from V1's <code>opportunityIds</code> field. This method provides API parity with <code>OpportunityService.get_associated_person_ids()</code>.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_associated_opportunity_ids(\n    self,\n    person_id: PersonId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[OpportunityId]:\n    \"\"\"\n    Get associated opportunity IDs for a person.\n\n    V1-only: V2 does not expose person -&gt; opportunity associations directly.\n    Uses GET `/persons/{id}` (V1) and returns `opportunity_ids`.\n\n    Args:\n        person_id: The person ID\n        max_results: Maximum number of opportunity IDs to return\n\n    Returns:\n        List of OpportunityId values associated with this person\n\n    Note:\n        The Person model already has `opportunity_ids` populated from V1's\n        `opportunityIds` field. This method provides API parity with\n        `OpportunityService.get_associated_person_ids()`.\n    \"\"\"\n    data = self._client.get(f\"/persons/{person_id}\", v1=True)\n    # Defensive: handle potential {\"person\": {...}} wrapper\n    person = data.get(\"person\") if isinstance(data, dict) else None\n    source = person if isinstance(person, dict) else data\n    opp_ids = None\n    if isinstance(source, dict):\n        opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n    if not isinstance(opp_ids, list):\n        return []\n\n    ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_associated_opportunity_ids_batch","title":"<code>get_associated_opportunity_ids_batch(person_ids: Sequence[PersonId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[PersonId, builtins.list[OpportunityId]]</code>","text":"<p>Get opportunity associations for multiple persons.</p> <p>Makes one V1 API call per person.</p> <p>Parameters:</p> Name Type Description Default <code>person_ids</code> <code>Sequence[PersonId]</code> <p>Sequence of person IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[PersonId, list[OpportunityId]]</code> <p>Dict mapping person_id -&gt; list of opportunity_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_associated_opportunity_ids_batch(\n    self,\n    person_ids: Sequence[PersonId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[PersonId, builtins.list[OpportunityId]]:\n    \"\"\"\n    Get opportunity associations for multiple persons.\n\n    Makes one V1 API call per person.\n\n    Args:\n        person_ids: Sequence of person IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping person_id -&gt; list of opportunity_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n    \"\"\"\n    result: dict[PersonId, builtins.list[OpportunityId]] = {}\n    for person_id in person_ids:\n        try:\n            result[person_id] = self.get_associated_opportunity_ids(person_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this person\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for person {person_id}: {e}\"\n                ) from e\n            # skip: continue without this person\n    return result\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_fields","title":"<code>get_fields(*, field_types: Sequence[FieldType] | None = None) -&gt; builtins.list[FieldMetadata]</code>","text":"<p>Get metadata about person fields.</p> <p>Cached for performance.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_fields(\n    self,\n    *,\n    field_types: Sequence[FieldType] | None = None,\n) -&gt; builtins.list[FieldMetadata]:\n    \"\"\"\n    Get metadata about person fields.\n\n    Cached for performance.\n    \"\"\"\n    params: dict[str, Any] = {}\n    if field_types:\n        params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n    data = self._client.get(\n        \"/persons/fields\",\n        params=params or None,\n        cache_key=f\"person_fields:{','.join(field_types or [])}\",\n        cache_ttl=300,\n    )\n\n    return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_list_entries","title":"<code>get_list_entries(person_id: PersonId) -&gt; PaginatedResponse[ListEntry]</code>","text":"<p>Get all list entries for a person across all lists.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_list_entries(\n    self,\n    person_id: PersonId,\n) -&gt; PaginatedResponse[ListEntry]:\n    \"\"\"Get all list entries for a person across all lists.\"\"\"\n    data = self._client.get(f\"/persons/{person_id}/list-entries\")\n\n    return PaginatedResponse[ListEntry](\n        data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_lists","title":"<code>get_lists(person_id: PersonId) -&gt; PaginatedResponse[ListSummary]</code>","text":"<p>Get all lists that contain this person.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_lists(\n    self,\n    person_id: PersonId,\n) -&gt; PaginatedResponse[ListSummary]:\n    \"\"\"Get all lists that contain this person.\"\"\"\n    data = self._client.get(f\"/persons/{person_id}/lists\")\n\n    return PaginatedResponse[ListSummary](\n        data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.get_merge_status","title":"<code>get_merge_status(task_id: str) -&gt; MergeTask</code>","text":"<p>Check the status of a merge operation.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def get_merge_status(self, task_id: str) -&gt; MergeTask:\n    \"\"\"Check the status of a merge operation.\"\"\"\n    data = self._client.get(f\"/tasks/person-merges/{task_id}\")\n    return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.iter","title":"<code>iter(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; Iterator[Person]</code>","text":"<p>Auto-paginate all persons.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def iter(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; Iterator[Person]:\n    \"\"\"\n    Auto-paginate all persons.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.list","title":"<code>list(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[Person]</code>","text":"<p>Get a page of persons.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[PersonId] | None</code> <p>Specific person IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string, or a FilterExpression built via <code>affinity.F</code></p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses)</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Person]</code> <p>Paginated response with persons</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def list(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[Person]:\n    \"\"\"\n    Get a page of persons.\n\n    Args:\n        ids: Specific person IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include\n        filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n        limit: Maximum number of results\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n    Returns:\n        Paginated response with persons\n    \"\"\"\n    if cursor is not None:\n        if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if ids:\n            params[\"ids\"] = [int(id_) for id_ in ids]\n        if field_ids:\n            params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n        if filter is not None:\n            filter_text = str(filter).strip()\n            if filter_text:\n                params[\"filter\"] = filter_text\n        if limit:\n            params[\"limit\"] = limit\n        data = self._client.get(\"/persons\", params=params or None)\n\n    return PaginatedResponse[Person](\n        data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.merge","title":"<code>merge(primary_id: PersonId, duplicate_id: PersonId) -&gt; str</code>","text":"<p>Merge a duplicate person into a primary person.</p> <p>Returns a task URL to check merge status.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def merge(\n    self,\n    primary_id: PersonId,\n    duplicate_id: PersonId,\n) -&gt; str:\n    \"\"\"\n    Merge a duplicate person into a primary person.\n\n    Returns a task URL to check merge status.\n    \"\"\"\n    if not self._client.enable_beta_endpoints:\n        raise BetaEndpointDisabledError(\n            \"Person merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n        )\n    result = self._client.post(\n        \"/person-merges\",\n        json={\n            \"primaryPersonId\": int(primary_id),\n            \"duplicatePersonId\": int(duplicate_id),\n        },\n    )\n    return str(result.get(\"taskUrl\", \"\"))\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.pages","title":"<code>pages(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; Iterator[PaginatedResponse[Person]]</code>","text":"<p>Iterate person pages (not items), yielding <code>PaginatedResponse[Person]</code>.</p> <p>Useful for ETL scripts that need checkpoint/resume via <code>page.next_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[PersonId] | None</code> <p>Specific person IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string or FilterExpression</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination</p> <code>None</code> <p>Yields:</p> Type Description <code>PaginatedResponse[Person]</code> <p>PaginatedResponse[Person] for each page</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def pages(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; Iterator[PaginatedResponse[Person]]:\n    \"\"\"\n    Iterate person pages (not items), yielding `PaginatedResponse[Person]`.\n\n    Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n    Args:\n        ids: Specific person IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include\n        filter: V2 filter expression string or FilterExpression\n        limit: Maximum results per page\n        cursor: Cursor to resume pagination\n\n    Yields:\n        PaginatedResponse[Person] for each page\n    \"\"\"\n    other_params = (ids, field_ids, field_types, filter, limit)\n    if cursor is not None and any(p is not None for p in other_params):\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    page = (\n        self.list(cursor=cursor)\n        if cursor is not None\n        else self.list(\n            ids=ids, field_ids=field_ids, field_types=field_types, filter=filter, limit=limit\n        )\n    )\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.resolve","title":"<code>resolve(*, email: str | None = None, name: str | None = None) -&gt; Person | None</code>","text":"<p>Find a single person by email or name.</p> <p>This is a convenience helper that searches and returns the first exact match, or None if not found. Uses V1 search internally.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str | None</code> <p>Email address to search for</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Person name to search for (first + last)</p> <code>None</code> <p>Returns:</p> Type Description <code>Person | None</code> <p>The matching Person, or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither email nor name is provided</p> Note <p>This auto-paginates V1 search results until a match is found. If multiple matches are found, returns the first one. For full disambiguation, use resolve_all() or search() directly.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def resolve(\n    self,\n    *,\n    email: str | None = None,\n    name: str | None = None,\n) -&gt; Person | None:\n    \"\"\"\n    Find a single person by email or name.\n\n    This is a convenience helper that searches and returns the first exact match,\n    or None if not found. Uses V1 search internally.\n\n    Args:\n        email: Email address to search for\n        name: Person name to search for (first + last)\n\n    Returns:\n        The matching Person, or None if not found\n\n    Raises:\n        ValueError: If neither email nor name is provided\n\n    Note:\n        This auto-paginates V1 search results until a match is found.\n        If multiple matches are found, returns the first one. For full\n        disambiguation, use resolve_all() or search() directly.\n    \"\"\"\n    if not email and not name:\n        raise ValueError(\"Must provide either email or name\")\n\n    term = email or name or \"\"\n    for page in self.search_pages(term, page_size=10):\n        for person in page.data:\n            if _person_matches(person, email=email, name=name):\n                return person\n\n    return None\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.resolve_all","title":"<code>resolve_all(*, email: str | None = None, name: str | None = None) -&gt; builtins.list[Person]</code>","text":"<p>Find all persons matching an email or name.</p> <p>Notes: - This auto-paginates V1 search results to collect exact matches. - Unlike resolve(), this returns every match in server-provided order.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def resolve_all(\n    self,\n    *,\n    email: str | None = None,\n    name: str | None = None,\n) -&gt; builtins.list[Person]:\n    \"\"\"\n    Find all persons matching an email or name.\n\n    Notes:\n    - This auto-paginates V1 search results to collect exact matches.\n    - Unlike resolve(), this returns every match in server-provided order.\n    \"\"\"\n    if not email and not name:\n        raise ValueError(\"Must provide either email or name\")\n\n    term = email or name or \"\"\n    matches: builtins.list[Person] = []\n    for page in self.search_pages(term, page_size=10):\n        for person in page.data:\n            if _person_matches(person, email=email, name=name):\n                matches.append(person)\n    return matches\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.search","title":"<code>search(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Person]</code>","text":"<p>Search for persons by name or email.</p> <p>Uses V1 API for search functionality.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or email)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Pagination token</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Person]</code> <p>PaginatedResponse[Person] with matching persons and pagination info</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def search(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Person]:\n    \"\"\"\n    Search for persons by name or email.\n\n    Uses V1 API for search functionality.\n\n    Args:\n        term: Search term (name or email)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Pagination token\n\n    Returns:\n        PaginatedResponse[Person] with matching persons and pagination info\n    \"\"\"\n    params: dict[str, Any] = {\"term\": term}\n    if with_interaction_dates:\n        params[\"with_interaction_dates\"] = True\n    if with_interaction_persons:\n        params[\"with_interaction_persons\"] = True\n    if with_opportunities:\n        params[\"with_opportunities\"] = True\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = self._client.get(\"/persons\", params=params, v1=True)\n    items = [Person.model_validate(p) for p in data.get(\"persons\", [])]\n    return PaginatedResponse[Person](\n        data=items,\n        next_page_token=data.get(\"next_page_token\"),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.search_all","title":"<code>search_all(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; Iterator[Person]</code>","text":"<p>Iterate all V1 person-search results with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or email)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>Person</code> <p>Person objects matching the search term</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def search_all(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; Iterator[Person]:\n    \"\"\"\n    Iterate all V1 person-search results with automatic pagination.\n\n    Args:\n        term: Search term (name or email)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        Person objects matching the search term\n    \"\"\"\n    for page in self.search_pages(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    ):\n        yield from page.data\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.search_pages","title":"<code>search_pages(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; Iterator[PaginatedResponse[Person]]</code>","text":"<p>Iterate V1 person-search result pages.</p> <p>Useful for scripts that need checkpoint/resume via <code>next_page_token</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or email)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>PaginatedResponse[Person]</code> <p>PaginatedResponse[Person] for each page</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def search_pages(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; Iterator[PaginatedResponse[Person]]:\n    \"\"\"\n    Iterate V1 person-search result pages.\n\n    Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n    Args:\n        term: Search term (name or email)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        PaginatedResponse[Person] for each page\n    \"\"\"\n    requested_token = page_token\n    page = self.search(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    )\n    while True:\n        yield page\n        next_token = page.next_page_token\n        if not next_token or next_token == requested_token:\n            return\n        requested_token = next_token\n        page = self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=next_token,\n        )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.PersonService.update","title":"<code>update(person_id: PersonId, data: PersonUpdate) -&gt; Person</code>","text":"<p>Update an existing person.</p> <p>Note: To add emails/organizations, include existing values plus new ones.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def update(\n    self,\n    person_id: PersonId,\n    data: PersonUpdate,\n) -&gt; Person:\n    \"\"\"\n    Update an existing person.\n\n    Note: To add emails/organizations, include existing values plus new ones.\n    \"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"json\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n\n    result = self._client.put(\n        f\"/persons/{person_id}\",\n        json=payload,\n        v1=True,\n    )\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"person\")\n\n    return Person.model_validate(result)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.all","title":"<code>all(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; AsyncIterator[Person]</code>","text":"<p>Iterate through all persons with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[PersonId] | None</code> <p>Specific person IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Person]</code> <p>Person objects</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def all(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; AsyncIterator[Person]:\n    \"\"\"\n    Iterate through all persons with automatic pagination.\n\n    Args:\n        ids: Specific person IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include\n        field_types: Field types to include\n        filter: V2 filter expression\n\n    Yields:\n        Person objects\n    \"\"\"\n\n    async def fetch_page(next_url: str | None) -&gt; PaginatedResponse[Person]:\n        if next_url:\n            data = await self._client.get_url(next_url)\n            return PaginatedResponse[Person](\n                data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n                pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n            )\n        return await self.list(\n            ids=ids, field_ids=field_ids, field_types=field_types, filter=filter\n        )\n\n    return AsyncPageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.create","title":"<code>create(data: PersonCreate) -&gt; Person</code>  <code>async</code>","text":"<p>Create a new person.</p> Note <p>Creates use V1 API, while reads use V2 API. Due to eventual consistency between V1 and V2, a <code>get()</code> call immediately after <code>create()</code> may return 404 NotFoundError. If you need to read immediately after creation, either: - Use the Person object returned by this method (it contains the created data) - Add a short delay (100-500ms) before calling get() - Implement retry logic in your application</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If email conflicts with existing person</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def create(self, data: PersonCreate) -&gt; Person:\n    \"\"\"\n    Create a new person.\n\n    Note:\n        Creates use V1 API, while reads use V2 API. Due to eventual consistency\n        between V1 and V2, a `get()` call immediately after `create()` may return\n        404 NotFoundError. If you need to read immediately after creation, either:\n        - Use the Person object returned by this method (it contains the created data)\n        - Add a short delay (100-500ms) before calling get()\n        - Implement retry logic in your application\n\n    Raises:\n        ValidationError: If email conflicts with existing person\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"json\")\n    if not data.company_ids:\n        payload.pop(\"organization_ids\", None)\n\n    result = await self._client.post(\"/persons\", json=payload, v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"person\")\n\n    return Person.model_validate(result)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.delete","title":"<code>delete(person_id: PersonId) -&gt; bool</code>  <code>async</code>","text":"<p>Delete a person (also deletes associated field values).</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def delete(self, person_id: PersonId) -&gt; bool:\n    \"\"\"Delete a person (also deletes associated field values).\"\"\"\n    result = await self._client.delete(f\"/persons/{person_id}\", v1=True)\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"person\")\n\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get","title":"<code>get(person_id: PersonId, *, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, include_field_values: bool = False, retries: int = 0, with_interaction_dates: bool = False, with_interaction_persons: bool = False) -&gt; Person</code>  <code>async</code>","text":"<p>Get a single person by ID.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId</code> <p>The person ID</p> required <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include (e.g., [\"enriched\", \"global\"])</p> <code>None</code> <code>include_field_values</code> <code>bool</code> <p>If True, fetch embedded field values. This saves one API call when you need both person info and field values. Cannot be combined with field_ids/field_types.</p> <code>False</code> <code>retries</code> <code>int</code> <p>Number of retries on 404 NotFoundError. Default is 0 (fail fast). Set to 2-3 if calling immediately after create() to handle eventual consistency lag.</p> <code>0</code> <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date summaries (last/next meeting dates, email dates).</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include person IDs for each interaction. Only applies when with_interaction_dates=True.</p> <code>False</code> <p>Returns:</p> Type Description <code>Person</code> <p>Person object with requested field data.</p> <code>Person</code> <p>When include_field_values=True, the Person will have a <code>field_values</code></p> <code>Person</code> <p>attribute containing the list of FieldValue objects.</p> <code>Person</code> <p>When with_interaction_dates=True, the Person will have interaction_dates</p> <code>Person</code> <p>and interactions populated.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If person does not exist after all retries.</p> <code>ValueError</code> <p>If include_field_values is combined with field_ids/field_types.</p> Note <p>When combining with_interaction_dates with field_ids/field_types, two API calls are made internally and the results are merged.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get(\n    self,\n    person_id: PersonId,\n    *,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    include_field_values: bool = False,\n    retries: int = 0,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n) -&gt; Person:\n    \"\"\"\n    Get a single person by ID.\n\n    Args:\n        person_id: The person ID\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include (e.g., [\"enriched\", \"global\"])\n        include_field_values: If True, fetch embedded field values. This saves\n            one API call when you need both person info and field values.\n            Cannot be combined with field_ids/field_types.\n        retries: Number of retries on 404 NotFoundError. Default is 0 (fail fast).\n            Set to 2-3 if calling immediately after create() to handle eventual\n            consistency lag.\n        with_interaction_dates: Include interaction date summaries (last/next\n            meeting dates, email dates).\n        with_interaction_persons: Include person IDs for each interaction.\n            Only applies when with_interaction_dates=True.\n\n    Returns:\n        Person object with requested field data.\n        When include_field_values=True, the Person will have a `field_values`\n        attribute containing the list of FieldValue objects.\n        When with_interaction_dates=True, the Person will have interaction_dates\n        and interactions populated.\n\n    Raises:\n        NotFoundError: If person does not exist after all retries.\n        ValueError: If include_field_values is combined with field_ids/field_types.\n\n    Note:\n        When combining with_interaction_dates with field_ids/field_types,\n        two API calls are made internally and the results are merged.\n    \"\"\"\n    return await self._get_with_retry(\n        person_id,\n        field_ids=field_ids,\n        field_types=field_types,\n        include_field_values=include_field_values,\n        retries=retries,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_associated_company_ids","title":"<code>get_associated_company_ids(person_id: PersonId, *, max_results: int | None = None) -&gt; builtins.list[CompanyId]</code>  <code>async</code>","text":"<p>Get associated company IDs for a person.</p> <p>V1-only: V2 does not expose person -&gt; company associations directly. Uses GET <code>/persons/{id}</code> (V1) and returns <code>organization_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId</code> <p>The person ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of company IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CompanyId]</code> <p>List of CompanyId values associated with this person</p> Note <p>The Person model already has <code>company_ids</code> populated from V1's <code>organizationIds</code> field. This method provides API parity with <code>CompanyService.get_associated_person_ids()</code>.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_associated_company_ids(\n    self,\n    person_id: PersonId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[CompanyId]:\n    \"\"\"\n    Get associated company IDs for a person.\n\n    V1-only: V2 does not expose person -&gt; company associations directly.\n    Uses GET `/persons/{id}` (V1) and returns `organization_ids`.\n\n    Args:\n        person_id: The person ID\n        max_results: Maximum number of company IDs to return\n\n    Returns:\n        List of CompanyId values associated with this person\n\n    Note:\n        The Person model already has `company_ids` populated from V1's\n        `organizationIds` field. This method provides API parity with\n        `CompanyService.get_associated_person_ids()`.\n    \"\"\"\n    data = await self._client.get(f\"/persons/{person_id}\", v1=True)\n    # Defensive: handle potential {\"person\": {...}} wrapper\n    # (consistent with CompanyService.get_associated_person_ids pattern)\n    person = data.get(\"person\") if isinstance(data, dict) else None\n    source = person if isinstance(person, dict) else data\n    org_ids = None\n    if isinstance(source, dict):\n        org_ids = source.get(\"organization_ids\") or source.get(\"organizationIds\")\n\n    if not isinstance(org_ids, list):\n        return []\n\n    ids = [CompanyId(int(cid)) for cid in org_ids if cid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_associated_company_ids_batch","title":"<code>get_associated_company_ids_batch(person_ids: Sequence[PersonId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[PersonId, builtins.list[CompanyId]]</code>  <code>async</code>","text":"<p>Get company associations for multiple persons.</p> <p>Makes one V1 API call per person.</p> <p>Parameters:</p> Name Type Description Default <code>person_ids</code> <code>Sequence[PersonId]</code> <p>Sequence of person IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[PersonId, list[CompanyId]]</code> <p>Dict mapping person_id -&gt; list of company_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_associated_company_ids_batch(\n    self,\n    person_ids: Sequence[PersonId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[PersonId, builtins.list[CompanyId]]:\n    \"\"\"\n    Get company associations for multiple persons.\n\n    Makes one V1 API call per person.\n\n    Args:\n        person_ids: Sequence of person IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping person_id -&gt; list of company_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n    \"\"\"\n    result: dict[PersonId, builtins.list[CompanyId]] = {}\n    for person_id in person_ids:\n        try:\n            result[person_id] = await self.get_associated_company_ids(person_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this person\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for person {person_id}: {e}\"\n                ) from e\n            # skip: continue without this person\n    return result\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_associated_opportunity_ids","title":"<code>get_associated_opportunity_ids(person_id: PersonId, *, max_results: int | None = None) -&gt; builtins.list[OpportunityId]</code>  <code>async</code>","text":"<p>Get associated opportunity IDs for a person.</p> <p>V1-only: V2 does not expose person -&gt; opportunity associations directly. Uses GET <code>/persons/{id}</code> (V1) and returns <code>opportunity_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId</code> <p>The person ID</p> required <code>max_results</code> <code>int | None</code> <p>Maximum number of opportunity IDs to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OpportunityId]</code> <p>List of OpportunityId values associated with this person</p> Note <p>The Person model already has <code>opportunity_ids</code> populated from V1's <code>opportunityIds</code> field. This method provides API parity with <code>OpportunityService.get_associated_person_ids()</code>.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_associated_opportunity_ids(\n    self,\n    person_id: PersonId,\n    *,\n    max_results: int | None = None,\n) -&gt; builtins.list[OpportunityId]:\n    \"\"\"\n    Get associated opportunity IDs for a person.\n\n    V1-only: V2 does not expose person -&gt; opportunity associations directly.\n    Uses GET `/persons/{id}` (V1) and returns `opportunity_ids`.\n\n    Args:\n        person_id: The person ID\n        max_results: Maximum number of opportunity IDs to return\n\n    Returns:\n        List of OpportunityId values associated with this person\n\n    Note:\n        The Person model already has `opportunity_ids` populated from V1's\n        `opportunityIds` field. This method provides API parity with\n        `OpportunityService.get_associated_person_ids()`.\n    \"\"\"\n    data = await self._client.get(f\"/persons/{person_id}\", v1=True)\n    # Defensive: handle potential {\"person\": {...}} wrapper\n    person = data.get(\"person\") if isinstance(data, dict) else None\n    source = person if isinstance(person, dict) else data\n    opp_ids = None\n    if isinstance(source, dict):\n        opp_ids = source.get(\"opportunity_ids\") or source.get(\"opportunityIds\")\n\n    if not isinstance(opp_ids, list):\n        return []\n\n    ids = [OpportunityId(int(oid)) for oid in opp_ids if oid is not None]\n    if max_results is not None and max_results &gt;= 0:\n        return ids[:max_results]\n    return ids\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_associated_opportunity_ids_batch","title":"<code>get_associated_opportunity_ids_batch(person_ids: Sequence[PersonId], *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[PersonId, builtins.list[OpportunityId]]</code>  <code>async</code>","text":"<p>Get opportunity associations for multiple persons.</p> <p>Makes one V1 API call per person.</p> <p>Parameters:</p> Name Type Description Default <code>person_ids</code> <code>Sequence[PersonId]</code> <p>Sequence of person IDs to fetch</p> required <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>dict[PersonId, list[OpportunityId]]</code> <p>Dict mapping person_id -&gt; list of opportunity_ids</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If on_error=\"raise\" and any fetch fails.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_associated_opportunity_ids_batch(\n    self,\n    person_ids: Sequence[PersonId],\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[PersonId, builtins.list[OpportunityId]]:\n    \"\"\"\n    Get opportunity associations for multiple persons.\n\n    Makes one V1 API call per person.\n\n    Args:\n        person_ids: Sequence of person IDs to fetch\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping person_id -&gt; list of opportunity_ids\n\n    Raises:\n        AffinityError: If on_error=\"raise\" and any fetch fails.\n    \"\"\"\n    result: dict[PersonId, builtins.list[OpportunityId]] = {}\n    for person_id in person_ids:\n        try:\n            result[person_id] = await self.get_associated_opportunity_ids(person_id)\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this person\n        except Exception as e:\n            if on_error == \"raise\":\n                raise AffinityError(\n                    f\"Failed to get associations for person {person_id}: {e}\"\n                ) from e\n            # skip: continue without this person\n    return result\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_fields","title":"<code>get_fields(*, field_types: Sequence[FieldType] | None = None) -&gt; builtins.list[FieldMetadata]</code>  <code>async</code>","text":"<p>Get metadata about person fields.</p> <p>Cached for performance.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_fields(\n    self,\n    *,\n    field_types: Sequence[FieldType] | None = None,\n) -&gt; builtins.list[FieldMetadata]:\n    \"\"\"\n    Get metadata about person fields.\n\n    Cached for performance.\n    \"\"\"\n    params: dict[str, Any] = {}\n    if field_types:\n        params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n\n    data = await self._client.get(\n        \"/persons/fields\",\n        params=params or None,\n        cache_key=f\"person_fields:{','.join(field_types or [])}\",\n        cache_ttl=300,\n    )\n\n    return [FieldMetadata.model_validate(f) for f in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_list_entries","title":"<code>get_list_entries(person_id: PersonId) -&gt; PaginatedResponse[ListEntry]</code>  <code>async</code>","text":"<p>Get all list entries for a person across all lists.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_list_entries(\n    self,\n    person_id: PersonId,\n) -&gt; PaginatedResponse[ListEntry]:\n    \"\"\"Get all list entries for a person across all lists.\"\"\"\n    data = await self._client.get(f\"/persons/{person_id}/list-entries\")\n\n    return PaginatedResponse[ListEntry](\n        data=[ListEntry.model_validate(e) for e in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_lists","title":"<code>get_lists(person_id: PersonId) -&gt; PaginatedResponse[ListSummary]</code>  <code>async</code>","text":"<p>Get all lists that contain this person.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_lists(\n    self,\n    person_id: PersonId,\n) -&gt; PaginatedResponse[ListSummary]:\n    \"\"\"Get all lists that contain this person.\"\"\"\n    data = await self._client.get(f\"/persons/{person_id}/lists\")\n\n    return PaginatedResponse[ListSummary](\n        data=[ListSummary.model_validate(item) for item in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.get_merge_status","title":"<code>get_merge_status(task_id: str) -&gt; MergeTask</code>  <code>async</code>","text":"<p>Check the status of a merge operation.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def get_merge_status(self, task_id: str) -&gt; MergeTask:\n    \"\"\"Check the status of a merge operation.\"\"\"\n    data = await self._client.get(f\"/tasks/person-merges/{task_id}\")\n    return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.iter","title":"<code>iter(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None) -&gt; AsyncIterator[Person]</code>","text":"<p>Auto-paginate all persons.</p> <p>Alias for <code>all()</code> (FR-006 public contract).</p> Source code in <code>affinity/services/persons.py</code> <pre><code>def iter(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n) -&gt; AsyncIterator[Person]:\n    \"\"\"\n    Auto-paginate all persons.\n\n    Alias for `all()` (FR-006 public contract).\n    \"\"\"\n    return self.all(ids=ids, field_ids=field_ids, field_types=field_types, filter=filter)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.list","title":"<code>list(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; PaginatedResponse[Person]</code>  <code>async</code>","text":"<p>Get a page of persons.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[PersonId] | None</code> <p>Specific person IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string, or a FilterExpression built via <code>affinity.F</code></p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination (opaque; obtained from prior responses)</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Person]</code> <p>Paginated response with persons</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def list(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; PaginatedResponse[Person]:\n    \"\"\"\n    Get a page of persons.\n\n    Args:\n        ids: Specific person IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include\n        filter: V2 filter expression string, or a FilterExpression built via `affinity.F`\n        limit: Maximum number of results\n        cursor: Cursor to resume pagination (opaque; obtained from prior responses)\n\n    Returns:\n        Paginated response with persons\n    \"\"\"\n    if cursor is not None:\n        if any(p is not None for p in (ids, field_ids, field_types, filter, limit)):\n            raise ValueError(\n                \"Cannot combine 'cursor' with other parameters; cursor encodes all query \"\n                \"context. Start a new pagination sequence without a cursor to change \"\n                \"parameters.\"\n            )\n        data = await self._client.get_url(cursor)\n    else:\n        params: dict[str, Any] = {}\n        if ids:\n            params[\"ids\"] = [int(id_) for id_ in ids]\n        if field_ids:\n            params[\"fieldIds\"] = [str(field_id) for field_id in field_ids]\n        if field_types:\n            params[\"fieldTypes\"] = [field_type.value for field_type in field_types]\n        if filter is not None:\n            filter_text = str(filter).strip()\n            if filter_text:\n                params[\"filter\"] = filter_text\n        if limit:\n            params[\"limit\"] = limit\n        data = await self._client.get(\"/persons\", params=params or None)\n\n    return PaginatedResponse[Person](\n        data=[Person.model_validate(p) for p in data.get(\"data\", [])],\n        pagination=PaginationInfo.model_validate(data.get(\"pagination\", {})),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.merge","title":"<code>merge(primary_id: PersonId, duplicate_id: PersonId) -&gt; str</code>  <code>async</code>","text":"<p>Merge a duplicate person into a primary person.</p> <p>Returns a task URL to check merge status.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def merge(\n    self,\n    primary_id: PersonId,\n    duplicate_id: PersonId,\n) -&gt; str:\n    \"\"\"\n    Merge a duplicate person into a primary person.\n\n    Returns a task URL to check merge status.\n    \"\"\"\n    if not self._client.enable_beta_endpoints:\n        raise BetaEndpointDisabledError(\n            \"Person merge is a beta endpoint; set enable_beta_endpoints=True to use it.\"\n        )\n    result = await self._client.post(\n        \"/person-merges\",\n        json={\n            \"primaryPersonId\": int(primary_id),\n            \"duplicatePersonId\": int(duplicate_id),\n        },\n    )\n    return str(result.get(\"taskUrl\", \"\"))\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.pages","title":"<code>pages(*, ids: Sequence[PersonId] | None = None, field_ids: Sequence[AnyFieldId] | None = None, field_types: Sequence[FieldType] | None = None, filter: str | FilterExpression | None = None, limit: int | None = None, cursor: str | None = None) -&gt; AsyncIterator[PaginatedResponse[Person]]</code>  <code>async</code>","text":"<p>Iterate person pages (not items), yielding <code>PaginatedResponse[Person]</code>.</p> <p>Useful for ETL scripts that need checkpoint/resume via <code>page.next_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Sequence[PersonId] | None</code> <p>Specific person IDs to fetch (batch lookup)</p> <code>None</code> <code>field_ids</code> <code>Sequence[AnyFieldId] | None</code> <p>Specific field IDs to include in response</p> <code>None</code> <code>field_types</code> <code>Sequence[FieldType] | None</code> <p>Field types to include</p> <code>None</code> <code>filter</code> <code>str | FilterExpression | None</code> <p>V2 filter expression string or FilterExpression</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum results per page</p> <code>None</code> <code>cursor</code> <code>str | None</code> <p>Cursor to resume pagination</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[PaginatedResponse[Person]]</code> <p>PaginatedResponse[Person] for each page</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def pages(\n    self,\n    *,\n    ids: Sequence[PersonId] | None = None,\n    field_ids: Sequence[AnyFieldId] | None = None,\n    field_types: Sequence[FieldType] | None = None,\n    filter: str | FilterExpression | None = None,\n    limit: int | None = None,\n    cursor: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[Person]]:\n    \"\"\"\n    Iterate person pages (not items), yielding `PaginatedResponse[Person]`.\n\n    Useful for ETL scripts that need checkpoint/resume via `page.next_cursor`.\n\n    Args:\n        ids: Specific person IDs to fetch (batch lookup)\n        field_ids: Specific field IDs to include in response\n        field_types: Field types to include\n        filter: V2 filter expression string or FilterExpression\n        limit: Maximum results per page\n        cursor: Cursor to resume pagination\n\n    Yields:\n        PaginatedResponse[Person] for each page\n    \"\"\"\n    other_params = (ids, field_ids, field_types, filter, limit)\n    if cursor is not None and any(p is not None for p in other_params):\n        raise ValueError(\n            \"Cannot combine 'cursor' with other parameters; cursor encodes all query context. \"\n            \"Start a new pagination sequence without a cursor to change parameters.\"\n        )\n    requested_cursor = cursor\n    if cursor is not None:\n        page = await self.list(cursor=cursor)\n    else:\n        page = await self.list(\n            ids=ids,\n            field_ids=field_ids,\n            field_types=field_types,\n            filter=filter,\n            limit=limit,\n        )\n    while True:\n        yield page\n        if not page.has_next:\n            return\n        next_cursor = page.next_cursor\n        if next_cursor is None or next_cursor == requested_cursor:\n            return\n        requested_cursor = next_cursor\n        page = await self.list(cursor=next_cursor)\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.resolve","title":"<code>resolve(*, email: str | None = None, name: str | None = None) -&gt; Person | None</code>  <code>async</code>","text":"<p>Find a single person by email or name.</p> <p>This is a convenience helper that searches and returns the first exact match, or None if not found. Uses V1 search internally.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def resolve(\n    self,\n    *,\n    email: str | None = None,\n    name: str | None = None,\n) -&gt; Person | None:\n    \"\"\"\n    Find a single person by email or name.\n\n    This is a convenience helper that searches and returns the first exact match,\n    or None if not found. Uses V1 search internally.\n    \"\"\"\n    if not email and not name:\n        raise ValueError(\"Must provide either email or name\")\n\n    term = email or name or \"\"\n    async for page in self.search_pages(term, page_size=10):\n        for person in page.data:\n            if _person_matches(person, email=email, name=name):\n                return person\n\n    return None\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.resolve_all","title":"<code>resolve_all(*, email: str | None = None, name: str | None = None) -&gt; builtins.list[Person]</code>  <code>async</code>","text":"<p>Find all persons matching an email or name.</p> <p>Notes: - This auto-paginates V1 search results to collect exact matches. - Unlike resolve(), this returns every match in server-provided order.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def resolve_all(\n    self,\n    *,\n    email: str | None = None,\n    name: str | None = None,\n) -&gt; builtins.list[Person]:\n    \"\"\"\n    Find all persons matching an email or name.\n\n    Notes:\n    - This auto-paginates V1 search results to collect exact matches.\n    - Unlike resolve(), this returns every match in server-provided order.\n    \"\"\"\n    if not email and not name:\n        raise ValueError(\"Must provide either email or name\")\n\n    term = email or name or \"\"\n    matches: builtins.list[Person] = []\n    async for page in self.search_pages(term, page_size=10):\n        for person in page.data:\n            if _person_matches(person, email=email, name=name):\n                matches.append(person)\n    return matches\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.search","title":"<code>search(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Person]</code>  <code>async</code>","text":"<p>Search for persons by name or email.</p> <p>Uses V1 API for search functionality.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def search(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Person]:\n    \"\"\"\n    Search for persons by name or email.\n\n    Uses V1 API for search functionality.\n    \"\"\"\n    params: dict[str, Any] = {\"term\": term}\n    if with_interaction_dates:\n        params[\"with_interaction_dates\"] = True\n    if with_interaction_persons:\n        params[\"with_interaction_persons\"] = True\n    if with_opportunities:\n        params[\"with_opportunities\"] = True\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = await self._client.get(\"/persons\", params=params, v1=True)\n    items = [Person.model_validate(p) for p in data.get(\"persons\", [])]\n    return PaginatedResponse[Person](\n        data=items,\n        next_page_token=data.get(\"next_page_token\"),\n    )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.search_all","title":"<code>search_all(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; AsyncIterator[Person]</code>  <code>async</code>","text":"<p>Iterate all V1 person-search results with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or email)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Person]</code> <p>Person objects matching the search term</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def search_all(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; AsyncIterator[Person]:\n    \"\"\"\n    Iterate all V1 person-search results with automatic pagination.\n\n    Args:\n        term: Search term (name or email)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        Person objects matching the search term\n    \"\"\"\n    async for page in self.search_pages(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    ):\n        for person in page.data:\n            yield person\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.search_pages","title":"<code>search_pages(term: str, *, with_interaction_dates: bool = False, with_interaction_persons: bool = False, with_opportunities: bool = False, page_size: int | None = None, page_token: str | None = None) -&gt; AsyncIterator[PaginatedResponse[Person]]</code>  <code>async</code>","text":"<p>Iterate V1 person-search result pages.</p> <p>Useful for scripts that need checkpoint/resume via <code>next_page_token</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>Search term (name or email)</p> required <code>with_interaction_dates</code> <code>bool</code> <p>Include interaction date data</p> <code>False</code> <code>with_interaction_persons</code> <code>bool</code> <p>Include persons for interactions</p> <code>False</code> <code>with_opportunities</code> <code>bool</code> <p>Include associated opportunity IDs</p> <code>False</code> <code>page_size</code> <code>int | None</code> <p>Results per page (max 500)</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Resume from this pagination token</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[PaginatedResponse[Person]]</code> <p>PaginatedResponse[Person] for each page</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def search_pages(\n    self,\n    term: str,\n    *,\n    with_interaction_dates: bool = False,\n    with_interaction_persons: bool = False,\n    with_opportunities: bool = False,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; AsyncIterator[PaginatedResponse[Person]]:\n    \"\"\"\n    Iterate V1 person-search result pages.\n\n    Useful for scripts that need checkpoint/resume via `next_page_token`.\n\n    Args:\n        term: Search term (name or email)\n        with_interaction_dates: Include interaction date data\n        with_interaction_persons: Include persons for interactions\n        with_opportunities: Include associated opportunity IDs\n        page_size: Results per page (max 500)\n        page_token: Resume from this pagination token\n\n    Yields:\n        PaginatedResponse[Person] for each page\n    \"\"\"\n    requested_token = page_token\n    page = await self.search(\n        term,\n        with_interaction_dates=with_interaction_dates,\n        with_interaction_persons=with_interaction_persons,\n        with_opportunities=with_opportunities,\n        page_size=page_size,\n        page_token=page_token,\n    )\n    while True:\n        yield page\n        next_token = page.next_page_token\n        if not next_token or next_token == requested_token:\n            return\n        requested_token = next_token\n        page = await self.search(\n            term,\n            with_interaction_dates=with_interaction_dates,\n            with_interaction_persons=with_interaction_persons,\n            with_opportunities=with_opportunities,\n            page_size=page_size,\n            page_token=next_token,\n        )\n</code></pre>"},{"location":"reference/services/persons/#affinity.services.persons.AsyncPersonService.update","title":"<code>update(person_id: PersonId, data: PersonUpdate) -&gt; Person</code>  <code>async</code>","text":"<p>Update an existing person.</p> <p>Note: To add emails/organizations, include existing values plus new ones.</p> Source code in <code>affinity/services/persons.py</code> <pre><code>async def update(\n    self,\n    person_id: PersonId,\n    data: PersonUpdate,\n) -&gt; Person:\n    \"\"\"\n    Update an existing person.\n\n    Note: To add emails/organizations, include existing values plus new ones.\n    \"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"json\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n\n    result = await self._client.put(\n        f\"/persons/{person_id}\",\n        json=payload,\n        v1=True,\n    )\n\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"person\")\n\n    return Person.model_validate(result)\n</code></pre>"},{"location":"reference/services/tasks/","title":"Tasks","text":"<p>Service for managing long-running operations (tasks).</p> <p>Provides utilities to poll and wait for async operations like merges.</p> Example Source code in <code>affinity/services/tasks.py</code> <pre><code>class TaskService:\n    \"\"\"\n    Service for managing long-running operations (tasks).\n\n    Provides utilities to poll and wait for async operations like merges.\n\n    Example:\n        # Start a merge operation\n        task_url = client.companies.merge(primary_id, duplicate_id)\n\n        # Wait for completion with timeout\n        task = client.tasks.wait(task_url, timeout=60.0)\n        if task.status == \"success\":\n            print(\"Merge completed!\")\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def get(self, task_url: str) -&gt; MergeTask:\n        \"\"\"\n        Get the current status of a task.\n\n        Args:\n            task_url: The task URL returned from an async operation\n\n        Returns:\n            MergeTask with current status\n        \"\"\"\n        # Extract task path from full URL if needed\n        data = self._client.get_url(task_url)\n        return MergeTask.model_validate(data)\n\n    def wait(\n        self,\n        task_url: str,\n        *,\n        timeout: float = 300.0,\n        poll_interval: float = 2.0,\n        max_poll_interval: float = 30.0,\n    ) -&gt; MergeTask:\n        \"\"\"\n        Wait for a task to complete with exponential backoff.\n\n        Args:\n            task_url: The task URL returned from an async operation\n            timeout: Maximum time to wait in seconds (default: 5 minutes)\n            poll_interval: Initial polling interval in seconds\n            max_poll_interval: Maximum polling interval after backoff\n\n        Returns:\n            MergeTask with final status\n\n        Raises:\n            TimeoutError: If task doesn't complete within timeout\n            AffinityError: If task fails\n        \"\"\"\n        start_time = time.monotonic()\n        current_interval = poll_interval\n\n        while True:\n            task = self.get(task_url)\n\n            if task.status in (TaskStatus.SUCCESS, TaskStatus.FAILED):\n                if task.status == TaskStatus.FAILED:\n                    raise AffinityError(\n                        f\"Task failed: {task_url}\",\n                        status_code=None,\n                        response_body={\"task\": task.model_dump()},\n                    )\n                return task\n\n            # Check timeout\n            elapsed = time.monotonic() - start_time\n            if elapsed &gt;= timeout:\n                raise AffinityTimeoutError(f\"Task did not complete within {timeout}s: {task_url}\")\n\n            # Wait with jitter before next poll\n            jitter = random.uniform(0, current_interval * 0.1)\n            time.sleep(current_interval + jitter)\n\n            # Exponential backoff, capped at max\n            current_interval = min(current_interval * 1.5, max_poll_interval)\n</code></pre> <p>Async version of TaskService.</p> Example Source code in <code>affinity/services/tasks.py</code> <pre><code>class AsyncTaskService:\n    \"\"\"\n    Async version of TaskService.\n\n    Example:\n        # Start a merge operation\n        task_url = await client.companies.merge(primary_id, duplicate_id)\n\n        # Wait for completion with timeout\n        task = await client.tasks.wait(task_url, timeout=60.0)\n    \"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        self._client = client\n\n    async def get(self, task_url: str) -&gt; MergeTask:\n        \"\"\"\n        Get the current status of a task.\n\n        Args:\n            task_url: The task URL returned from an async operation\n\n        Returns:\n            MergeTask with current status\n        \"\"\"\n        data = await self._client.get_url(task_url)\n        return MergeTask.model_validate(data)\n\n    async def wait(\n        self,\n        task_url: str,\n        *,\n        timeout: float = 300.0,\n        poll_interval: float = 2.0,\n        max_poll_interval: float = 30.0,\n    ) -&gt; MergeTask:\n        \"\"\"\n        Wait for a task to complete with exponential backoff.\n\n        Args:\n            task_url: The task URL returned from an async operation\n            timeout: Maximum time to wait in seconds (default: 5 minutes)\n            poll_interval: Initial polling interval in seconds\n            max_poll_interval: Maximum polling interval after backoff\n\n        Returns:\n            MergeTask with final status\n\n        Raises:\n            TimeoutError: If task doesn't complete within timeout\n            AffinityError: If task fails\n        \"\"\"\n        start_time = time.monotonic()\n        current_interval = poll_interval\n\n        while True:\n            task = await self.get(task_url)\n\n            if task.status in (TaskStatus.SUCCESS, TaskStatus.FAILED):\n                if task.status == TaskStatus.FAILED:\n                    raise AffinityError(\n                        f\"Task failed: {task_url}\",\n                        status_code=None,\n                        response_body={\"task\": task.model_dump()},\n                    )\n                return task\n\n            # Check timeout\n            elapsed = time.monotonic() - start_time\n            if elapsed &gt;= timeout:\n                raise AffinityTimeoutError(f\"Task did not complete within {timeout}s: {task_url}\")\n\n            # Wait with jitter before next poll\n            jitter = random.uniform(0, current_interval * 0.1)\n            await asyncio.sleep(current_interval + jitter)\n\n            # Exponential backoff, capped at max\n            current_interval = min(current_interval * 1.5, max_poll_interval)\n</code></pre>"},{"location":"reference/services/tasks/#affinity.services.tasks.TaskService--start-a-merge-operation","title":"Start a merge operation","text":"<p>task_url = client.companies.merge(primary_id, duplicate_id)</p>"},{"location":"reference/services/tasks/#affinity.services.tasks.TaskService--wait-for-completion-with-timeout","title":"Wait for completion with timeout","text":"<p>task = client.tasks.wait(task_url, timeout=60.0) if task.status == \"success\":     print(\"Merge completed!\")</p>"},{"location":"reference/services/tasks/#affinity.services.tasks.TaskService.get","title":"<code>get(task_url: str) -&gt; MergeTask</code>","text":"<p>Get the current status of a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_url</code> <code>str</code> <p>The task URL returned from an async operation</p> required <p>Returns:</p> Type Description <code>MergeTask</code> <p>MergeTask with current status</p> Source code in <code>affinity/services/tasks.py</code> <pre><code>def get(self, task_url: str) -&gt; MergeTask:\n    \"\"\"\n    Get the current status of a task.\n\n    Args:\n        task_url: The task URL returned from an async operation\n\n    Returns:\n        MergeTask with current status\n    \"\"\"\n    # Extract task path from full URL if needed\n    data = self._client.get_url(task_url)\n    return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/tasks/#affinity.services.tasks.TaskService.wait","title":"<code>wait(task_url: str, *, timeout: float = 300.0, poll_interval: float = 2.0, max_poll_interval: float = 30.0) -&gt; MergeTask</code>","text":"<p>Wait for a task to complete with exponential backoff.</p> <p>Parameters:</p> Name Type Description Default <code>task_url</code> <code>str</code> <p>The task URL returned from an async operation</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds (default: 5 minutes)</p> <code>300.0</code> <code>poll_interval</code> <code>float</code> <p>Initial polling interval in seconds</p> <code>2.0</code> <code>max_poll_interval</code> <code>float</code> <p>Maximum polling interval after backoff</p> <code>30.0</code> <p>Returns:</p> Type Description <code>MergeTask</code> <p>MergeTask with final status</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If task doesn't complete within timeout</p> <code>AffinityError</code> <p>If task fails</p> Source code in <code>affinity/services/tasks.py</code> <pre><code>def wait(\n    self,\n    task_url: str,\n    *,\n    timeout: float = 300.0,\n    poll_interval: float = 2.0,\n    max_poll_interval: float = 30.0,\n) -&gt; MergeTask:\n    \"\"\"\n    Wait for a task to complete with exponential backoff.\n\n    Args:\n        task_url: The task URL returned from an async operation\n        timeout: Maximum time to wait in seconds (default: 5 minutes)\n        poll_interval: Initial polling interval in seconds\n        max_poll_interval: Maximum polling interval after backoff\n\n    Returns:\n        MergeTask with final status\n\n    Raises:\n        TimeoutError: If task doesn't complete within timeout\n        AffinityError: If task fails\n    \"\"\"\n    start_time = time.monotonic()\n    current_interval = poll_interval\n\n    while True:\n        task = self.get(task_url)\n\n        if task.status in (TaskStatus.SUCCESS, TaskStatus.FAILED):\n            if task.status == TaskStatus.FAILED:\n                raise AffinityError(\n                    f\"Task failed: {task_url}\",\n                    status_code=None,\n                    response_body={\"task\": task.model_dump()},\n                )\n            return task\n\n        # Check timeout\n        elapsed = time.monotonic() - start_time\n        if elapsed &gt;= timeout:\n            raise AffinityTimeoutError(f\"Task did not complete within {timeout}s: {task_url}\")\n\n        # Wait with jitter before next poll\n        jitter = random.uniform(0, current_interval * 0.1)\n        time.sleep(current_interval + jitter)\n\n        # Exponential backoff, capped at max\n        current_interval = min(current_interval * 1.5, max_poll_interval)\n</code></pre>"},{"location":"reference/services/tasks/#affinity.services.tasks.AsyncTaskService--start-a-merge-operation","title":"Start a merge operation","text":"<p>task_url = await client.companies.merge(primary_id, duplicate_id)</p>"},{"location":"reference/services/tasks/#affinity.services.tasks.AsyncTaskService--wait-for-completion-with-timeout","title":"Wait for completion with timeout","text":"<p>task = await client.tasks.wait(task_url, timeout=60.0)</p>"},{"location":"reference/services/tasks/#affinity.services.tasks.AsyncTaskService.get","title":"<code>get(task_url: str) -&gt; MergeTask</code>  <code>async</code>","text":"<p>Get the current status of a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_url</code> <code>str</code> <p>The task URL returned from an async operation</p> required <p>Returns:</p> Type Description <code>MergeTask</code> <p>MergeTask with current status</p> Source code in <code>affinity/services/tasks.py</code> <pre><code>async def get(self, task_url: str) -&gt; MergeTask:\n    \"\"\"\n    Get the current status of a task.\n\n    Args:\n        task_url: The task URL returned from an async operation\n\n    Returns:\n        MergeTask with current status\n    \"\"\"\n    data = await self._client.get_url(task_url)\n    return MergeTask.model_validate(data)\n</code></pre>"},{"location":"reference/services/tasks/#affinity.services.tasks.AsyncTaskService.wait","title":"<code>wait(task_url: str, *, timeout: float = 300.0, poll_interval: float = 2.0, max_poll_interval: float = 30.0) -&gt; MergeTask</code>  <code>async</code>","text":"<p>Wait for a task to complete with exponential backoff.</p> <p>Parameters:</p> Name Type Description Default <code>task_url</code> <code>str</code> <p>The task URL returned from an async operation</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds (default: 5 minutes)</p> <code>300.0</code> <code>poll_interval</code> <code>float</code> <p>Initial polling interval in seconds</p> <code>2.0</code> <code>max_poll_interval</code> <code>float</code> <p>Maximum polling interval after backoff</p> <code>30.0</code> <p>Returns:</p> Type Description <code>MergeTask</code> <p>MergeTask with final status</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If task doesn't complete within timeout</p> <code>AffinityError</code> <p>If task fails</p> Source code in <code>affinity/services/tasks.py</code> <pre><code>async def wait(\n    self,\n    task_url: str,\n    *,\n    timeout: float = 300.0,\n    poll_interval: float = 2.0,\n    max_poll_interval: float = 30.0,\n) -&gt; MergeTask:\n    \"\"\"\n    Wait for a task to complete with exponential backoff.\n\n    Args:\n        task_url: The task URL returned from an async operation\n        timeout: Maximum time to wait in seconds (default: 5 minutes)\n        poll_interval: Initial polling interval in seconds\n        max_poll_interval: Maximum polling interval after backoff\n\n    Returns:\n        MergeTask with final status\n\n    Raises:\n        TimeoutError: If task doesn't complete within timeout\n        AffinityError: If task fails\n    \"\"\"\n    start_time = time.monotonic()\n    current_interval = poll_interval\n\n    while True:\n        task = await self.get(task_url)\n\n        if task.status in (TaskStatus.SUCCESS, TaskStatus.FAILED):\n            if task.status == TaskStatus.FAILED:\n                raise AffinityError(\n                    f\"Task failed: {task_url}\",\n                    status_code=None,\n                    response_body={\"task\": task.model_dump()},\n                )\n            return task\n\n        # Check timeout\n        elapsed = time.monotonic() - start_time\n        if elapsed &gt;= timeout:\n            raise AffinityTimeoutError(f\"Task did not complete within {timeout}s: {task_url}\")\n\n        # Wait with jitter before next poll\n        jitter = random.uniform(0, current_interval * 0.1)\n        await asyncio.sleep(current_interval + jitter)\n\n        # Exponential backoff, capped at max\n        current_interval = min(current_interval * 1.5, max_poll_interval)\n</code></pre>"},{"location":"reference/services/v1/auth/","title":"Auth (V1)","text":"<p>Service for authentication info.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class AuthService:\n    \"\"\"Service for authentication info.\"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def whoami(self) -&gt; WhoAmI:\n        \"\"\"Get info about current user and API key.\"\"\"\n        # V2 also has this endpoint\n        data = self._client.get(\"/auth/whoami\")\n        return WhoAmI.model_validate(data)\n</code></pre>"},{"location":"reference/services/v1/auth/#affinity.services.v1_only.AuthService.whoami","title":"<code>whoami() -&gt; WhoAmI</code>","text":"<p>Get info about current user and API key.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def whoami(self) -&gt; WhoAmI:\n    \"\"\"Get info about current user and API key.\"\"\"\n    # V2 also has this endpoint\n    data = self._client.get(\"/auth/whoami\")\n    return WhoAmI.model_validate(data)\n</code></pre>"},{"location":"reference/services/v1/field-values/","title":"Field values (V1)","text":"<p>Service for managing field values.</p> <p>For list entry field values, prefer ListEntryService.update_field_value(). Use this for global field values not tied to list entries.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class FieldValueService:\n    \"\"\"\n    Service for managing field values.\n\n    For list entry field values, prefer ListEntryService.update_field_value().\n    Use this for global field values not tied to list entries.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def list(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        list_entry_id: ListEntryId | None = None,\n    ) -&gt; list[FieldValue]:\n        \"\"\"\n        Get field values for an entity.\n\n        Exactly one of person_id, company_id, opportunity_id, or list_entry_id\n        must be provided.\n\n        Raises:\n            ValueError: If zero or multiple IDs are provided.\n        \"\"\"\n        provided = {\n            name: value\n            for name, value in (\n                (\"person_id\", person_id),\n                (\"company_id\", company_id),\n                (\"opportunity_id\", opportunity_id),\n                (\"list_entry_id\", list_entry_id),\n            )\n            if value is not None\n        }\n        if len(provided) == 0:\n            raise ValueError(\n                \"field_values.list() requires exactly one entity ID. \"\n                \"Example: client.field_values.list(person_id=PersonId(123))\"\n            )\n        if len(provided) &gt; 1:\n            raise ValueError(\n                f\"field_values.list() accepts only one entity ID, \"\n                f\"but received {len(provided)}: {', '.join(provided.keys())}. \"\n                \"Call list() separately for each entity.\"\n            )\n\n        params: dict[str, Any] = {}\n        if person_id is not None:\n            params[\"person_id\"] = int(person_id)\n        if company_id is not None:\n            params[\"organization_id\"] = int(company_id)\n        if opportunity_id is not None:\n            params[\"opportunity_id\"] = int(opportunity_id)\n        if list_entry_id is not None:\n            params[\"list_entry_id\"] = int(list_entry_id)\n\n        data = self._client.get(\"/field-values\", params=params or None, v1=True)\n        items = data.get(\"data\", [])\n        if not isinstance(items, list):\n            items = []\n        return [FieldValue.model_validate(v) for v in items]\n\n    def create(self, data: FieldValueCreate) -&gt; FieldValue:\n        \"\"\"\n        Create a field value (V1 API).\n\n        Note: V1 writes require numeric field IDs. The SDK accepts V2-style\n        `field-&lt;digits&gt;` IDs and converts them; enriched/relationship-intelligence\n        IDs are not supported.\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"json\", exclude_unset=True, exclude_none=True)\n        payload[\"field_id\"] = field_id_to_v1_numeric(data.field_id)\n\n        result = self._client.post(\"/field-values\", json=payload, v1=True)\n        return FieldValue.model_validate(result)\n\n    def update(self, field_value_id: FieldValueId, value: Any) -&gt; FieldValue:\n        \"\"\"Update a field value.\"\"\"\n        result = self._client.put(\n            f\"/field-values/{field_value_id}\",\n            json={\"value\": value},\n            v1=True,\n        )\n        return FieldValue.model_validate(result)\n\n    def delete(self, field_value_id: FieldValueId) -&gt; bool:\n        \"\"\"Delete a field value.\"\"\"\n        result = self._client.delete(f\"/field-values/{field_value_id}\", v1=True)\n        return bool(result.get(\"success\", False))\n\n    def get_for_entity(\n        self,\n        field_id: str | FieldId,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        list_entry_id: ListEntryId | None = None,\n        default: T = _UNSET,\n    ) -&gt; FieldValue | T | None:\n        \"\"\"\n        Get a specific field value for an entity.\n\n        Convenience method that fetches all field values and returns the one\n        matching field_id. Like dict.get(), returns None (or default) if not found.\n\n        Note: This still makes one API call to fetch all field values for the entity.\n        For entities with hundreds of field values, prefer using ``list()`` directly\n        if you need to inspect multiple fields.\n\n        Args:\n            field_id: The field to look up (accepts str or FieldId for convenience)\n            person_id: Person entity (exactly one entity ID required)\n            company_id: Company entity\n            opportunity_id: Opportunity entity\n            list_entry_id: List entry entity\n            default: Value to return if field not found (default: None)\n\n        Returns:\n            FieldValue if the field has a value, default otherwise.\n            Note: A FieldValue with ``.value is None`` still counts as \"present\" (explicit empty).\n\n        Example:\n            # Check if a person has a specific field value\n            status = client.field_values.get_for_entity(\n                \"field-123\",  # or FieldId(\"field-123\")\n                person_id=PersonId(456),\n            )\n            if status is None:\n                print(\"Field is empty\")\n            else:\n                print(f\"Value: {status.value}\")\n\n            # With default value\n            status = client.field_values.get_for_entity(\n                \"field-123\",\n                person_id=PersonId(456),\n                default=\"N/A\",\n            )\n        \"\"\"\n        all_values = self.list(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n            list_entry_id=list_entry_id,\n        )\n        # Normalize field_id for comparison (handles both str and FieldId)\n        target_id = FieldId(field_id) if not isinstance(field_id, FieldId) else field_id\n        for fv in all_values:\n            if fv.field_id == target_id:\n                return fv\n        return None if default is _UNSET else default\n\n    def list_batch(\n        self,\n        person_ids: Sequence[PersonId] | None = None,\n        company_ids: Sequence[CompanyId] | None = None,\n        opportunity_ids: Sequence[OpportunityId] | None = None,\n        *,\n        on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n    ) -&gt; dict[PersonId | CompanyId | OpportunityId, builtins.list[FieldValue]]:\n        \"\"\"\n        Get field values for multiple entities.\n\n        **Performance note:** This makes one API call per entity (O(n) calls).\n        There is no server-side batch endpoint. Use this for convenience and\n        consistent error handling, not for performance optimization.\n        For parallelism, use the async client.\n\n        Args:\n            person_ids: Sequence of person IDs (mutually exclusive with others)\n            company_ids: Sequence of company IDs\n            opportunity_ids: Sequence of opportunity IDs\n            on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n        Returns:\n            Dict mapping entity_id -&gt; list of field values.\n            Note: Dict ordering is not guaranteed; do not rely on insertion order.\n\n        Example:\n            # Check which persons have a specific field set\n            fv_map = client.field_values.list_batch(person_ids=person_ids)\n            for person_id, field_values in fv_map.items():\n                has_status = any(fv.field_id == target_field for fv in field_values)\n        \"\"\"\n        # Validate exactly one sequence provided\n        provided = [\n            (\"person_ids\", person_ids),\n            (\"company_ids\", company_ids),\n            (\"opportunity_ids\", opportunity_ids),\n        ]\n        non_none = [(name, seq) for name, seq in provided if seq is not None]\n        if len(non_none) != 1:\n            raise ValueError(\"Exactly one of person_ids, company_ids, or opportunity_ids required\")\n\n        name, ids = non_none[0]\n        result: dict[PersonId | CompanyId | OpportunityId, list[FieldValue]] = {}\n\n        for entity_id in ids:\n            try:\n                if name == \"person_ids\":\n                    result[entity_id] = self.list(person_id=cast(PersonId, entity_id))\n                elif name == \"company_ids\":\n                    result[entity_id] = self.list(company_id=cast(CompanyId, entity_id))\n                else:\n                    result[entity_id] = self.list(opportunity_id=cast(OpportunityId, entity_id))\n            except AffinityError:\n                if on_error == \"raise\":\n                    raise\n                # skip: continue without this entity\n            except Exception as e:\n                if on_error == \"raise\":\n                    # Preserve status_code if available\n                    status_code = getattr(e, \"status_code\", None)\n                    raise AffinityError(\n                        f\"Failed to get field values for {name[:-1]} {entity_id}: {e}\",\n                        status_code=status_code,\n                    ) from e\n\n        return result\n</code></pre>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.create","title":"<code>create(data: FieldValueCreate) -&gt; FieldValue</code>","text":"<p>Create a field value (V1 API).</p> <p>Note: V1 writes require numeric field IDs. The SDK accepts V2-style <code>field-&lt;digits&gt;</code> IDs and converts them; enriched/relationship-intelligence IDs are not supported.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def create(self, data: FieldValueCreate) -&gt; FieldValue:\n    \"\"\"\n    Create a field value (V1 API).\n\n    Note: V1 writes require numeric field IDs. The SDK accepts V2-style\n    `field-&lt;digits&gt;` IDs and converts them; enriched/relationship-intelligence\n    IDs are not supported.\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"json\", exclude_unset=True, exclude_none=True)\n    payload[\"field_id\"] = field_id_to_v1_numeric(data.field_id)\n\n    result = self._client.post(\"/field-values\", json=payload, v1=True)\n    return FieldValue.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.delete","title":"<code>delete(field_value_id: FieldValueId) -&gt; bool</code>","text":"<p>Delete a field value.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def delete(self, field_value_id: FieldValueId) -&gt; bool:\n    \"\"\"Delete a field value.\"\"\"\n    result = self._client.delete(f\"/field-values/{field_value_id}\", v1=True)\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.get_for_entity","title":"<code>get_for_entity(field_id: str | FieldId, *, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, list_entry_id: ListEntryId | None = None, default: T = _UNSET) -&gt; FieldValue | T | None</code>","text":"<p>Get a specific field value for an entity.</p> <p>Convenience method that fetches all field values and returns the one matching field_id. Like dict.get(), returns None (or default) if not found.</p> <p>Note: This still makes one API call to fetch all field values for the entity. For entities with hundreds of field values, prefer using <code>list()</code> directly if you need to inspect multiple fields.</p> <p>Parameters:</p> Name Type Description Default <code>field_id</code> <code>str | FieldId</code> <p>The field to look up (accepts str or FieldId for convenience)</p> required <code>person_id</code> <code>PersonId | None</code> <p>Person entity (exactly one entity ID required)</p> <code>None</code> <code>company_id</code> <code>CompanyId | None</code> <p>Company entity</p> <code>None</code> <code>opportunity_id</code> <code>OpportunityId | None</code> <p>Opportunity entity</p> <code>None</code> <code>list_entry_id</code> <code>ListEntryId | None</code> <p>List entry entity</p> <code>None</code> <code>default</code> <code>T</code> <p>Value to return if field not found (default: None)</p> <code>_UNSET</code> <p>Returns:</p> Name Type Description <code>FieldValue | T | None</code> <p>FieldValue if the field has a value, default otherwise.</p> <code>Note</code> <code>FieldValue | T | None</code> <p>A FieldValue with <code>.value is None</code> still counts as \"present\" (explicit empty).</p> Example Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get_for_entity(\n    self,\n    field_id: str | FieldId,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    list_entry_id: ListEntryId | None = None,\n    default: T = _UNSET,\n) -&gt; FieldValue | T | None:\n    \"\"\"\n    Get a specific field value for an entity.\n\n    Convenience method that fetches all field values and returns the one\n    matching field_id. Like dict.get(), returns None (or default) if not found.\n\n    Note: This still makes one API call to fetch all field values for the entity.\n    For entities with hundreds of field values, prefer using ``list()`` directly\n    if you need to inspect multiple fields.\n\n    Args:\n        field_id: The field to look up (accepts str or FieldId for convenience)\n        person_id: Person entity (exactly one entity ID required)\n        company_id: Company entity\n        opportunity_id: Opportunity entity\n        list_entry_id: List entry entity\n        default: Value to return if field not found (default: None)\n\n    Returns:\n        FieldValue if the field has a value, default otherwise.\n        Note: A FieldValue with ``.value is None`` still counts as \"present\" (explicit empty).\n\n    Example:\n        # Check if a person has a specific field value\n        status = client.field_values.get_for_entity(\n            \"field-123\",  # or FieldId(\"field-123\")\n            person_id=PersonId(456),\n        )\n        if status is None:\n            print(\"Field is empty\")\n        else:\n            print(f\"Value: {status.value}\")\n\n        # With default value\n        status = client.field_values.get_for_entity(\n            \"field-123\",\n            person_id=PersonId(456),\n            default=\"N/A\",\n        )\n    \"\"\"\n    all_values = self.list(\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n        list_entry_id=list_entry_id,\n    )\n    # Normalize field_id for comparison (handles both str and FieldId)\n    target_id = FieldId(field_id) if not isinstance(field_id, FieldId) else field_id\n    for fv in all_values:\n        if fv.field_id == target_id:\n            return fv\n    return None if default is _UNSET else default\n</code></pre>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.get_for_entity--check-if-a-person-has-a-specific-field-value","title":"Check if a person has a specific field value","text":"<p>status = client.field_values.get_for_entity(     \"field-123\",  # or FieldId(\"field-123\")     person_id=PersonId(456), ) if status is None:     print(\"Field is empty\") else:     print(f\"Value: {status.value}\")</p>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.get_for_entity--with-default-value","title":"With default value","text":"<p>status = client.field_values.get_for_entity(     \"field-123\",     person_id=PersonId(456),     default=\"N/A\", )</p>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.list","title":"<code>list(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, list_entry_id: ListEntryId | None = None) -&gt; list[FieldValue]</code>","text":"<p>Get field values for an entity.</p> <p>Exactly one of person_id, company_id, opportunity_id, or list_entry_id must be provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If zero or multiple IDs are provided.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    list_entry_id: ListEntryId | None = None,\n) -&gt; list[FieldValue]:\n    \"\"\"\n    Get field values for an entity.\n\n    Exactly one of person_id, company_id, opportunity_id, or list_entry_id\n    must be provided.\n\n    Raises:\n        ValueError: If zero or multiple IDs are provided.\n    \"\"\"\n    provided = {\n        name: value\n        for name, value in (\n            (\"person_id\", person_id),\n            (\"company_id\", company_id),\n            (\"opportunity_id\", opportunity_id),\n            (\"list_entry_id\", list_entry_id),\n        )\n        if value is not None\n    }\n    if len(provided) == 0:\n        raise ValueError(\n            \"field_values.list() requires exactly one entity ID. \"\n            \"Example: client.field_values.list(person_id=PersonId(123))\"\n        )\n    if len(provided) &gt; 1:\n        raise ValueError(\n            f\"field_values.list() accepts only one entity ID, \"\n            f\"but received {len(provided)}: {', '.join(provided.keys())}. \"\n            \"Call list() separately for each entity.\"\n        )\n\n    params: dict[str, Any] = {}\n    if person_id is not None:\n        params[\"person_id\"] = int(person_id)\n    if company_id is not None:\n        params[\"organization_id\"] = int(company_id)\n    if opportunity_id is not None:\n        params[\"opportunity_id\"] = int(opportunity_id)\n    if list_entry_id is not None:\n        params[\"list_entry_id\"] = int(list_entry_id)\n\n    data = self._client.get(\"/field-values\", params=params or None, v1=True)\n    items = data.get(\"data\", [])\n    if not isinstance(items, list):\n        items = []\n    return [FieldValue.model_validate(v) for v in items]\n</code></pre>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.list_batch","title":"<code>list_batch(person_ids: Sequence[PersonId] | None = None, company_ids: Sequence[CompanyId] | None = None, opportunity_ids: Sequence[OpportunityId] | None = None, *, on_error: Literal['raise', 'skip'] = 'raise') -&gt; dict[PersonId | CompanyId | OpportunityId, builtins.list[FieldValue]]</code>","text":"<p>Get field values for multiple entities.</p> <p>Performance note: This makes one API call per entity (O(n) calls). There is no server-side batch endpoint. Use this for convenience and consistent error handling, not for performance optimization. For parallelism, use the async client.</p> <p>Parameters:</p> Name Type Description Default <code>person_ids</code> <code>Sequence[PersonId] | None</code> <p>Sequence of person IDs (mutually exclusive with others)</p> <code>None</code> <code>company_ids</code> <code>Sequence[CompanyId] | None</code> <p>Sequence of company IDs</p> <code>None</code> <code>opportunity_ids</code> <code>Sequence[OpportunityId] | None</code> <p>Sequence of opportunity IDs</p> <code>None</code> <code>on_error</code> <code>Literal['raise', 'skip']</code> <p>How to handle errors - \"raise\" (default) or \"skip\" failed IDs</p> <code>'raise'</code> <p>Returns:</p> Name Type Description <code>dict[PersonId | CompanyId | OpportunityId, list[FieldValue]]</code> <p>Dict mapping entity_id -&gt; list of field values.</p> <code>Note</code> <code>dict[PersonId | CompanyId | OpportunityId, list[FieldValue]]</code> <p>Dict ordering is not guaranteed; do not rely on insertion order.</p> Example Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list_batch(\n    self,\n    person_ids: Sequence[PersonId] | None = None,\n    company_ids: Sequence[CompanyId] | None = None,\n    opportunity_ids: Sequence[OpportunityId] | None = None,\n    *,\n    on_error: Literal[\"raise\", \"skip\"] = \"raise\",\n) -&gt; dict[PersonId | CompanyId | OpportunityId, builtins.list[FieldValue]]:\n    \"\"\"\n    Get field values for multiple entities.\n\n    **Performance note:** This makes one API call per entity (O(n) calls).\n    There is no server-side batch endpoint. Use this for convenience and\n    consistent error handling, not for performance optimization.\n    For parallelism, use the async client.\n\n    Args:\n        person_ids: Sequence of person IDs (mutually exclusive with others)\n        company_ids: Sequence of company IDs\n        opportunity_ids: Sequence of opportunity IDs\n        on_error: How to handle errors - \"raise\" (default) or \"skip\" failed IDs\n\n    Returns:\n        Dict mapping entity_id -&gt; list of field values.\n        Note: Dict ordering is not guaranteed; do not rely on insertion order.\n\n    Example:\n        # Check which persons have a specific field set\n        fv_map = client.field_values.list_batch(person_ids=person_ids)\n        for person_id, field_values in fv_map.items():\n            has_status = any(fv.field_id == target_field for fv in field_values)\n    \"\"\"\n    # Validate exactly one sequence provided\n    provided = [\n        (\"person_ids\", person_ids),\n        (\"company_ids\", company_ids),\n        (\"opportunity_ids\", opportunity_ids),\n    ]\n    non_none = [(name, seq) for name, seq in provided if seq is not None]\n    if len(non_none) != 1:\n        raise ValueError(\"Exactly one of person_ids, company_ids, or opportunity_ids required\")\n\n    name, ids = non_none[0]\n    result: dict[PersonId | CompanyId | OpportunityId, list[FieldValue]] = {}\n\n    for entity_id in ids:\n        try:\n            if name == \"person_ids\":\n                result[entity_id] = self.list(person_id=cast(PersonId, entity_id))\n            elif name == \"company_ids\":\n                result[entity_id] = self.list(company_id=cast(CompanyId, entity_id))\n            else:\n                result[entity_id] = self.list(opportunity_id=cast(OpportunityId, entity_id))\n        except AffinityError:\n            if on_error == \"raise\":\n                raise\n            # skip: continue without this entity\n        except Exception as e:\n            if on_error == \"raise\":\n                # Preserve status_code if available\n                status_code = getattr(e, \"status_code\", None)\n                raise AffinityError(\n                    f\"Failed to get field values for {name[:-1]} {entity_id}: {e}\",\n                    status_code=status_code,\n                ) from e\n\n    return result\n</code></pre>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.list_batch--check-which-persons-have-a-specific-field-set","title":"Check which persons have a specific field set","text":"<p>fv_map = client.field_values.list_batch(person_ids=person_ids) for person_id, field_values in fv_map.items():     has_status = any(fv.field_id == target_field for fv in field_values)</p>"},{"location":"reference/services/v1/field-values/#affinity.services.v1_only.FieldValueService.update","title":"<code>update(field_value_id: FieldValueId, value: Any) -&gt; FieldValue</code>","text":"<p>Update a field value.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def update(self, field_value_id: FieldValueId, value: Any) -&gt; FieldValue:\n    \"\"\"Update a field value.\"\"\"\n    result = self._client.put(\n        f\"/field-values/{field_value_id}\",\n        json={\"value\": value},\n        v1=True,\n    )\n    return FieldValue.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/fields/","title":"Fields (V1)","text":"<p>Service for managing custom fields.</p> <p>Use V2 /fields endpoints for reading field metadata. Use V1 for creating/deleting fields.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class FieldService:\n    \"\"\"\n    Service for managing custom fields.\n\n    Use V2 /fields endpoints for reading field metadata.\n    Use V1 for creating/deleting fields.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def list(\n        self,\n        *,\n        list_id: ListId | None = None,\n        entity_type: EntityType | None = None,\n    ) -&gt; list[FieldMetadata]:\n        \"\"\"\n        Get fields (V1 API).\n\n        For list/person/company field metadata, prefer the V2 read endpoints on the\n        corresponding services when available (e.g., `client.lists.get_fields(...)`).\n        \"\"\"\n        params: dict[str, Any] = {}\n        if list_id:\n            params[\"list_id\"] = int(list_id)\n        if entity_type is not None:\n            params[\"entity_type\"] = int(entity_type)\n\n        data = self._client.get(\"/fields\", params=params or None, v1=True)\n        items = data.get(\"data\", [])\n        if not isinstance(items, list):\n            items = []\n        return [FieldMetadata.model_validate(f) for f in items]\n\n    def create(self, data: FieldCreate) -&gt; FieldMetadata:\n        \"\"\"Create a custom field.\"\"\"\n        value_type_code = to_v1_value_type_code(value_type=data.value_type, raw=None)\n        if value_type_code is None:\n            raise ValueError(f\"Field value_type has no V1 numeric mapping: {data.value_type!s}\")\n        payload = data.model_dump(by_alias=True, mode=\"json\", exclude_unset=True, exclude_none=True)\n        payload[\"entity_type\"] = int(data.entity_type)\n        payload[\"value_type\"] = value_type_code\n        for key in (\"allows_multiple\", \"is_list_specific\", \"is_required\"):\n            if not payload.get(key):\n                payload.pop(key, None)\n\n        result = self._client.post(\"/fields\", json=payload, v1=True)\n\n        # Invalidate field caches\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"field\")\n            self._client.cache.invalidate_prefix(\"list_\")\n            self._client.cache.invalidate_prefix(\"person_fields\")\n            self._client.cache.invalidate_prefix(\"company_fields\")\n\n        return FieldMetadata.model_validate(result)\n\n    def delete(self, field_id: FieldId) -&gt; bool:\n        \"\"\"\n        Delete a custom field (V1 API).\n\n        Note: V1 deletes require numeric field IDs. The SDK accepts V2-style\n        `field-&lt;digits&gt;` IDs and converts them; enriched/relationship-intelligence\n        IDs are not supported.\n        \"\"\"\n        numeric_id = field_id_to_v1_numeric(field_id)\n        result = self._client.delete(f\"/fields/{numeric_id}\", v1=True)\n\n        # Invalidate field caches\n        if self._client.cache:\n            self._client.cache.invalidate_prefix(\"field\")\n            self._client.cache.invalidate_prefix(\"list_\")\n            self._client.cache.invalidate_prefix(\"person_fields\")\n            self._client.cache.invalidate_prefix(\"company_fields\")\n\n        return bool(result.get(\"success\", False))\n\n    def exists(self, field_id: AnyFieldId) -&gt; bool:\n        \"\"\"\n        Check if a field exists.\n\n        Useful for validation before setting field values.\n\n        Note: This fetches all fields and checks locally. If your code calls\n        exists() frequently in a loop, consider caching the result of fields.list()\n        yourself.\n\n        Args:\n            field_id: The field ID to check\n\n        Returns:\n            True if the field exists, False otherwise\n\n        Example:\n            if client.fields.exists(FieldId(\"field-123\")):\n                client.field_values.create(...)\n        \"\"\"\n        target_id = FieldId(field_id) if not isinstance(field_id, FieldId) else field_id\n        fields = self.list()\n        return any(f.id == target_id for f in fields)\n\n    def get_by_name(self, name: str) -&gt; FieldMetadata | None:\n        \"\"\"\n        Find a field by its display name.\n\n        Uses case-insensitive matching (casefold for i18n support).\n\n        Note: This fetches all fields and searches locally. If your code calls\n        get_by_name() frequently in a loop, consider caching the result of\n        fields.list() yourself.\n\n        Args:\n            name: The field display name to search for\n\n        Returns:\n            FieldMetadata if found, None otherwise\n\n        Example:\n            field = client.fields.get_by_name(\"Primary Email Status\")\n            if field:\n                fv = client.field_values.get_for_entity(field.id, person_id=pid)\n        \"\"\"\n        fields = self.list()\n        name_folded = name.strip().casefold()  # Strip whitespace, then casefold for i18n\n        for field in fields:\n            if field.name.casefold() == name_folded:\n                return field\n        return None\n</code></pre>"},{"location":"reference/services/v1/fields/#affinity.services.v1_only.FieldService.create","title":"<code>create(data: FieldCreate) -&gt; FieldMetadata</code>","text":"<p>Create a custom field.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def create(self, data: FieldCreate) -&gt; FieldMetadata:\n    \"\"\"Create a custom field.\"\"\"\n    value_type_code = to_v1_value_type_code(value_type=data.value_type, raw=None)\n    if value_type_code is None:\n        raise ValueError(f\"Field value_type has no V1 numeric mapping: {data.value_type!s}\")\n    payload = data.model_dump(by_alias=True, mode=\"json\", exclude_unset=True, exclude_none=True)\n    payload[\"entity_type\"] = int(data.entity_type)\n    payload[\"value_type\"] = value_type_code\n    for key in (\"allows_multiple\", \"is_list_specific\", \"is_required\"):\n        if not payload.get(key):\n            payload.pop(key, None)\n\n    result = self._client.post(\"/fields\", json=payload, v1=True)\n\n    # Invalidate field caches\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"field\")\n        self._client.cache.invalidate_prefix(\"list_\")\n        self._client.cache.invalidate_prefix(\"person_fields\")\n        self._client.cache.invalidate_prefix(\"company_fields\")\n\n    return FieldMetadata.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/fields/#affinity.services.v1_only.FieldService.delete","title":"<code>delete(field_id: FieldId) -&gt; bool</code>","text":"<p>Delete a custom field (V1 API).</p> <p>Note: V1 deletes require numeric field IDs. The SDK accepts V2-style <code>field-&lt;digits&gt;</code> IDs and converts them; enriched/relationship-intelligence IDs are not supported.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def delete(self, field_id: FieldId) -&gt; bool:\n    \"\"\"\n    Delete a custom field (V1 API).\n\n    Note: V1 deletes require numeric field IDs. The SDK accepts V2-style\n    `field-&lt;digits&gt;` IDs and converts them; enriched/relationship-intelligence\n    IDs are not supported.\n    \"\"\"\n    numeric_id = field_id_to_v1_numeric(field_id)\n    result = self._client.delete(f\"/fields/{numeric_id}\", v1=True)\n\n    # Invalidate field caches\n    if self._client.cache:\n        self._client.cache.invalidate_prefix(\"field\")\n        self._client.cache.invalidate_prefix(\"list_\")\n        self._client.cache.invalidate_prefix(\"person_fields\")\n        self._client.cache.invalidate_prefix(\"company_fields\")\n\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/v1/fields/#affinity.services.v1_only.FieldService.exists","title":"<code>exists(field_id: AnyFieldId) -&gt; bool</code>","text":"<p>Check if a field exists.</p> <p>Useful for validation before setting field values.</p> <p>Note: This fetches all fields and checks locally. If your code calls exists() frequently in a loop, consider caching the result of fields.list() yourself.</p> <p>Parameters:</p> Name Type Description Default <code>field_id</code> <code>AnyFieldId</code> <p>The field ID to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the field exists, False otherwise</p> Example <p>if client.fields.exists(FieldId(\"field-123\")):     client.field_values.create(...)</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def exists(self, field_id: AnyFieldId) -&gt; bool:\n    \"\"\"\n    Check if a field exists.\n\n    Useful for validation before setting field values.\n\n    Note: This fetches all fields and checks locally. If your code calls\n    exists() frequently in a loop, consider caching the result of fields.list()\n    yourself.\n\n    Args:\n        field_id: The field ID to check\n\n    Returns:\n        True if the field exists, False otherwise\n\n    Example:\n        if client.fields.exists(FieldId(\"field-123\")):\n            client.field_values.create(...)\n    \"\"\"\n    target_id = FieldId(field_id) if not isinstance(field_id, FieldId) else field_id\n    fields = self.list()\n    return any(f.id == target_id for f in fields)\n</code></pre>"},{"location":"reference/services/v1/fields/#affinity.services.v1_only.FieldService.get_by_name","title":"<code>get_by_name(name: str) -&gt; FieldMetadata | None</code>","text":"<p>Find a field by its display name.</p> <p>Uses case-insensitive matching (casefold for i18n support).</p> <p>Note: This fetches all fields and searches locally. If your code calls get_by_name() frequently in a loop, consider caching the result of fields.list() yourself.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The field display name to search for</p> required <p>Returns:</p> Type Description <code>FieldMetadata | None</code> <p>FieldMetadata if found, None otherwise</p> Example <p>field = client.fields.get_by_name(\"Primary Email Status\") if field:     fv = client.field_values.get_for_entity(field.id, person_id=pid)</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get_by_name(self, name: str) -&gt; FieldMetadata | None:\n    \"\"\"\n    Find a field by its display name.\n\n    Uses case-insensitive matching (casefold for i18n support).\n\n    Note: This fetches all fields and searches locally. If your code calls\n    get_by_name() frequently in a loop, consider caching the result of\n    fields.list() yourself.\n\n    Args:\n        name: The field display name to search for\n\n    Returns:\n        FieldMetadata if found, None otherwise\n\n    Example:\n        field = client.fields.get_by_name(\"Primary Email Status\")\n        if field:\n            fv = client.field_values.get_for_entity(field.id, person_id=pid)\n    \"\"\"\n    fields = self.list()\n    name_folded = name.strip().casefold()  # Strip whitespace, then casefold for i18n\n    for field in fields:\n        if field.name.casefold() == name_folded:\n            return field\n    return None\n</code></pre>"},{"location":"reference/services/v1/fields/#affinity.services.v1_only.FieldService.list","title":"<code>list(*, list_id: ListId | None = None, entity_type: EntityType | None = None) -&gt; list[FieldMetadata]</code>","text":"<p>Get fields (V1 API).</p> <p>For list/person/company field metadata, prefer the V2 read endpoints on the corresponding services when available (e.g., <code>client.lists.get_fields(...)</code>).</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list(\n    self,\n    *,\n    list_id: ListId | None = None,\n    entity_type: EntityType | None = None,\n) -&gt; list[FieldMetadata]:\n    \"\"\"\n    Get fields (V1 API).\n\n    For list/person/company field metadata, prefer the V2 read endpoints on the\n    corresponding services when available (e.g., `client.lists.get_fields(...)`).\n    \"\"\"\n    params: dict[str, Any] = {}\n    if list_id:\n        params[\"list_id\"] = int(list_id)\n    if entity_type is not None:\n        params[\"entity_type\"] = int(entity_type)\n\n    data = self._client.get(\"/fields\", params=params or None, v1=True)\n    items = data.get(\"data\", [])\n    if not isinstance(items, list):\n        items = []\n    return [FieldMetadata.model_validate(f) for f in items]\n</code></pre>"},{"location":"reference/services/v1/files/","title":"Files (V1)","text":"<p>Service for managing files attached to entities.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class EntityFileService:\n    \"\"\"Service for managing files attached to entities.\"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def _validate_exactly_one_target(\n        self,\n        *,\n        person_id: PersonId | None,\n        company_id: CompanyId | None,\n        opportunity_id: OpportunityId | None,\n    ) -&gt; None:\n        targets = [person_id, company_id, opportunity_id]\n        count = sum(1 for t in targets if t is not None)\n        if count == 1:\n            return\n        if count == 0:\n            raise ValueError(\"Exactly one of person_id, company_id, or opportunity_id is required\")\n        raise ValueError(\"Only one of person_id, company_id, or opportunity_id may be provided\")\n\n    def list(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[EntityFile]:\n        \"\"\"Get files attached to an entity.\"\"\"\n        self._validate_exactly_one_target(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n        params: dict[str, Any] = {}\n        if person_id:\n            params[\"person_id\"] = int(person_id)\n        if company_id:\n            params[\"organization_id\"] = int(company_id)\n        if opportunity_id:\n            params[\"opportunity_id\"] = int(opportunity_id)\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = self._client.get(\"/entity-files\", params=params or None, v1=True)\n        items = (\n            data.get(\"entity_files\")\n            or data.get(\"entityFiles\")\n            or data.get(\"files\")\n            or data.get(\"data\", [])\n        )\n        if not isinstance(items, list):\n            items = []\n        return PaginatedResponse[EntityFile](\n            data=[EntityFile.model_validate(f) for f in items],\n            next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n        )\n\n    def get(self, file_id: FileId) -&gt; EntityFile:\n        \"\"\"Get file metadata.\"\"\"\n        data = self._client.get(f\"/entity-files/{file_id}\", v1=True)\n        return EntityFile.model_validate(data)\n\n    def download(\n        self,\n        file_id: FileId,\n        *,\n        timeout: httpx.Timeout | float | None = None,\n        deadline_seconds: float | None = None,\n    ) -&gt; bytes:\n        \"\"\"Download file content.\"\"\"\n        return self._client.download_file(\n            f\"/entity-files/download/{file_id}\",\n            v1=True,\n            timeout=timeout,\n            deadline_seconds=deadline_seconds,\n        )\n\n    def get_download_url(\n        self,\n        file_id: FileId,\n        *,\n        timeout: httpx.Timeout | float | None = None,\n    ) -&gt; PresignedUrl:\n        \"\"\"\n        Get a presigned download URL for a file without downloading its content.\n\n        The returned URL is valid for approximately 60 seconds and can be\n        fetched without authentication (it's self-authenticating via signature).\n\n        Args:\n            file_id: The entity file ID\n            timeout: Optional request timeout\n\n        Returns:\n            PresignedUrl with the URL, file metadata, and expiration info\n\n        Raises:\n            AffinityError: If the API doesn't return a redirect URL\n        \"\"\"\n        # Fetch file metadata first\n        file_meta = self.get(file_id)\n\n        url = self._client.get_redirect_url(\n            f\"/entity-files/download/{file_id}\",\n            v1=True,\n            timeout=timeout,\n        )\n        if not url:\n            raise AffinityError(\n                f\"Failed to get presigned URL for file {file_id}: no redirect returned\"\n            )\n\n        # Parse X-Amz-Expires from the presigned URL to determine TTL\n        # Default to 60 seconds if not found (Affinity's typical TTL)\n        parsed = urlparse(url)\n        qs = parse_qs(parsed.query)\n        expires_in = 60  # default\n        if \"X-Amz-Expires\" in qs:\n            with contextlib.suppress(ValueError, IndexError):\n                expires_in = int(qs[\"X-Amz-Expires\"][0])\n\n        now = datetime.now(timezone.utc)\n        expires_at = now + timedelta(seconds=expires_in)\n\n        return PresignedUrl(\n            url=url,\n            file_id=int(file_id),\n            name=file_meta.name,\n            size=file_meta.size,\n            content_type=file_meta.content_type,\n            expires_in=expires_in,\n            expires_at=expires_at,\n        )\n\n    def download_stream(\n        self,\n        file_id: FileId,\n        *,\n        chunk_size: int = 65_536,\n        on_progress: ProgressCallback | None = None,\n        timeout: httpx.Timeout | float | None = None,\n        deadline_seconds: float | None = None,\n    ) -&gt; Iterator[bytes]:\n        \"\"\"Stream-download file content in chunks.\"\"\"\n        return self._client.stream_download(\n            f\"/entity-files/download/{file_id}\",\n            v1=True,\n            chunk_size=chunk_size,\n            on_progress=on_progress,\n            timeout=timeout,\n            deadline_seconds=deadline_seconds,\n        )\n\n    def download_stream_with_info(\n        self,\n        file_id: FileId,\n        *,\n        chunk_size: int = 65_536,\n        on_progress: ProgressCallback | None = None,\n        timeout: httpx.Timeout | float | None = None,\n        deadline_seconds: float | None = None,\n    ) -&gt; DownloadedFile:\n        \"\"\"\n        Stream-download a file and return response metadata (headers/filename/size).\n\n        Notes:\n        - `filename` is derived from `Content-Disposition` when present.\n        - If the server does not provide a filename, callers can fall back to\n          `files.get(file_id).name`.\n        \"\"\"\n        return self._client.stream_download_with_info(\n            f\"/entity-files/download/{file_id}\",\n            v1=True,\n            chunk_size=chunk_size,\n            on_progress=on_progress,\n            timeout=timeout,\n            deadline_seconds=deadline_seconds,\n        )\n\n    def download_to(\n        self,\n        file_id: FileId,\n        path: str | Path,\n        *,\n        overwrite: bool = False,\n        chunk_size: int = 65_536,\n        on_progress: ProgressCallback | None = None,\n        timeout: httpx.Timeout | float | None = None,\n        deadline_seconds: float | None = None,\n    ) -&gt; Path:\n        \"\"\"\n        Download a file to disk.\n\n        Args:\n            file_id: The entity file id\n            path: Destination path\n            overwrite: If False, raises FileExistsError when path exists\n            chunk_size: Bytes per chunk\n\n        Returns:\n            The destination path\n        \"\"\"\n        target = Path(path)\n        if target.exists() and not overwrite:\n            raise FileExistsError(str(target))\n\n        try:\n            with target.open(\"wb\") as f:\n                for chunk in self.download_stream(\n                    file_id,\n                    chunk_size=chunk_size,\n                    on_progress=on_progress,\n                    timeout=timeout,\n                    deadline_seconds=deadline_seconds,\n                ):\n                    f.write(chunk)\n        except Exception:\n            # Clean up partial file on error\n            if target.exists():\n                target.unlink()\n            raise\n\n        return target\n\n    def upload(\n        self,\n        files: dict[str, Any],\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Upload files to an entity.\n\n        Args:\n            files: Dict of filename to file-like object\n            person_id: Person to attach to\n            company_id: Company to attach to\n            opportunity_id: Opportunity to attach to\n\n        Returns:\n            List of created file records\n        \"\"\"\n        self._validate_exactly_one_target(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n        data: dict[str, Any] = {}\n        if person_id:\n            data[\"person_id\"] = int(person_id)\n        if company_id:\n            data[\"organization_id\"] = int(company_id)\n        if opportunity_id:\n            data[\"opportunity_id\"] = int(opportunity_id)\n\n        result = self._client.upload_file(\n            \"/entity-files\",\n            files=files,\n            data=data,\n            v1=True,\n        )\n        if \"success\" in result:\n            return bool(result.get(\"success\"))\n        # If the API returns something else on success (e.g., created object),\n        # treat any 2xx JSON response as success (4xx/5xx raise earlier).\n        return True\n\n    def upload_path(\n        self,\n        path: str | Path,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        filename: str | None = None,\n        content_type: str | None = None,\n        on_progress: ProgressCallback | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Upload a file from disk.\n\n        Notes:\n        - Returns only a boolean because the API returns `{\"success\": true}` for uploads.\n        - Progress reporting is best-effort for uploads (start/end only).\n        \"\"\"\n        self._validate_exactly_one_target(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n\n        p = Path(path)\n        upload_filename = filename or p.name\n        guessed, _ = mimetypes.guess_type(upload_filename)\n        final_content_type = content_type or guessed or \"application/octet-stream\"\n        total = p.stat().st_size\n\n        if on_progress:\n            on_progress(0, total, phase=\"upload\")\n\n        with p.open(\"rb\") as f:\n            ok = self.upload(\n                files={\"file\": (upload_filename, f, final_content_type)},\n                person_id=person_id,\n                company_id=company_id,\n                opportunity_id=opportunity_id,\n            )\n\n        if on_progress:\n            on_progress(total, total, phase=\"upload\")\n\n        return ok\n\n    def upload_bytes(\n        self,\n        data: bytes,\n        filename: str,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        content_type: str | None = None,\n        on_progress: ProgressCallback | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Upload in-memory bytes as a file.\n\n        Notes:\n        - Returns only a boolean because the API returns `{\"success\": true}` for uploads.\n        - Progress reporting is best-effort for uploads (start/end only).\n        \"\"\"\n        self._validate_exactly_one_target(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n\n        guessed, _ = mimetypes.guess_type(filename)\n        final_content_type = content_type or guessed or \"application/octet-stream\"\n        total = len(data)\n\n        if on_progress:\n            on_progress(0, total, phase=\"upload\")\n\n        ok = self.upload(\n            files={\"file\": (filename, data, final_content_type)},\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n\n        if on_progress:\n            on_progress(total, total, phase=\"upload\")\n\n        return ok\n\n    def all(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n    ) -&gt; Iterator[EntityFile]:\n        \"\"\"Iterate through all files for an entity with automatic pagination.\"\"\"\n        self._validate_exactly_one_target(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n\n        page_token: str | None = None\n        while True:\n            page = self.list(\n                person_id=person_id,\n                company_id=company_id,\n                opportunity_id=opportunity_id,\n                page_token=page_token,\n            )\n            yield from page.data\n            if not page.has_next:\n                break\n            page_token = page.next_page_token\n\n    def iter(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n    ) -&gt; Iterator[EntityFile]:\n        \"\"\"Auto-paginate all files (alias for `all()`).\"\"\"\n        return self.all(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.all","title":"<code>all(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None) -&gt; Iterator[EntityFile]</code>","text":"<p>Iterate through all files for an entity with automatic pagination.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def all(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n) -&gt; Iterator[EntityFile]:\n    \"\"\"Iterate through all files for an entity with automatic pagination.\"\"\"\n    self._validate_exactly_one_target(\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n    )\n\n    page_token: str | None = None\n    while True:\n        page = self.list(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n            page_token=page_token,\n        )\n        yield from page.data\n        if not page.has_next:\n            break\n        page_token = page.next_page_token\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.download","title":"<code>download(file_id: FileId, *, timeout: httpx.Timeout | float | None = None, deadline_seconds: float | None = None) -&gt; bytes</code>","text":"<p>Download file content.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def download(\n    self,\n    file_id: FileId,\n    *,\n    timeout: httpx.Timeout | float | None = None,\n    deadline_seconds: float | None = None,\n) -&gt; bytes:\n    \"\"\"Download file content.\"\"\"\n    return self._client.download_file(\n        f\"/entity-files/download/{file_id}\",\n        v1=True,\n        timeout=timeout,\n        deadline_seconds=deadline_seconds,\n    )\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.download_stream","title":"<code>download_stream(file_id: FileId, *, chunk_size: int = 65536, on_progress: ProgressCallback | None = None, timeout: httpx.Timeout | float | None = None, deadline_seconds: float | None = None) -&gt; Iterator[bytes]</code>","text":"<p>Stream-download file content in chunks.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def download_stream(\n    self,\n    file_id: FileId,\n    *,\n    chunk_size: int = 65_536,\n    on_progress: ProgressCallback | None = None,\n    timeout: httpx.Timeout | float | None = None,\n    deadline_seconds: float | None = None,\n) -&gt; Iterator[bytes]:\n    \"\"\"Stream-download file content in chunks.\"\"\"\n    return self._client.stream_download(\n        f\"/entity-files/download/{file_id}\",\n        v1=True,\n        chunk_size=chunk_size,\n        on_progress=on_progress,\n        timeout=timeout,\n        deadline_seconds=deadline_seconds,\n    )\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.download_stream_with_info","title":"<code>download_stream_with_info(file_id: FileId, *, chunk_size: int = 65536, on_progress: ProgressCallback | None = None, timeout: httpx.Timeout | float | None = None, deadline_seconds: float | None = None) -&gt; DownloadedFile</code>","text":"<p>Stream-download a file and return response metadata (headers/filename/size).</p> <p>Notes: - <code>filename</code> is derived from <code>Content-Disposition</code> when present. - If the server does not provide a filename, callers can fall back to   <code>files.get(file_id).name</code>.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def download_stream_with_info(\n    self,\n    file_id: FileId,\n    *,\n    chunk_size: int = 65_536,\n    on_progress: ProgressCallback | None = None,\n    timeout: httpx.Timeout | float | None = None,\n    deadline_seconds: float | None = None,\n) -&gt; DownloadedFile:\n    \"\"\"\n    Stream-download a file and return response metadata (headers/filename/size).\n\n    Notes:\n    - `filename` is derived from `Content-Disposition` when present.\n    - If the server does not provide a filename, callers can fall back to\n      `files.get(file_id).name`.\n    \"\"\"\n    return self._client.stream_download_with_info(\n        f\"/entity-files/download/{file_id}\",\n        v1=True,\n        chunk_size=chunk_size,\n        on_progress=on_progress,\n        timeout=timeout,\n        deadline_seconds=deadline_seconds,\n    )\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.download_to","title":"<code>download_to(file_id: FileId, path: str | Path, *, overwrite: bool = False, chunk_size: int = 65536, on_progress: ProgressCallback | None = None, timeout: httpx.Timeout | float | None = None, deadline_seconds: float | None = None) -&gt; Path</code>","text":"<p>Download a file to disk.</p> <p>Parameters:</p> Name Type Description Default <code>file_id</code> <code>FileId</code> <p>The entity file id</p> required <code>path</code> <code>str | Path</code> <p>Destination path</p> required <code>overwrite</code> <code>bool</code> <p>If False, raises FileExistsError when path exists</p> <code>False</code> <code>chunk_size</code> <code>int</code> <p>Bytes per chunk</p> <code>65536</code> <p>Returns:</p> Type Description <code>Path</code> <p>The destination path</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def download_to(\n    self,\n    file_id: FileId,\n    path: str | Path,\n    *,\n    overwrite: bool = False,\n    chunk_size: int = 65_536,\n    on_progress: ProgressCallback | None = None,\n    timeout: httpx.Timeout | float | None = None,\n    deadline_seconds: float | None = None,\n) -&gt; Path:\n    \"\"\"\n    Download a file to disk.\n\n    Args:\n        file_id: The entity file id\n        path: Destination path\n        overwrite: If False, raises FileExistsError when path exists\n        chunk_size: Bytes per chunk\n\n    Returns:\n        The destination path\n    \"\"\"\n    target = Path(path)\n    if target.exists() and not overwrite:\n        raise FileExistsError(str(target))\n\n    try:\n        with target.open(\"wb\") as f:\n            for chunk in self.download_stream(\n                file_id,\n                chunk_size=chunk_size,\n                on_progress=on_progress,\n                timeout=timeout,\n                deadline_seconds=deadline_seconds,\n            ):\n                f.write(chunk)\n    except Exception:\n        # Clean up partial file on error\n        if target.exists():\n            target.unlink()\n        raise\n\n    return target\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.get","title":"<code>get(file_id: FileId) -&gt; EntityFile</code>","text":"<p>Get file metadata.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get(self, file_id: FileId) -&gt; EntityFile:\n    \"\"\"Get file metadata.\"\"\"\n    data = self._client.get(f\"/entity-files/{file_id}\", v1=True)\n    return EntityFile.model_validate(data)\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.get_download_url","title":"<code>get_download_url(file_id: FileId, *, timeout: httpx.Timeout | float | None = None) -&gt; PresignedUrl</code>","text":"<p>Get a presigned download URL for a file without downloading its content.</p> <p>The returned URL is valid for approximately 60 seconds and can be fetched without authentication (it's self-authenticating via signature).</p> <p>Parameters:</p> Name Type Description Default <code>file_id</code> <code>FileId</code> <p>The entity file ID</p> required <code>timeout</code> <code>Timeout | float | None</code> <p>Optional request timeout</p> <code>None</code> <p>Returns:</p> Type Description <code>PresignedUrl</code> <p>PresignedUrl with the URL, file metadata, and expiration info</p> <p>Raises:</p> Type Description <code>AffinityError</code> <p>If the API doesn't return a redirect URL</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get_download_url(\n    self,\n    file_id: FileId,\n    *,\n    timeout: httpx.Timeout | float | None = None,\n) -&gt; PresignedUrl:\n    \"\"\"\n    Get a presigned download URL for a file without downloading its content.\n\n    The returned URL is valid for approximately 60 seconds and can be\n    fetched without authentication (it's self-authenticating via signature).\n\n    Args:\n        file_id: The entity file ID\n        timeout: Optional request timeout\n\n    Returns:\n        PresignedUrl with the URL, file metadata, and expiration info\n\n    Raises:\n        AffinityError: If the API doesn't return a redirect URL\n    \"\"\"\n    # Fetch file metadata first\n    file_meta = self.get(file_id)\n\n    url = self._client.get_redirect_url(\n        f\"/entity-files/download/{file_id}\",\n        v1=True,\n        timeout=timeout,\n    )\n    if not url:\n        raise AffinityError(\n            f\"Failed to get presigned URL for file {file_id}: no redirect returned\"\n        )\n\n    # Parse X-Amz-Expires from the presigned URL to determine TTL\n    # Default to 60 seconds if not found (Affinity's typical TTL)\n    parsed = urlparse(url)\n    qs = parse_qs(parsed.query)\n    expires_in = 60  # default\n    if \"X-Amz-Expires\" in qs:\n        with contextlib.suppress(ValueError, IndexError):\n            expires_in = int(qs[\"X-Amz-Expires\"][0])\n\n    now = datetime.now(timezone.utc)\n    expires_at = now + timedelta(seconds=expires_in)\n\n    return PresignedUrl(\n        url=url,\n        file_id=int(file_id),\n        name=file_meta.name,\n        size=file_meta.size,\n        content_type=file_meta.content_type,\n        expires_in=expires_in,\n        expires_at=expires_at,\n    )\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.iter","title":"<code>iter(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None) -&gt; Iterator[EntityFile]</code>","text":"<p>Auto-paginate all files (alias for <code>all()</code>).</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def iter(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n) -&gt; Iterator[EntityFile]:\n    \"\"\"Auto-paginate all files (alias for `all()`).\"\"\"\n    return self.all(\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n    )\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.list","title":"<code>list(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[EntityFile]</code>","text":"<p>Get files attached to an entity.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[EntityFile]:\n    \"\"\"Get files attached to an entity.\"\"\"\n    self._validate_exactly_one_target(\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n    )\n    params: dict[str, Any] = {}\n    if person_id:\n        params[\"person_id\"] = int(person_id)\n    if company_id:\n        params[\"organization_id\"] = int(company_id)\n    if opportunity_id:\n        params[\"opportunity_id\"] = int(opportunity_id)\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = self._client.get(\"/entity-files\", params=params or None, v1=True)\n    items = (\n        data.get(\"entity_files\")\n        or data.get(\"entityFiles\")\n        or data.get(\"files\")\n        or data.get(\"data\", [])\n    )\n    if not isinstance(items, list):\n        items = []\n    return PaginatedResponse[EntityFile](\n        data=[EntityFile.model_validate(f) for f in items],\n        next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n    )\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.upload","title":"<code>upload(files: dict[str, Any], *, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None) -&gt; bool</code>","text":"<p>Upload files to an entity.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>dict[str, Any]</code> <p>Dict of filename to file-like object</p> required <code>person_id</code> <code>PersonId | None</code> <p>Person to attach to</p> <code>None</code> <code>company_id</code> <code>CompanyId | None</code> <p>Company to attach to</p> <code>None</code> <code>opportunity_id</code> <code>OpportunityId | None</code> <p>Opportunity to attach to</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>List of created file records</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def upload(\n    self,\n    files: dict[str, Any],\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n) -&gt; bool:\n    \"\"\"\n    Upload files to an entity.\n\n    Args:\n        files: Dict of filename to file-like object\n        person_id: Person to attach to\n        company_id: Company to attach to\n        opportunity_id: Opportunity to attach to\n\n    Returns:\n        List of created file records\n    \"\"\"\n    self._validate_exactly_one_target(\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n    )\n    data: dict[str, Any] = {}\n    if person_id:\n        data[\"person_id\"] = int(person_id)\n    if company_id:\n        data[\"organization_id\"] = int(company_id)\n    if opportunity_id:\n        data[\"opportunity_id\"] = int(opportunity_id)\n\n    result = self._client.upload_file(\n        \"/entity-files\",\n        files=files,\n        data=data,\n        v1=True,\n    )\n    if \"success\" in result:\n        return bool(result.get(\"success\"))\n    # If the API returns something else on success (e.g., created object),\n    # treat any 2xx JSON response as success (4xx/5xx raise earlier).\n    return True\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.upload_bytes","title":"<code>upload_bytes(data: bytes, filename: str, *, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, content_type: str | None = None, on_progress: ProgressCallback | None = None) -&gt; bool</code>","text":"<p>Upload in-memory bytes as a file.</p> <p>Notes: - Returns only a boolean because the API returns <code>{\"success\": true}</code> for uploads. - Progress reporting is best-effort for uploads (start/end only).</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def upload_bytes(\n    self,\n    data: bytes,\n    filename: str,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    content_type: str | None = None,\n    on_progress: ProgressCallback | None = None,\n) -&gt; bool:\n    \"\"\"\n    Upload in-memory bytes as a file.\n\n    Notes:\n    - Returns only a boolean because the API returns `{\"success\": true}` for uploads.\n    - Progress reporting is best-effort for uploads (start/end only).\n    \"\"\"\n    self._validate_exactly_one_target(\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n    )\n\n    guessed, _ = mimetypes.guess_type(filename)\n    final_content_type = content_type or guessed or \"application/octet-stream\"\n    total = len(data)\n\n    if on_progress:\n        on_progress(0, total, phase=\"upload\")\n\n    ok = self.upload(\n        files={\"file\": (filename, data, final_content_type)},\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n    )\n\n    if on_progress:\n        on_progress(total, total, phase=\"upload\")\n\n    return ok\n</code></pre>"},{"location":"reference/services/v1/files/#affinity.services.v1_only.EntityFileService.upload_path","title":"<code>upload_path(path: str | Path, *, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, filename: str | None = None, content_type: str | None = None, on_progress: ProgressCallback | None = None) -&gt; bool</code>","text":"<p>Upload a file from disk.</p> <p>Notes: - Returns only a boolean because the API returns <code>{\"success\": true}</code> for uploads. - Progress reporting is best-effort for uploads (start/end only).</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def upload_path(\n    self,\n    path: str | Path,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    filename: str | None = None,\n    content_type: str | None = None,\n    on_progress: ProgressCallback | None = None,\n) -&gt; bool:\n    \"\"\"\n    Upload a file from disk.\n\n    Notes:\n    - Returns only a boolean because the API returns `{\"success\": true}` for uploads.\n    - Progress reporting is best-effort for uploads (start/end only).\n    \"\"\"\n    self._validate_exactly_one_target(\n        person_id=person_id,\n        company_id=company_id,\n        opportunity_id=opportunity_id,\n    )\n\n    p = Path(path)\n    upload_filename = filename or p.name\n    guessed, _ = mimetypes.guess_type(upload_filename)\n    final_content_type = content_type or guessed or \"application/octet-stream\"\n    total = p.stat().st_size\n\n    if on_progress:\n        on_progress(0, total, phase=\"upload\")\n\n    with p.open(\"rb\") as f:\n        ok = self.upload(\n            files={\"file\": (upload_filename, f, final_content_type)},\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n        )\n\n    if on_progress:\n        on_progress(total, total, phase=\"upload\")\n\n    return ok\n</code></pre>"},{"location":"reference/services/v1/interactions/","title":"Interactions (V1)","text":"<p>Service for managing interactions (meetings, calls, emails, chats).</p> <p>V2 provides read-only metadata; V1 supports full CRUD.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class InteractionService:\n    \"\"\"\n    Service for managing interactions (meetings, calls, emails, chats).\n\n    V2 provides read-only metadata; V1 supports full CRUD.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def list(\n        self,\n        *,\n        type: InteractionType | None = None,\n        start_time: datetime | None = None,\n        end_time: datetime | None = None,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Interaction]:\n        \"\"\"\n        Get interactions with optional filtering.\n\n        The Affinity API requires:\n        - type: Interaction type (meeting, call, email, chat)\n        - start_time and end_time: Date range (max 1 year)\n        - One entity ID: person_id, company_id, or opportunity_id\n\n        Returns V1 paginated response with `data` and `next_page_token`.\n\n        Raises:\n            ValueError: If type is not provided (required by Affinity V1 API)\n        \"\"\"\n        if type is None:\n            raise ValueError(\n                \"type is required for interactions API. \"\n                \"Use InteractionType.EMAIL, MEETING, CALL, or CHAT_MESSAGE.\"\n            )\n        params: dict[str, Any] = {\"type\": int(type)}\n        if start_time:\n            params[\"start_time\"] = start_time.isoformat()\n        if end_time:\n            params[\"end_time\"] = end_time.isoformat()\n        if person_id:\n            params[\"person_id\"] = int(person_id)\n        if company_id:\n            params[\"organization_id\"] = int(company_id)\n        if opportunity_id:\n            params[\"opportunity_id\"] = int(opportunity_id)\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = self._client.get(\"/interactions\", params=params or None, v1=True)\n        items: Any = None\n        if type is not None:\n            if int(type) in (int(InteractionType.MEETING), int(InteractionType.CALL)):\n                items = data.get(\"events\")\n            elif int(type) == int(InteractionType.CHAT_MESSAGE):\n                items = data.get(\"chat_messages\")\n            elif int(type) == int(InteractionType.EMAIL):\n                items = data.get(\"emails\")\n\n        if items is None:\n            items = (\n                data.get(\"interactions\")\n                or data.get(\"events\")\n                or data.get(\"emails\")\n                or data.get(\"chat_messages\")\n                or data.get(\"data\", [])\n            )\n        if not isinstance(items, list):\n            items = []\n        return PaginatedResponse[Interaction](\n            data=[Interaction.model_validate(i) for i in items],\n            next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n        )\n\n    def get(self, interaction_id: InteractionId, type: InteractionType) -&gt; Interaction:\n        \"\"\"Get a single interaction by ID and type.\"\"\"\n        data = self._client.get(\n            f\"/interactions/{int(interaction_id)}\",\n            params={\"type\": int(type)},\n            v1=True,\n        )\n        return Interaction.model_validate(data)\n\n    def create(self, data: InteractionCreate) -&gt; Interaction:\n        \"\"\"Create a new interaction (manually logged).\"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n        _coerce_isoformat(payload, (\"date\",))\n\n        result = self._client.post(\"/interactions\", json=payload, v1=True)\n        return Interaction.model_validate(result)\n\n    def update(\n        self,\n        interaction_id: InteractionId,\n        type: InteractionType,\n        data: InteractionUpdate,\n    ) -&gt; Interaction:\n        \"\"\"Update an interaction.\"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"python\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n        payload[\"type\"] = int(type)\n        _coerce_isoformat(payload, (\"date\",))\n\n        result = self._client.put(\n            f\"/interactions/{int(interaction_id)}\",\n            json=payload,\n            v1=True,\n        )\n        return Interaction.model_validate(result)\n\n    def delete(self, interaction_id: InteractionId, type: InteractionType) -&gt; bool:\n        \"\"\"Delete an interaction.\"\"\"\n        result = self._client.delete(\n            f\"/interactions/{int(interaction_id)}\",\n            params={\"type\": int(type)},\n            v1=True,\n        )\n        return bool(result.get(\"success\", False))\n\n    def iter(\n        self,\n        *,\n        type: InteractionType | None = None,\n        start_time: datetime | None = None,\n        end_time: datetime | None = None,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        page_size: int | None = None,\n    ) -&gt; PageIterator[Interaction]:\n        \"\"\"\n        Iterate through all interactions with automatic pagination.\n\n        The Affinity API requires:\n        - type: Interaction type (meeting, call, email, chat)\n        - start_time and end_time: Date range (max 1 year)\n        - One entity ID: person_id, company_id, or opportunity_id\n\n        Returns:\n            PageIterator that yields Interaction objects\n        \"\"\"\n\n        def fetch_page(cursor: str | None) -&gt; PaginatedResponse[Interaction]:\n            return self.list(\n                type=type,\n                start_time=start_time,\n                end_time=end_time,\n                person_id=person_id,\n                company_id=company_id,\n                opportunity_id=opportunity_id,\n                page_size=page_size,\n                page_token=cursor,\n            )\n\n        return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/v1/interactions/#affinity.services.v1_only.InteractionService.create","title":"<code>create(data: InteractionCreate) -&gt; Interaction</code>","text":"<p>Create a new interaction (manually logged).</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def create(self, data: InteractionCreate) -&gt; Interaction:\n    \"\"\"Create a new interaction (manually logged).\"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n    _coerce_isoformat(payload, (\"date\",))\n\n    result = self._client.post(\"/interactions\", json=payload, v1=True)\n    return Interaction.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/interactions/#affinity.services.v1_only.InteractionService.delete","title":"<code>delete(interaction_id: InteractionId, type: InteractionType) -&gt; bool</code>","text":"<p>Delete an interaction.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def delete(self, interaction_id: InteractionId, type: InteractionType) -&gt; bool:\n    \"\"\"Delete an interaction.\"\"\"\n    result = self._client.delete(\n        f\"/interactions/{int(interaction_id)}\",\n        params={\"type\": int(type)},\n        v1=True,\n    )\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/v1/interactions/#affinity.services.v1_only.InteractionService.get","title":"<code>get(interaction_id: InteractionId, type: InteractionType) -&gt; Interaction</code>","text":"<p>Get a single interaction by ID and type.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get(self, interaction_id: InteractionId, type: InteractionType) -&gt; Interaction:\n    \"\"\"Get a single interaction by ID and type.\"\"\"\n    data = self._client.get(\n        f\"/interactions/{int(interaction_id)}\",\n        params={\"type\": int(type)},\n        v1=True,\n    )\n    return Interaction.model_validate(data)\n</code></pre>"},{"location":"reference/services/v1/interactions/#affinity.services.v1_only.InteractionService.iter","title":"<code>iter(*, type: InteractionType | None = None, start_time: datetime | None = None, end_time: datetime | None = None, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, page_size: int | None = None) -&gt; PageIterator[Interaction]</code>","text":"<p>Iterate through all interactions with automatic pagination.</p> <p>The Affinity API requires: - type: Interaction type (meeting, call, email, chat) - start_time and end_time: Date range (max 1 year) - One entity ID: person_id, company_id, or opportunity_id</p> <p>Returns:</p> Type Description <code>PageIterator[Interaction]</code> <p>PageIterator that yields Interaction objects</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def iter(\n    self,\n    *,\n    type: InteractionType | None = None,\n    start_time: datetime | None = None,\n    end_time: datetime | None = None,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    page_size: int | None = None,\n) -&gt; PageIterator[Interaction]:\n    \"\"\"\n    Iterate through all interactions with automatic pagination.\n\n    The Affinity API requires:\n    - type: Interaction type (meeting, call, email, chat)\n    - start_time and end_time: Date range (max 1 year)\n    - One entity ID: person_id, company_id, or opportunity_id\n\n    Returns:\n        PageIterator that yields Interaction objects\n    \"\"\"\n\n    def fetch_page(cursor: str | None) -&gt; PaginatedResponse[Interaction]:\n        return self.list(\n            type=type,\n            start_time=start_time,\n            end_time=end_time,\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n            page_size=page_size,\n            page_token=cursor,\n        )\n\n    return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/v1/interactions/#affinity.services.v1_only.InteractionService.list","title":"<code>list(*, type: InteractionType | None = None, start_time: datetime | None = None, end_time: datetime | None = None, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Interaction]</code>","text":"<p>Get interactions with optional filtering.</p> <p>The Affinity API requires: - type: Interaction type (meeting, call, email, chat) - start_time and end_time: Date range (max 1 year) - One entity ID: person_id, company_id, or opportunity_id</p> <p>Returns V1 paginated response with <code>data</code> and <code>next_page_token</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If type is not provided (required by Affinity V1 API)</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list(\n    self,\n    *,\n    type: InteractionType | None = None,\n    start_time: datetime | None = None,\n    end_time: datetime | None = None,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Interaction]:\n    \"\"\"\n    Get interactions with optional filtering.\n\n    The Affinity API requires:\n    - type: Interaction type (meeting, call, email, chat)\n    - start_time and end_time: Date range (max 1 year)\n    - One entity ID: person_id, company_id, or opportunity_id\n\n    Returns V1 paginated response with `data` and `next_page_token`.\n\n    Raises:\n        ValueError: If type is not provided (required by Affinity V1 API)\n    \"\"\"\n    if type is None:\n        raise ValueError(\n            \"type is required for interactions API. \"\n            \"Use InteractionType.EMAIL, MEETING, CALL, or CHAT_MESSAGE.\"\n        )\n    params: dict[str, Any] = {\"type\": int(type)}\n    if start_time:\n        params[\"start_time\"] = start_time.isoformat()\n    if end_time:\n        params[\"end_time\"] = end_time.isoformat()\n    if person_id:\n        params[\"person_id\"] = int(person_id)\n    if company_id:\n        params[\"organization_id\"] = int(company_id)\n    if opportunity_id:\n        params[\"opportunity_id\"] = int(opportunity_id)\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = self._client.get(\"/interactions\", params=params or None, v1=True)\n    items: Any = None\n    if type is not None:\n        if int(type) in (int(InteractionType.MEETING), int(InteractionType.CALL)):\n            items = data.get(\"events\")\n        elif int(type) == int(InteractionType.CHAT_MESSAGE):\n            items = data.get(\"chat_messages\")\n        elif int(type) == int(InteractionType.EMAIL):\n            items = data.get(\"emails\")\n\n    if items is None:\n        items = (\n            data.get(\"interactions\")\n            or data.get(\"events\")\n            or data.get(\"emails\")\n            or data.get(\"chat_messages\")\n            or data.get(\"data\", [])\n        )\n    if not isinstance(items, list):\n        items = []\n    return PaginatedResponse[Interaction](\n        data=[Interaction.model_validate(i) for i in items],\n        next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n    )\n</code></pre>"},{"location":"reference/services/v1/interactions/#affinity.services.v1_only.InteractionService.update","title":"<code>update(interaction_id: InteractionId, type: InteractionType, data: InteractionUpdate) -&gt; Interaction</code>","text":"<p>Update an interaction.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def update(\n    self,\n    interaction_id: InteractionId,\n    type: InteractionType,\n    data: InteractionUpdate,\n) -&gt; Interaction:\n    \"\"\"Update an interaction.\"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"python\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n    payload[\"type\"] = int(type)\n    _coerce_isoformat(payload, (\"date\",))\n\n    result = self._client.put(\n        f\"/interactions/{int(interaction_id)}\",\n        json=payload,\n        v1=True,\n    )\n    return Interaction.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/notes/","title":"Notes (V1)","text":"<p>Service for managing notes.</p> <p>V2 provides read-only access; use V1 for create/update/delete.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class NoteService:\n    \"\"\"\n    Service for managing notes.\n\n    V2 provides read-only access; use V1 for create/update/delete.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def list(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        creator_id: UserId | None = None,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Note]:\n        \"\"\"\n        Get notes filtered by entity or creator.\n\n        Args:\n            person_id: Filter notes associated with this person\n            company_id: Filter notes associated with this company\n            opportunity_id: Filter notes associated with this opportunity\n            creator_id: Filter notes created by this user\n            page_size: Number of results per page\n            page_token: Pagination token from previous response\n\n        Returns:\n            PaginatedResponse with notes and next_page_token\n        \"\"\"\n        params: dict[str, Any] = {}\n        if person_id:\n            params[\"person_id\"] = int(person_id)\n        if company_id:\n            params[\"organization_id\"] = int(company_id)\n        if opportunity_id:\n            params[\"opportunity_id\"] = int(opportunity_id)\n        if creator_id:\n            params[\"creator_id\"] = int(creator_id)\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = self._client.get(\"/notes\", params=params or None, v1=True)\n        items = data.get(\"notes\", data.get(\"data\", []))\n        if not isinstance(items, list):\n            items = []\n        return PaginatedResponse[Note](\n            data=[Note.model_validate(n) for n in items],\n            next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n        )\n\n    def get(self, note_id: NoteId) -&gt; Note:\n        \"\"\"Get a single note by ID.\"\"\"\n        data = self._client.get(f\"/notes/{note_id}\", v1=True)\n        return Note.model_validate(data)\n\n    def create(self, data: NoteCreate) -&gt; Note:\n        \"\"\"\n        Create a new note.\n\n        Must be associated with at least one person, organization,\n        opportunity, or parent note (for replies).\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n        _coerce_isoformat(payload, (\"created_at\",))\n        if not data.person_ids:\n            payload.pop(\"person_ids\", None)\n        if not data.company_ids:\n            payload.pop(\"organization_ids\", None)\n        if not data.opportunity_ids:\n            payload.pop(\"opportunity_ids\", None)\n\n        result = self._client.post(\"/notes\", json=payload, v1=True)\n        return Note.model_validate(result)\n\n    def update(self, note_id: NoteId, data: NoteUpdate) -&gt; Note:\n        \"\"\"Update a note's content.\"\"\"\n        payload = data.model_dump(mode=\"json\", exclude_unset=True, exclude_none=True)\n        result = self._client.put(\n            f\"/notes/{note_id}\",\n            json=payload,\n            v1=True,\n        )\n        return Note.model_validate(result)\n\n    def delete(self, note_id: NoteId) -&gt; bool:\n        \"\"\"Delete a note.\"\"\"\n        result = self._client.delete(f\"/notes/{note_id}\", v1=True)\n        return bool(result.get(\"success\", False))\n\n    def iter(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        creator_id: UserId | None = None,\n        page_size: int | None = None,\n    ) -&gt; PageIterator[Note]:\n        \"\"\"\n        Iterate through all notes with automatic pagination.\n\n        Args:\n            person_id: Filter notes associated with this person\n            company_id: Filter notes associated with this company\n            opportunity_id: Filter notes associated with this opportunity\n            creator_id: Filter notes created by this user\n            page_size: Number of results per page\n\n        Returns:\n            PageIterator that yields Note objects\n        \"\"\"\n\n        def fetch_page(cursor: str | None) -&gt; PaginatedResponse[Note]:\n            return self.list(\n                person_id=person_id,\n                company_id=company_id,\n                opportunity_id=opportunity_id,\n                creator_id=creator_id,\n                page_size=page_size,\n                page_token=cursor,\n            )\n\n        return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/v1/notes/#affinity.services.v1_only.NoteService.create","title":"<code>create(data: NoteCreate) -&gt; Note</code>","text":"<p>Create a new note.</p> <p>Must be associated with at least one person, organization, opportunity, or parent note (for replies).</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def create(self, data: NoteCreate) -&gt; Note:\n    \"\"\"\n    Create a new note.\n\n    Must be associated with at least one person, organization,\n    opportunity, or parent note (for replies).\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n    _coerce_isoformat(payload, (\"created_at\",))\n    if not data.person_ids:\n        payload.pop(\"person_ids\", None)\n    if not data.company_ids:\n        payload.pop(\"organization_ids\", None)\n    if not data.opportunity_ids:\n        payload.pop(\"opportunity_ids\", None)\n\n    result = self._client.post(\"/notes\", json=payload, v1=True)\n    return Note.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/notes/#affinity.services.v1_only.NoteService.delete","title":"<code>delete(note_id: NoteId) -&gt; bool</code>","text":"<p>Delete a note.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def delete(self, note_id: NoteId) -&gt; bool:\n    \"\"\"Delete a note.\"\"\"\n    result = self._client.delete(f\"/notes/{note_id}\", v1=True)\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/v1/notes/#affinity.services.v1_only.NoteService.get","title":"<code>get(note_id: NoteId) -&gt; Note</code>","text":"<p>Get a single note by ID.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get(self, note_id: NoteId) -&gt; Note:\n    \"\"\"Get a single note by ID.\"\"\"\n    data = self._client.get(f\"/notes/{note_id}\", v1=True)\n    return Note.model_validate(data)\n</code></pre>"},{"location":"reference/services/v1/notes/#affinity.services.v1_only.NoteService.iter","title":"<code>iter(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, creator_id: UserId | None = None, page_size: int | None = None) -&gt; PageIterator[Note]</code>","text":"<p>Iterate through all notes with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId | None</code> <p>Filter notes associated with this person</p> <code>None</code> <code>company_id</code> <code>CompanyId | None</code> <p>Filter notes associated with this company</p> <code>None</code> <code>opportunity_id</code> <code>OpportunityId | None</code> <p>Filter notes associated with this opportunity</p> <code>None</code> <code>creator_id</code> <code>UserId | None</code> <p>Filter notes created by this user</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Number of results per page</p> <code>None</code> <p>Returns:</p> Type Description <code>PageIterator[Note]</code> <p>PageIterator that yields Note objects</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def iter(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    creator_id: UserId | None = None,\n    page_size: int | None = None,\n) -&gt; PageIterator[Note]:\n    \"\"\"\n    Iterate through all notes with automatic pagination.\n\n    Args:\n        person_id: Filter notes associated with this person\n        company_id: Filter notes associated with this company\n        opportunity_id: Filter notes associated with this opportunity\n        creator_id: Filter notes created by this user\n        page_size: Number of results per page\n\n    Returns:\n        PageIterator that yields Note objects\n    \"\"\"\n\n    def fetch_page(cursor: str | None) -&gt; PaginatedResponse[Note]:\n        return self.list(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n            creator_id=creator_id,\n            page_size=page_size,\n            page_token=cursor,\n        )\n\n    return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/v1/notes/#affinity.services.v1_only.NoteService.list","title":"<code>list(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, creator_id: UserId | None = None, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Note]</code>","text":"<p>Get notes filtered by entity or creator.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId | None</code> <p>Filter notes associated with this person</p> <code>None</code> <code>company_id</code> <code>CompanyId | None</code> <p>Filter notes associated with this company</p> <code>None</code> <code>opportunity_id</code> <code>OpportunityId | None</code> <p>Filter notes associated with this opportunity</p> <code>None</code> <code>creator_id</code> <code>UserId | None</code> <p>Filter notes created by this user</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Number of results per page</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Pagination token from previous response</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Note]</code> <p>PaginatedResponse with notes and next_page_token</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    creator_id: UserId | None = None,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Note]:\n    \"\"\"\n    Get notes filtered by entity or creator.\n\n    Args:\n        person_id: Filter notes associated with this person\n        company_id: Filter notes associated with this company\n        opportunity_id: Filter notes associated with this opportunity\n        creator_id: Filter notes created by this user\n        page_size: Number of results per page\n        page_token: Pagination token from previous response\n\n    Returns:\n        PaginatedResponse with notes and next_page_token\n    \"\"\"\n    params: dict[str, Any] = {}\n    if person_id:\n        params[\"person_id\"] = int(person_id)\n    if company_id:\n        params[\"organization_id\"] = int(company_id)\n    if opportunity_id:\n        params[\"opportunity_id\"] = int(opportunity_id)\n    if creator_id:\n        params[\"creator_id\"] = int(creator_id)\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = self._client.get(\"/notes\", params=params or None, v1=True)\n    items = data.get(\"notes\", data.get(\"data\", []))\n    if not isinstance(items, list):\n        items = []\n    return PaginatedResponse[Note](\n        data=[Note.model_validate(n) for n in items],\n        next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n    )\n</code></pre>"},{"location":"reference/services/v1/notes/#affinity.services.v1_only.NoteService.update","title":"<code>update(note_id: NoteId, data: NoteUpdate) -&gt; Note</code>","text":"<p>Update a note's content.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def update(self, note_id: NoteId, data: NoteUpdate) -&gt; Note:\n    \"\"\"Update a note's content.\"\"\"\n    payload = data.model_dump(mode=\"json\", exclude_unset=True, exclude_none=True)\n    result = self._client.put(\n        f\"/notes/{note_id}\",\n        json=payload,\n        v1=True,\n    )\n    return Note.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/relationships/","title":"Relationship strength (V1)","text":"<p>Service for querying relationship strengths.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class RelationshipStrengthService:\n    \"\"\"Service for querying relationship strengths.\"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def get(\n        self,\n        external_id: PersonId,\n        internal_id: UserId | None = None,\n    ) -&gt; list[RelationshipStrength]:\n        \"\"\"\n        Get relationship strength(s) for an external person.\n\n        Args:\n            external_id: External person to query\n            internal_id: Optional internal person for specific relationship\n\n        Returns:\n            List of relationship strengths (may be empty)\n        \"\"\"\n        params: dict[str, Any] = {\"external_id\": int(external_id)}\n        if internal_id:\n            params[\"internal_id\"] = int(internal_id)\n\n        data = self._client.get(\"/relationships-strengths\", params=params, v1=True)\n        items = data.get(\"data\", [])\n        if not isinstance(items, list):\n            items = []\n        return [RelationshipStrength.model_validate(r) for r in items]\n</code></pre>"},{"location":"reference/services/v1/relationships/#affinity.services.v1_only.RelationshipStrengthService.get","title":"<code>get(external_id: PersonId, internal_id: UserId | None = None) -&gt; list[RelationshipStrength]</code>","text":"<p>Get relationship strength(s) for an external person.</p> <p>Parameters:</p> Name Type Description Default <code>external_id</code> <code>PersonId</code> <p>External person to query</p> required <code>internal_id</code> <code>UserId | None</code> <p>Optional internal person for specific relationship</p> <code>None</code> <p>Returns:</p> Type Description <code>list[RelationshipStrength]</code> <p>List of relationship strengths (may be empty)</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get(\n    self,\n    external_id: PersonId,\n    internal_id: UserId | None = None,\n) -&gt; list[RelationshipStrength]:\n    \"\"\"\n    Get relationship strength(s) for an external person.\n\n    Args:\n        external_id: External person to query\n        internal_id: Optional internal person for specific relationship\n\n    Returns:\n        List of relationship strengths (may be empty)\n    \"\"\"\n    params: dict[str, Any] = {\"external_id\": int(external_id)}\n    if internal_id:\n        params[\"internal_id\"] = int(internal_id)\n\n    data = self._client.get(\"/relationships-strengths\", params=params, v1=True)\n    items = data.get(\"data\", [])\n    if not isinstance(items, list):\n        items = []\n    return [RelationshipStrength.model_validate(r) for r in items]\n</code></pre>"},{"location":"reference/services/v1/reminders/","title":"Reminders (V1)","text":"<p>Service for managing reminders.</p> <p>Reminders are V1-only in this SDK (create/update/delete via V1).</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class ReminderService:\n    \"\"\"\n    Service for managing reminders.\n\n    Reminders are V1-only in this SDK (create/update/delete via V1).\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def list(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        creator_id: UserId | None = None,\n        owner_id: UserId | None = None,\n        completer_id: UserId | None = None,\n        type: ReminderType | None = None,\n        reset_type: ReminderResetType | None = None,\n        status: ReminderStatus | None = None,\n        due_before: datetime | None = None,\n        due_after: datetime | None = None,\n        page_size: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; PaginatedResponse[Reminder]:\n        \"\"\"\n        Get reminders with optional filtering.\n\n        Args:\n            person_id: Filter reminders for this person\n            company_id: Filter reminders for this company\n            opportunity_id: Filter reminders for this opportunity\n            creator_id: Filter by reminder creator\n            owner_id: Filter by reminder owner (assignee)\n            completer_id: Filter by who completed the reminder\n            type: Filter by reminder type (ONE_TIME or RECURRING)\n            reset_type: Filter by reset type (FIXED_DATE, DATE_ADDED, or INTERACTION)\n            status: Filter by status (ACTIVE, SNOOZED, or COMPLETE)\n            due_before: Filter reminders due before this datetime\n            due_after: Filter reminders due after this datetime\n            page_size: Number of results per page\n            page_token: Pagination token from previous response\n\n        Returns:\n            PaginatedResponse with reminders and next_page_token\n        \"\"\"\n        params: dict[str, Any] = {}\n        if person_id:\n            params[\"person_id\"] = int(person_id)\n        if company_id:\n            params[\"organization_id\"] = int(company_id)\n        if opportunity_id:\n            params[\"opportunity_id\"] = int(opportunity_id)\n        if creator_id:\n            params[\"creator_id\"] = int(creator_id)\n        if owner_id:\n            params[\"owner_id\"] = int(owner_id)\n        if completer_id:\n            params[\"completer_id\"] = int(completer_id)\n        if type is not None:\n            params[\"type\"] = int(type)\n        if reset_type is not None:\n            params[\"reset_type\"] = int(reset_type)\n        if status is not None:\n            params[\"status\"] = int(status)\n        if due_before:\n            params[\"due_before\"] = due_before.isoformat()\n        if due_after:\n            params[\"due_after\"] = due_after.isoformat()\n        if page_size:\n            params[\"page_size\"] = page_size\n        if page_token:\n            params[\"page_token\"] = page_token\n\n        data = self._client.get(\"/reminders\", params=params or None, v1=True)\n        items = data.get(\"reminders\", data.get(\"data\", []))\n        if not isinstance(items, list):\n            items = []\n        return PaginatedResponse[Reminder](\n            data=[Reminder.model_validate(r) for r in items],\n            next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n        )\n\n    def get(self, reminder_id: ReminderIdType) -&gt; Reminder:\n        \"\"\"Get a single reminder.\"\"\"\n        data = self._client.get(f\"/reminders/{reminder_id}\", v1=True)\n        return Reminder.model_validate(data)\n\n    def create(self, data: ReminderCreate) -&gt; Reminder:\n        \"\"\"Create a new reminder.\"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n        _coerce_isoformat(payload, (\"due_date\",))\n\n        result = self._client.post(\"/reminders\", json=payload, v1=True)\n        return Reminder.model_validate(result)\n\n    def update(self, reminder_id: ReminderIdType, data: ReminderUpdate) -&gt; Reminder:\n        \"\"\"Update a reminder.\"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"python\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n        _coerce_isoformat(payload, (\"due_date\",))\n\n        result = self._client.put(f\"/reminders/{reminder_id}\", json=payload, v1=True)\n        return Reminder.model_validate(result)\n\n    def delete(self, reminder_id: ReminderIdType) -&gt; bool:\n        \"\"\"Delete a reminder.\"\"\"\n        result = self._client.delete(f\"/reminders/{reminder_id}\", v1=True)\n        return bool(result.get(\"success\", False))\n\n    def iter(\n        self,\n        *,\n        person_id: PersonId | None = None,\n        company_id: CompanyId | None = None,\n        opportunity_id: OpportunityId | None = None,\n        creator_id: UserId | None = None,\n        owner_id: UserId | None = None,\n        completer_id: UserId | None = None,\n        type: ReminderType | None = None,\n        reset_type: ReminderResetType | None = None,\n        status: ReminderStatus | None = None,\n        due_before: datetime | None = None,\n        due_after: datetime | None = None,\n        page_size: int | None = None,\n    ) -&gt; PageIterator[Reminder]:\n        \"\"\"\n        Iterate through all reminders with automatic pagination.\n\n        Args:\n            person_id: Filter reminders for this person\n            company_id: Filter reminders for this company\n            opportunity_id: Filter reminders for this opportunity\n            creator_id: Filter by reminder creator\n            owner_id: Filter by reminder owner (assignee)\n            completer_id: Filter by who completed the reminder\n            type: Filter by reminder type (ONE_TIME or RECURRING)\n            reset_type: Filter by reset type (FIXED_DATE, DATE_ADDED, or INTERACTION)\n            status: Filter by status (ACTIVE, SNOOZED, or COMPLETE)\n            due_before: Filter reminders due before this datetime\n            due_after: Filter reminders due after this datetime\n            page_size: Number of results per page\n\n        Returns:\n            PageIterator that yields Reminder objects\n        \"\"\"\n\n        def fetch_page(cursor: str | None) -&gt; PaginatedResponse[Reminder]:\n            return self.list(\n                person_id=person_id,\n                company_id=company_id,\n                opportunity_id=opportunity_id,\n                creator_id=creator_id,\n                owner_id=owner_id,\n                completer_id=completer_id,\n                type=type,\n                reset_type=reset_type,\n                status=status,\n                due_before=due_before,\n                due_after=due_after,\n                page_size=page_size,\n                page_token=cursor,\n            )\n\n        return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/v1/reminders/#affinity.services.v1_only.ReminderService.create","title":"<code>create(data: ReminderCreate) -&gt; Reminder</code>","text":"<p>Create a new reminder.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def create(self, data: ReminderCreate) -&gt; Reminder:\n    \"\"\"Create a new reminder.\"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n    _coerce_isoformat(payload, (\"due_date\",))\n\n    result = self._client.post(\"/reminders\", json=payload, v1=True)\n    return Reminder.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/reminders/#affinity.services.v1_only.ReminderService.delete","title":"<code>delete(reminder_id: ReminderIdType) -&gt; bool</code>","text":"<p>Delete a reminder.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def delete(self, reminder_id: ReminderIdType) -&gt; bool:\n    \"\"\"Delete a reminder.\"\"\"\n    result = self._client.delete(f\"/reminders/{reminder_id}\", v1=True)\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/v1/reminders/#affinity.services.v1_only.ReminderService.get","title":"<code>get(reminder_id: ReminderIdType) -&gt; Reminder</code>","text":"<p>Get a single reminder.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get(self, reminder_id: ReminderIdType) -&gt; Reminder:\n    \"\"\"Get a single reminder.\"\"\"\n    data = self._client.get(f\"/reminders/{reminder_id}\", v1=True)\n    return Reminder.model_validate(data)\n</code></pre>"},{"location":"reference/services/v1/reminders/#affinity.services.v1_only.ReminderService.iter","title":"<code>iter(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, creator_id: UserId | None = None, owner_id: UserId | None = None, completer_id: UserId | None = None, type: ReminderType | None = None, reset_type: ReminderResetType | None = None, status: ReminderStatus | None = None, due_before: datetime | None = None, due_after: datetime | None = None, page_size: int | None = None) -&gt; PageIterator[Reminder]</code>","text":"<p>Iterate through all reminders with automatic pagination.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId | None</code> <p>Filter reminders for this person</p> <code>None</code> <code>company_id</code> <code>CompanyId | None</code> <p>Filter reminders for this company</p> <code>None</code> <code>opportunity_id</code> <code>OpportunityId | None</code> <p>Filter reminders for this opportunity</p> <code>None</code> <code>creator_id</code> <code>UserId | None</code> <p>Filter by reminder creator</p> <code>None</code> <code>owner_id</code> <code>UserId | None</code> <p>Filter by reminder owner (assignee)</p> <code>None</code> <code>completer_id</code> <code>UserId | None</code> <p>Filter by who completed the reminder</p> <code>None</code> <code>type</code> <code>ReminderType | None</code> <p>Filter by reminder type (ONE_TIME or RECURRING)</p> <code>None</code> <code>reset_type</code> <code>ReminderResetType | None</code> <p>Filter by reset type (FIXED_DATE, DATE_ADDED, or INTERACTION)</p> <code>None</code> <code>status</code> <code>ReminderStatus | None</code> <p>Filter by status (ACTIVE, SNOOZED, or COMPLETE)</p> <code>None</code> <code>due_before</code> <code>datetime | None</code> <p>Filter reminders due before this datetime</p> <code>None</code> <code>due_after</code> <code>datetime | None</code> <p>Filter reminders due after this datetime</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Number of results per page</p> <code>None</code> <p>Returns:</p> Type Description <code>PageIterator[Reminder]</code> <p>PageIterator that yields Reminder objects</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def iter(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    creator_id: UserId | None = None,\n    owner_id: UserId | None = None,\n    completer_id: UserId | None = None,\n    type: ReminderType | None = None,\n    reset_type: ReminderResetType | None = None,\n    status: ReminderStatus | None = None,\n    due_before: datetime | None = None,\n    due_after: datetime | None = None,\n    page_size: int | None = None,\n) -&gt; PageIterator[Reminder]:\n    \"\"\"\n    Iterate through all reminders with automatic pagination.\n\n    Args:\n        person_id: Filter reminders for this person\n        company_id: Filter reminders for this company\n        opportunity_id: Filter reminders for this opportunity\n        creator_id: Filter by reminder creator\n        owner_id: Filter by reminder owner (assignee)\n        completer_id: Filter by who completed the reminder\n        type: Filter by reminder type (ONE_TIME or RECURRING)\n        reset_type: Filter by reset type (FIXED_DATE, DATE_ADDED, or INTERACTION)\n        status: Filter by status (ACTIVE, SNOOZED, or COMPLETE)\n        due_before: Filter reminders due before this datetime\n        due_after: Filter reminders due after this datetime\n        page_size: Number of results per page\n\n    Returns:\n        PageIterator that yields Reminder objects\n    \"\"\"\n\n    def fetch_page(cursor: str | None) -&gt; PaginatedResponse[Reminder]:\n        return self.list(\n            person_id=person_id,\n            company_id=company_id,\n            opportunity_id=opportunity_id,\n            creator_id=creator_id,\n            owner_id=owner_id,\n            completer_id=completer_id,\n            type=type,\n            reset_type=reset_type,\n            status=status,\n            due_before=due_before,\n            due_after=due_after,\n            page_size=page_size,\n            page_token=cursor,\n        )\n\n    return PageIterator(fetch_page)\n</code></pre>"},{"location":"reference/services/v1/reminders/#affinity.services.v1_only.ReminderService.list","title":"<code>list(*, person_id: PersonId | None = None, company_id: CompanyId | None = None, opportunity_id: OpportunityId | None = None, creator_id: UserId | None = None, owner_id: UserId | None = None, completer_id: UserId | None = None, type: ReminderType | None = None, reset_type: ReminderResetType | None = None, status: ReminderStatus | None = None, due_before: datetime | None = None, due_after: datetime | None = None, page_size: int | None = None, page_token: str | None = None) -&gt; PaginatedResponse[Reminder]</code>","text":"<p>Get reminders with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>PersonId | None</code> <p>Filter reminders for this person</p> <code>None</code> <code>company_id</code> <code>CompanyId | None</code> <p>Filter reminders for this company</p> <code>None</code> <code>opportunity_id</code> <code>OpportunityId | None</code> <p>Filter reminders for this opportunity</p> <code>None</code> <code>creator_id</code> <code>UserId | None</code> <p>Filter by reminder creator</p> <code>None</code> <code>owner_id</code> <code>UserId | None</code> <p>Filter by reminder owner (assignee)</p> <code>None</code> <code>completer_id</code> <code>UserId | None</code> <p>Filter by who completed the reminder</p> <code>None</code> <code>type</code> <code>ReminderType | None</code> <p>Filter by reminder type (ONE_TIME or RECURRING)</p> <code>None</code> <code>reset_type</code> <code>ReminderResetType | None</code> <p>Filter by reset type (FIXED_DATE, DATE_ADDED, or INTERACTION)</p> <code>None</code> <code>status</code> <code>ReminderStatus | None</code> <p>Filter by status (ACTIVE, SNOOZED, or COMPLETE)</p> <code>None</code> <code>due_before</code> <code>datetime | None</code> <p>Filter reminders due before this datetime</p> <code>None</code> <code>due_after</code> <code>datetime | None</code> <p>Filter reminders due after this datetime</p> <code>None</code> <code>page_size</code> <code>int | None</code> <p>Number of results per page</p> <code>None</code> <code>page_token</code> <code>str | None</code> <p>Pagination token from previous response</p> <code>None</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Reminder]</code> <p>PaginatedResponse with reminders and next_page_token</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list(\n    self,\n    *,\n    person_id: PersonId | None = None,\n    company_id: CompanyId | None = None,\n    opportunity_id: OpportunityId | None = None,\n    creator_id: UserId | None = None,\n    owner_id: UserId | None = None,\n    completer_id: UserId | None = None,\n    type: ReminderType | None = None,\n    reset_type: ReminderResetType | None = None,\n    status: ReminderStatus | None = None,\n    due_before: datetime | None = None,\n    due_after: datetime | None = None,\n    page_size: int | None = None,\n    page_token: str | None = None,\n) -&gt; PaginatedResponse[Reminder]:\n    \"\"\"\n    Get reminders with optional filtering.\n\n    Args:\n        person_id: Filter reminders for this person\n        company_id: Filter reminders for this company\n        opportunity_id: Filter reminders for this opportunity\n        creator_id: Filter by reminder creator\n        owner_id: Filter by reminder owner (assignee)\n        completer_id: Filter by who completed the reminder\n        type: Filter by reminder type (ONE_TIME or RECURRING)\n        reset_type: Filter by reset type (FIXED_DATE, DATE_ADDED, or INTERACTION)\n        status: Filter by status (ACTIVE, SNOOZED, or COMPLETE)\n        due_before: Filter reminders due before this datetime\n        due_after: Filter reminders due after this datetime\n        page_size: Number of results per page\n        page_token: Pagination token from previous response\n\n    Returns:\n        PaginatedResponse with reminders and next_page_token\n    \"\"\"\n    params: dict[str, Any] = {}\n    if person_id:\n        params[\"person_id\"] = int(person_id)\n    if company_id:\n        params[\"organization_id\"] = int(company_id)\n    if opportunity_id:\n        params[\"opportunity_id\"] = int(opportunity_id)\n    if creator_id:\n        params[\"creator_id\"] = int(creator_id)\n    if owner_id:\n        params[\"owner_id\"] = int(owner_id)\n    if completer_id:\n        params[\"completer_id\"] = int(completer_id)\n    if type is not None:\n        params[\"type\"] = int(type)\n    if reset_type is not None:\n        params[\"reset_type\"] = int(reset_type)\n    if status is not None:\n        params[\"status\"] = int(status)\n    if due_before:\n        params[\"due_before\"] = due_before.isoformat()\n    if due_after:\n        params[\"due_after\"] = due_after.isoformat()\n    if page_size:\n        params[\"page_size\"] = page_size\n    if page_token:\n        params[\"page_token\"] = page_token\n\n    data = self._client.get(\"/reminders\", params=params or None, v1=True)\n    items = data.get(\"reminders\", data.get(\"data\", []))\n    if not isinstance(items, list):\n        items = []\n    return PaginatedResponse[Reminder](\n        data=[Reminder.model_validate(r) for r in items],\n        next_page_token=data.get(\"next_page_token\") or data.get(\"nextPageToken\"),\n    )\n</code></pre>"},{"location":"reference/services/v1/reminders/#affinity.services.v1_only.ReminderService.update","title":"<code>update(reminder_id: ReminderIdType, data: ReminderUpdate) -&gt; Reminder</code>","text":"<p>Update a reminder.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def update(self, reminder_id: ReminderIdType, data: ReminderUpdate) -&gt; Reminder:\n    \"\"\"Update a reminder.\"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"python\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n    _coerce_isoformat(payload, (\"due_date\",))\n\n    result = self._client.put(f\"/reminders/{reminder_id}\", json=payload, v1=True)\n    return Reminder.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/webhooks/","title":"Webhooks (V1)","text":"<p>Service for managing webhook subscriptions.</p> <p>Note: Limited to 3 subscriptions per Affinity instance.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>class WebhookService:\n    \"\"\"\n    Service for managing webhook subscriptions.\n\n    Note: Limited to 3 subscriptions per Affinity instance.\n    \"\"\"\n\n    def __init__(self, client: HTTPClient):\n        self._client = client\n\n    def list(self) -&gt; builtins.list[WebhookSubscription]:\n        \"\"\"Get all webhook subscriptions.\"\"\"\n        data = self._client.get(\"/webhook\", v1=True)\n        return [WebhookSubscription.model_validate(w) for w in data.get(\"data\", [])]\n\n    def get(self, webhook_id: WebhookId) -&gt; WebhookSubscription:\n        \"\"\"Get a single webhook subscription.\"\"\"\n        data = self._client.get(f\"/webhook/{webhook_id}\", v1=True)\n        return WebhookSubscription.model_validate(data)\n\n    def create(self, data: WebhookCreate) -&gt; WebhookSubscription:\n        \"\"\"\n        Create a webhook subscription.\n\n        The webhook URL will receive a validation request.\n        \"\"\"\n        payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n        _coerce_isoformat(payload, (\"date\",))\n        if not data.subscriptions:\n            payload.pop(\"subscriptions\", None)\n\n        result = self._client.post(\"/webhook/subscribe\", json=payload, v1=True)\n        return WebhookSubscription.model_validate(result)\n\n    def update(self, webhook_id: WebhookId, data: WebhookUpdate) -&gt; WebhookSubscription:\n        \"\"\"Update a webhook subscription.\"\"\"\n        payload = data.model_dump(\n            by_alias=True,\n            mode=\"json\",\n            exclude_unset=True,\n            exclude_none=True,\n        )\n\n        result = self._client.put(f\"/webhook/{webhook_id}\", json=payload, v1=True)\n        return WebhookSubscription.model_validate(result)\n\n    def delete(self, webhook_id: WebhookId) -&gt; bool:\n        \"\"\"Delete a webhook subscription.\"\"\"\n        result = self._client.delete(f\"/webhook/{webhook_id}\", v1=True)\n        return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/v1/webhooks/#affinity.services.v1_only.WebhookService.create","title":"<code>create(data: WebhookCreate) -&gt; WebhookSubscription</code>","text":"<p>Create a webhook subscription.</p> <p>The webhook URL will receive a validation request.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def create(self, data: WebhookCreate) -&gt; WebhookSubscription:\n    \"\"\"\n    Create a webhook subscription.\n\n    The webhook URL will receive a validation request.\n    \"\"\"\n    payload = data.model_dump(by_alias=True, mode=\"python\", exclude_none=True)\n    _coerce_isoformat(payload, (\"date\",))\n    if not data.subscriptions:\n        payload.pop(\"subscriptions\", None)\n\n    result = self._client.post(\"/webhook/subscribe\", json=payload, v1=True)\n    return WebhookSubscription.model_validate(result)\n</code></pre>"},{"location":"reference/services/v1/webhooks/#affinity.services.v1_only.WebhookService.delete","title":"<code>delete(webhook_id: WebhookId) -&gt; bool</code>","text":"<p>Delete a webhook subscription.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def delete(self, webhook_id: WebhookId) -&gt; bool:\n    \"\"\"Delete a webhook subscription.\"\"\"\n    result = self._client.delete(f\"/webhook/{webhook_id}\", v1=True)\n    return bool(result.get(\"success\", False))\n</code></pre>"},{"location":"reference/services/v1/webhooks/#affinity.services.v1_only.WebhookService.get","title":"<code>get(webhook_id: WebhookId) -&gt; WebhookSubscription</code>","text":"<p>Get a single webhook subscription.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def get(self, webhook_id: WebhookId) -&gt; WebhookSubscription:\n    \"\"\"Get a single webhook subscription.\"\"\"\n    data = self._client.get(f\"/webhook/{webhook_id}\", v1=True)\n    return WebhookSubscription.model_validate(data)\n</code></pre>"},{"location":"reference/services/v1/webhooks/#affinity.services.v1_only.WebhookService.list","title":"<code>list() -&gt; builtins.list[WebhookSubscription]</code>","text":"<p>Get all webhook subscriptions.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def list(self) -&gt; builtins.list[WebhookSubscription]:\n    \"\"\"Get all webhook subscriptions.\"\"\"\n    data = self._client.get(\"/webhook\", v1=True)\n    return [WebhookSubscription.model_validate(w) for w in data.get(\"data\", [])]\n</code></pre>"},{"location":"reference/services/v1/webhooks/#affinity.services.v1_only.WebhookService.update","title":"<code>update(webhook_id: WebhookId, data: WebhookUpdate) -&gt; WebhookSubscription</code>","text":"<p>Update a webhook subscription.</p> Source code in <code>affinity/services/v1_only.py</code> <pre><code>def update(self, webhook_id: WebhookId, data: WebhookUpdate) -&gt; WebhookSubscription:\n    \"\"\"Update a webhook subscription.\"\"\"\n    payload = data.model_dump(\n        by_alias=True,\n        mode=\"json\",\n        exclude_unset=True,\n        exclude_none=True,\n    )\n\n    result = self._client.put(f\"/webhook/{webhook_id}\", json=payload, v1=True)\n    return WebhookSubscription.model_validate(result)\n</code></pre>"}]}