#!/usr/bin/env bash
# lib/common.sh - Common utilities for Affinity MCP tools

# Source cache utilities
source "${MCPBASH_PROJECT_ROOT}/lib/cache.sh"

# ==============================================================================
# JSON Tool Wrapper
# ==============================================================================
# Use mcp-bash's JSON tool (jq or gojq) for all JSON processing.
# This respects MCPBASH_JSON_TOOL setting and works with either implementation.
#
# jq_tool() is the canonical name (follows mcp-bash proposal pattern).
# jq() is kept for backwards compatibility with existing tools.

jq_tool() { "${MCPBASH_JSON_TOOL_BIN:-jq}" "$@"; }
jq() { jq_tool "$@"; }

# ==============================================================================
# CLI Gateway Registry
# ==============================================================================
# Pre-generated commands registry for CLI Gateway tools (discover-commands, execute-*-command).
# Generated by tools/generate_cli_commands_registry.py during CI.
# Location: server.d/registry/ (bundled) or .registry/ (local dev fallback)

if [[ -f "${MCPBASH_PROJECT_ROOT}/server.d/registry/commands.json" ]]; then
    REGISTRY_FILE="${MCPBASH_PROJECT_ROOT}/server.d/registry/commands.json"
else
    REGISTRY_FILE="${MCPBASH_PROJECT_ROOT}/.registry/commands.json"
fi

# ==============================================================================
# Logging Helpers
# ==============================================================================
# These wrap mcp-bash SDK logging with xaffinity-specific context.
# Use XAFFINITY_DEBUG=true or MCPBASH_LOG_LEVEL=debug for verbose output.

# Log debug message (only when debug mode enabled)
# Usage: xaffinity_log_debug "context" "message"
xaffinity_log_debug() {
    local context="$1"
    local message="$2"
    if [[ "${XAFFINITY_DEBUG:-}" == "true" || "${MCPBASH_LOG_LEVEL:-info}" == "debug" ]]; then
        if type mcp_log_debug &>/dev/null; then
            mcp_log_debug "xaffinity:$context" "$message"
        fi
    fi
}

# Log info message
# Usage: xaffinity_log_info "context" "message"
xaffinity_log_info() {
    local context="$1"
    local message="$2"
    if type mcp_log_info &>/dev/null; then
        mcp_log_info "xaffinity:$context" "$message"
    fi
}

# Log warning message
# Usage: xaffinity_log_warn "context" "message"
xaffinity_log_warn() {
    local context="$1"
    local message="$2"
    if type mcp_log_warn &>/dev/null; then
        mcp_log_warn "xaffinity:$context" "$message"
    fi
}

# Log error message
# Usage: xaffinity_log_error "context" "message"
xaffinity_log_error() {
    local context="$1"
    local message="$2"
    if type mcp_log_error &>/dev/null; then
        mcp_log_error "xaffinity:$context" "$message"
    fi
}

# Log CLI command execution (debug only, redacts sensitive args)
# Usage: xaffinity_log_cli "subcommand" "exit_code" "output_bytes"
xaffinity_log_cli() {
    local subcommand="$1"
    local exit_code="$2"
    local output_bytes="${3:-0}"
    if [[ "${XAFFINITY_DEBUG:-}" == "true" || "${MCPBASH_LOG_LEVEL:-info}" == "debug" ]]; then
        if type mcp_log_debug &>/dev/null; then
            mcp_log_debug "xaffinity:cli" "cmd=$subcommand exit=$exit_code bytes=$output_bytes"
        fi
    fi
}

# ==============================================================================
# Metrics Logging
# ==============================================================================
# Log structured metrics for monitoring and alerting.
# Metrics are logged to stderr in a parseable format for log aggregation.
# Usage: log_metric "metric_name" "value" ["tag1=val1" "tag2=val2" ...]
#
# Example output: [METRIC] execute_command_result=success tool=execute-read-command command=person_get
log_metric() {
    local metric="$1"
    local value="$2"
    shift 2
    local tags=""
    for tag in "$@"; do
        tags+=" $tag"
    done
    echo "[METRIC] ${metric}=${value}${tags}" >&2
}

# Build CLI base arguments from XAFFINITY_CLI_PATTERN
# The pattern from check-key looks like: "xaffinity --dotenv --readonly <command> --json"
# We extract flags before <command> and after <command>
build_cli_base_args() {
    local pattern="${XAFFINITY_CLI_PATTERN:-xaffinity --readonly <command> --json}"

    # Extract pre-command flags (everything between "xaffinity" and "<command>")
    local pre_flags=$(echo "$pattern" | sed -E 's/^xaffinity\s+(.*)--readonly\s+<command>.*$/\1--readonly/' | tr -s ' ')

    # Extract post-command flags (everything after "<command>")
    local post_flags=$(echo "$pattern" | sed -E 's/.*<command>\s*(.*)$/\1/' | tr -s ' ')

    # Return the pre-flags (we'll append command-specific flags)
    # Post-flags like --json are typically added per-tool
    echo "$pre_flags"
}

# Run xaffinity with correct flags from check-key pattern
# Usage: run_xaffinity <subcommand> [args...]
# Example: run_xaffinity person ls --query "John"
# Note: --quiet is a global option, so we detect and move it to the right position
# Uses mcp_with_retry for transient failure handling (3 attempts, 0.5s base delay)
run_xaffinity() {
    local pattern="${XAFFINITY_CLI_PATTERN:-xaffinity --readonly <command> --json}"
    local needs_dotenv=false
    local needs_quiet=false

    # Check if pattern includes --dotenv
    if [[ "$pattern" == *"--dotenv"* ]]; then
        needs_dotenv=true
    fi

    # Check for --quiet in arguments and filter it out
    local filtered_args=()
    for arg in "$@"; do
        if [[ "$arg" == "--quiet" || "$arg" == "-q" ]]; then
            needs_quiet=true
        else
            filtered_args+=("$arg")
        fi
    done

    # Build command with global options first
    local cmd=(xaffinity)
    [[ "$needs_dotenv" == "true" ]] && cmd+=(--dotenv)
    [[ "$needs_quiet" == "true" ]] && cmd+=(--quiet)
    cmd+=("${filtered_args[@]}")

    # Execute with retry for transient failures
    mcp_with_retry 3 0.5 -- "${cmd[@]}"
}

# Run xaffinity in readonly mode (respects dotenv from check-key)
# Usage: run_xaffinity_readonly <subcommand> [args...]
# Note: --quiet is a global option, so we detect and move it to the right position
# Logs command execution in debug mode (args are not logged for security)
# Uses mcp_with_retry for transient failure handling (3 attempts, 0.5s base delay)
run_xaffinity_readonly() {
    local pattern="${XAFFINITY_CLI_PATTERN:-xaffinity --readonly <command> --json}"
    local needs_dotenv=false
    local needs_quiet=false
    local subcommand="${1:-unknown}"

    if [[ "$pattern" == *"--dotenv"* ]]; then
        needs_dotenv=true
    fi

    # Check for --quiet in arguments and filter it out
    local filtered_args=()
    for arg in "$@"; do
        if [[ "$arg" == "--quiet" || "$arg" == "-q" ]]; then
            needs_quiet=true
        else
            filtered_args+=("$arg")
        fi
    done

    # Build command with global options first
    local cmd=(xaffinity)
    [[ "$needs_dotenv" == "true" ]] && cmd+=(--dotenv)
    cmd+=(--readonly)
    [[ "$needs_quiet" == "true" ]] && cmd+=(--quiet)
    cmd+=("${filtered_args[@]}")

    # Log command start in debug mode
    xaffinity_log_debug "cli" "executing: xaffinity --readonly $subcommand ..."

    # Execute with retry for transient failures (3 attempts, 0.5s base delay)
    local output exit_code=0
    output=$(mcp_with_retry 3 0.5 -- "${cmd[@]}") || exit_code=$?

    # Log result in debug mode
    local output_bytes=${#output}
    xaffinity_log_cli "$subcommand" "$exit_code" "$output_bytes"

    # Output the result
    echo "$output"
    return $exit_code
}

# Fetch or retrieve cached workflow config for a list
# Returns the full workflow config schema: {list, statusField, savedViews, fieldIndex}
# Usage: get_or_fetch_workflow_config <list_id>
get_or_fetch_workflow_config() {
    local list_id="$1"

    # Try cache first
    if cached=$(get_workflow_config_cached "$list_id" 2>/dev/null); then
        echo "$cached"
        return 0
    fi

    # Cache miss - fetch and compute the workflow config schema
    local cli_base_args=(--output json --quiet)
    [[ -n "${AFFINITY_SESSION_CACHE:-}" ]] && cli_base_args+=(--session-cache "$AFFINITY_SESSION_CACHE")

    # Fetch list metadata
    local list_data
    list_data=$(run_xaffinity_readonly list get "$list_id" "${cli_base_args[@]}" 2>/dev/null | jq_tool -c '.data // {}')
    local list_name=$(echo "$list_data" | jq_tool -r '.list.name // "Unknown"')
    local list_type=$(echo "$list_data" | jq_tool -r '.list.type // "unknown"')

    # Fetch fields for this list
    local fields_data
    fields_data=$(run_xaffinity_readonly field ls --list-id "$list_id" "${cli_base_args[@]}" 2>/dev/null | jq_tool -c '.data.fields // []')

    # Find Status field (ranked dropdown with name containing "status")
    local status_field
    status_field=$(echo "$fields_data" | jq_tool -c '
        [.[] | select(
            (.name | ascii_downcase | contains("status")) and
            .valueType == "ranked-dropdown"
        )] | first // null
    ')

    local status_field_output="null"
    if [[ "$status_field" != "null" ]]; then
        local field_id=$(echo "$status_field" | jq_tool -r '.id')
        local field_name=$(echo "$status_field" | jq_tool -r '.name')
        local options=$(echo "$status_field" | jq_tool -c '.dropdownOptions // []')
        status_field_output=$(jq_tool -n \
            --arg fid "$field_id" \
            --arg fname "$field_name" \
            --argjson opts "$options" \
            '{fieldId: $fid, name: $fname, options: $opts}'
        )
    fi

    # Fetch saved views
    local saved_views
    saved_views=$(echo "$list_data" | jq_tool -c '.savedViews // []' | jq_tool -c 'map({viewId: .id, name: .name})')

    # Build field index (for field name resolution)
    local field_index
    field_index=$(echo "$fields_data" | jq_tool -c 'map({fieldId: .id, name: .name, valueType: .valueType, scope: .scope})')

    # Compose result
    local result
    result=$(jq_tool -n \
        --argjson listId "$list_id" \
        --arg listName "$list_name" \
        --arg listType "$list_type" \
        --argjson statusField "$status_field_output" \
        --argjson savedViews "$saved_views" \
        --argjson fieldIndex "$field_index" \
        '{
            list: {listId: $listId, name: $listName, type: $listType},
            statusField: $statusField,
            savedViews: $savedViews,
            fieldIndex: $fieldIndex
        }'
    )

    # Cache the result
    set_workflow_config_cached "$list_id" "$result" 2>/dev/null || true

    echo "$result"
}

# Resolve a list by name or ID
# Usage: resolve_list <name_or_id>
# Returns: list ID
resolve_list() {
    local name_or_id="$1"

    # If it looks like an ID, return it
    if [[ "$name_or_id" =~ ^[0-9]+$ ]]; then
        echo "$name_or_id"
        return 0
    fi

    # Search by name
    local result
    result=$(run_xaffinity_readonly list ls --output json --quiet \
        ${AFFINITY_SESSION_CACHE:+--session-cache "$AFFINITY_SESSION_CACHE"} 2>/dev/null)

    local list_id
    list_id=$(echo "$result" | jq_tool -r --arg name "$name_or_id" \
        '.data.lists[] | select(.name == $name) | .id' | head -1)

    if [[ -n "$list_id" ]]; then
        echo "$list_id"
        return 0
    fi

    return 1
}
